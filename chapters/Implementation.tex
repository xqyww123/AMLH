\chapter{用于智能合约的 \Eamlh 的实现}\label{Ch.Implementation}

\section{用于智能合约的抽象机器 \amlhS 在 HOL 上的实现}

首先论述 HOL 交互式定理证明器上用于智能合约的抽象机器 \amlhS 的实现，
这一实现通过 HOL 定理证明器上4867行的 SML 语言完成。
状态方面采用计算与状态分离的方案，将所有状态转移以指令的方式记录而在
智能合约所有计算完成后的最后写入区块链，这样更安全。

\begin{defin}[现象的定义] 类型 phenomenon 表示现象
\[ \begin{split}
\mathrm{phenomenon} \Coloneqq & \PhV\ \mathrm{num}\ 
\mathrm{num} \mbar \PhS\ \mathrm{phenomenon}\ 
\mathrm{phenomenon} \\
\mbar & \PhP \mathrm{phenomenon}
\end{split} \]
$\PhV x\ b$ 表示 $b$ 个二进制表示的数字 $x$。$\PhS p_1\ p_2$ 表示两个值
在内存上的直接拼接构成的现象。$\PhP p$ 表示对现象 $p$ 的指针。
\[ \begin{array}{lcllcl}
\PB\ (\PhV x\ b) &\coloneqq& b&
\PX\ (\PhV x\ b) &\coloneqq& x\\
\PB\ (\PhS p_1\ p_2) &\coloneqq& \PB p_1 + \PB p_2\quad\quad&
\PX\ (\PhS p_1\ p_2) &\coloneqq& \PX(p_1) + \PX(p_2) \cdot 256^{\PB(p_1)}\\
\PB\ (\PhP p) &\coloneqq& \mathrm{PointerSize} &&&
\end{array} \]
$\PX\ (\PhP p)$ 故意的不去定义。PointerSize 为常量固定为智能合约执行环境
的位数，一般为32。
现象的分割工具，函数 $\PL,\ \PU$
    \begin{align*} \PL n\ p &= \PhV\ (\PX p \Mod 256^n)\ n&
        \PU n\ p &= \PhV\ (\PX p \Div 256^n)\ (\PB p \dotminus n)&
    \end{align*}
合法的现象
\begin{gather*} \begin{align*}
\VP\ (\PhV\ x\ b) &\coloneqq (x < 256^b)&
\VP\ (\PhP\ p) &\coloneqq \VP p&
\end{align*}\\
\VP\ (\PhS\ p_1\ p_2) \coloneqq \VP p_1 \ \land\ \VP p_2
\end{gather*}
现象集的 0 元素是 $\mathbf{PhV}\ 0\ 0$，
占用0个比特位的值，且其是合法的。
\end{defin}

\begin{defin}[\amlhS 上的理解]
\amlhS 上理解的定义基本基于定义 \ref{Def.itp} ，只是固定了理解的现象集
的位数目。
    \[ \begin{split}
        \itp{\alpha} \Coloneqq \mathbf{Noesis}\ &(\alpha \rightarrow \phenomenon)
        \ (\phenomenon \rightarrow \alpha)\\
    &(\alpha\ \mathrm{set})\ (\phenomenon\ \mathrm{set})\ \mathrm{num}
    \end{split} \]
\begin{gather*}
\begin{align*}
\mathbf{NOE\_LIGHT}\ (\mathbf{Noesis}\ l\ tr\ s_e\ s_p\ s) & = l&
\mathbf{NOE\_TRANSCEND}\ (\mathbf{Noesis}\ l\ tr\ s_e\ s_p\ s) & = tr&\\
\mathbf{NOE\_SET}\ (\mathbf{Noesis}\ l\ tr\ s_e\ s_p\ s) & = s_e&
\mathbf{NOE\_SIZE}\ (\mathbf{Noesis}\ l\ tr\ s_e\ s_p\ s) &= s&
\end{align*}\\
\mathbf{NOE\_PSET}\ (\mathbf{Noesis}\ l\ tr\ s_e\ s_p\ s)
 = s_p \cap \{ p \mbar \PB p = s \}
 \end{gather*}
同样有记号
\begin{gather*}
\begin{align*}
    \mathbf{Li}_i\ & \coloneqq \mathbf{NOE\_LIGHT}\ i&
    \mathbf{Tr}_i\ & \coloneqq \mathbf{NOE\_TRANSCEND}\ i &
\end{align*}\\ \begin{align*}
    \mathbf{Sp}_i\ & \coloneqq \mathbf{NOE\_PSET}\ i&
    \mathbf{Si}_i\ & \coloneqq \mathbf{NOE\_SIZE}\ i&
    \mathbf{Se}_i\ & \coloneqq \mathbf{NOE\_SET}\ i&
\end{align*} \end{gather*}
$\mathbf{Si}_i$ 表示理解 $i$ 的现象集的比特数。
\end{defin}

\begin{defin}[\amlhS 的 Noesis 对应] 在定义 \ref{Def.TR} 的基础上
加入现象合法性。
\[ p \widesim{i} e \coloneqq \mathbf{V}_i\ \land\ \VP\ p\ \land\ 
p \in \mathbf{Sp}_i\ \land\ (\mathbf{Tr}_i\ p = e) \]
\end{defin}

其余理论均与第 \ref{Ch.AmLH} 章相同。

\begin{defin}[链的抽象表达]
\amlhS 将链上数据抽象为各个由标识区分的键值表，使用有限映射表示，
类型 chain 为此别名 
\[ \mathrm{chain} \Coloneqq (\mathrm{string},\ \mathrm{phenomenon})
\mapsto \mathrm{phenomenon} \]
链数据是作为字符串的表标识与作为现象的键的元组到作为现象的值的有限映射。
$\Dom_c\ \phi,\ \Ima_c\ \phi$ 表示一个链数据 $\phi$ 的名为 $c$ 的表
的所有键与值
  \[ \begin{array}{lcl}
    \Dom_c\ \phi &=& \{x\mbar (c,x) \in \Dom \phi\} \\
    \Ima_c\ \phi &=& \{\phi\ (c,x) \mbar (c,x) \in \Dom \phi \}
\end{array} \]
类型 chain\_table 综合了表标识与键值理解
  \begin{gather*}
  \combtyp{chain\_table}{(\alpha,\ \beta)} \Coloneqq \mathbf{TC}\ 
  \mathrm{string}\ (\itp{\alpha})\ (\itp\beta)\\
  \begin{align*}
    (\mathbf{TC}\ c\ i\ j)_\mathrm{c} &\coloneqq c&
    (\mathbf{TC}\ c\ i\ j)_\mathrm{i} &\coloneqq i&
    (\mathbf{TC}\ c\ i\ j)_\mathrm{j} &\coloneqq j&
  \end{align*} \end{gather*}
记号 $\phi^{(\mathbf{TC}\ c\ i\ j)}$ 表示链数据 $\phi$ 的标识为 $c$ 的表
在键理解 $i$ 与值理解 $j$ 的作用下的本体对应
\[ \begin{array}{lrcl}
  &\phi^{(\mathbf{TC}\ c\ i\ j)} &=& \Tr_j \ccirc\ \phi \ccirc \Li_i\\
    \Dom&\phi^{(\mathbf{TC}\ c\ i\ j)} &=& \{\epsilon\mbar (c,\Li_i 
    \epsilon) \in \Dom \phi\} \\
    \Ima&\phi^{(\mathbf{TC}\ c\ i\ j)} &=& \{\Tr_j(\phi\ (c,\Li_i 
    \epsilon))\mbar (c,\Li_i \epsilon) \in \Dom \phi \}
\end{array} \]
$t_0$ 为表 $t$ 的零元素
  \[ (\mathbf{TC}\ c\ i\ j)_0 = \Tr_j\ (\PhV\ 0\ \Si_j) \]
类型 write\_chain 表示对链的写入操作命令，也是一个别名
\[ \mathrm{write\_chain} \Coloneqq ((\mathrm{string},\ 
\mathrm{phenomenon}),\ \mathrm{phenomenon}) \]
元组 $((name,\ key),\ value)$ 表示以值 $value$ 写入到表 $name$ 的
键 $key$ 的写入操作。
有限映射的更新操作 $\fupdate$ 就表示对链数据的写入。
一系列辅助函数 
\begin{gather*} \begin{array}{lcl}
\Has &:& \combtyp{table}{(\alpha,\ \beta)} \rightarrow \mathrm{chain}
  \rightarrow \alpha \rightarrow \mathrm{bool}\\
  \Read &:& \combtyp{table}{(\alpha,\ \beta)} \rightarrow
  \mathrm{chain} \rightarrow \alpha \rightarrow \beta \\
  \ReadZ &:& \combtyp{table}{(\alpha,\ \beta)} \rightarrow
  \mathrm{chain} \rightarrow \alpha \rightarrow \beta \\
  \Write &:& \combtyp{table}{(\alpha,\ \beta)} \rightarrow
  \alpha \rightarrow \beta \rightarrow \mathrm{write\_chain}
\end{array}\\
\begin{array}{lcl}
\Has\ (\TC c\ i\ j)\ \phi\ k &\coloneqq& (c,\ \Li_i k) \in \Dom \phi\\
\Read\ (\TC c\ i\ j)\ \phi\ k &\coloneqq& \Tr_j(\phi\ (c,\ \Li_i\ k))\\
  \ReadZ\ (\TC c\ i\ j)\ \phi\ k &\coloneqq& \left\{ \begin{split}
&\xif \Has\ (\TC c\ i\ j)\ \phi\ k \xthen \Tr_j(\phi\ (c,\ \Li_i\ k))\\
  &\quad\quad\quad\xelse \Tr_j(\PhV\ 0\ \Si_j) \end{split} \right. \\
\Write\ (\TC c\ i\ j)\ k\ v &\coloneqq& ((c,\ \Li_i k),\ \Li_j v)
\end{array} \end{gather*}
有一些显然的定理
  \[ \begin{array}{rclcl}
    &\vdash&\Has\ t\ \phi\ k &=& k \in \phi^t\\
    &\vdash&\Read\ t\ \phi\ k &=& \phi^t\ k\\
    &\vdash&\ReadZ\ t\ \phi\ k &=& \xif k \in \phi^t \xthen
    \phi^t\ k \xelse t_0\\
    &\vdash&\Read\ t\ (\phi \fupdate \Write\ t\ k\ v)\ k' &=&
    (\xif k = k' \xthen v \xelse \Read\ t\ \phi\ k') \\
  t_1 \neq t_2 &\vdash& \Read\ t_1\ (\phi \fupdate \Write\ 
    t_2\ k\ v)\ k' &=& \Read\ t_1\ \phi\ k' \\
    &\vdash&\ReadZ\ t\ (\phi \fupdate \Write\ t\ k\ v)\ k' &=&
    (\xif k = k' \xthen v \xelse \ReadZ\ t\ \phi\ k') \\
    t_1 \neq t_2 &\vdash& \ReadZ\ t_1\ (\phi \fupdate \Write\ 
    t_2\ k\ v)\ k' &=& \ReadZ\ t_1\ \phi\ k' \\
    &\vdash& \ReadZ\ t\ \emptyset\ k &=& t_0 \\
    k \in \phi^t &\vdash& \Ima_t\ (\phi \fupdate \Write\ t\ k\ v) 
    &=& \Ima \phi^t - \{ \phi^t\ k \} \cup \{ v \}\\
    k \notin \phi^t &\vdash& \Ima_t\ (\phi \fupdate \Write\ t\ k\ v) 
    &=& \Ima \phi^t \cup \{ v \}
  \end{array} \]
\end{defin}

\begin{defin}[智能合约调用响应]
类型 response 表示所期望的智能合约调用的返回类型。
  \[ \combtyp{response}{\alpha} \Coloneqq ((\combtyp{list}{
    \mathrm{write\_chain}}),\ \alpha) \]
$(l,\ x)$ 表示以 $x$ 为返回值，$l$ 为链数据写入命令序列的智能合约调用
响应。$l$ 列表中的每一项元素都是 write\_chain 类型描述的链数据的写入命令
。一个智能合约的作为外部接口的函数必须返回 response 类型，编译时会在
每个外部接口函数的实现的最后逐一遍历写入命令序列 $l$，逐一将命令执行并
写入进链中。智能合约调用响应在实现上的内存结构是
\begin{center}
\begin{tabular}{|c|c|} \hline
\text{指向写入命令序列 $l$ 的指针}&\text{计算结果 $x$}\\
\text{PointerSize bytes}&\text{$\mathbf{Si}_i$ bytes}\\ \hline
\end{tabular}
\end{center}
\end{defin}

\amlhS 所有定义的理解列于表 \ref{tab.IC.noesis} 与表 
 \ref{tab.IC.noesis2} 中。所有的基元指令及其定义与 Noesis 同构列于
表 \ref{tab.IC.primop} 与表 \ref{tab.IC.primop2} 中。

\begin{table}[hp]
\begin{threeparttable}
\centering \caption{\amlhS 中实现的理解} \label{tab.IC.noesis}
\begin{tabularx}{\linewidth}{ |c|c|c|c|X|p{2cm}| } \hline
\textbf{理解} & \textbf{本体集} & \textbf{现象集} & 
$\mathbf{Si}$ \textbf{值} & $\mathbf{Li}$ \textbf{映射} & 
$\mathbf{Tr}$ \textbf{映射} \\ \hline
$\NatSegI\ n$ & $\{x\mbar x < n\}$ & $\mathbb{U}_\mathrm{pv}$ &
$\lceil \log_{256}\ n \rceil$ & 
$\lambda e.\ \PhV e\ \lceil \log_{256}\ n \rceil$ & $\PX$ 
\\ \hline
$\BoolI$ & $\univ{bool}$ & $\mathbb{U}_\mathrm{pv}$ & $1$ &
$\lambda e.\ \PhV\ ($\newline$\xif\ e\ \xthen\ 1\ \xelse\ 0)\ 1$&
$\lambda v.$ \newline $\PX v > 0$  \\ \hline 
$\AddressI$ & $\{ n \mbar n < \mathrm{AdrSize} \}$ &
$\mathbb{U}_\mathrm{pv}$ & AdrSize & $\lambda e.\ \PhV
e\ \mathrm{AdrSize}$ & $\PX$ \\ \hline
$\OneI\ x$ & $\{ x \}$ & $\mathbb{U}_\mathrm{pv}$ & 0 & 
$\K(\PhV 0\ 0)$ & $\K x$ \\ \hline
$\ListI\ i$ & $\mathrm{EVERY}\ \mathbf{Se}_i$ & 虚构 & Ps & 虚构 
& 虚构 \\ \hline
$\CWI$ & $(\mathbb{U}_\mathrm{str} \times \mathbb{U}_\mathrm{ph}) \times
\mathbb{U}_\mathrm{ph}$ & 虚构 & $1 + 2 \mathrm{Ps}$ & 虚构 
& 虚构 \\ \hline
$i \times j$ & $\mathbf{Se}_i \times \mathbf{Se}_j$ & 
见注1 & $\Si_i + \Si_j$ & $\lambda(x,y).\ \PhS\ \Li_i(x)\ 
\Li_j(x)$ & 见注2 \\ \hline
\end{tabularx}
\begin{tablenotes} \small 
\item $\mathbb{U}_\mathrm{pv}$ 是 $\{ \PhV x\ b \}$ 的简写，
表示现象类型的所有元素中由 $\PhV$ 构造的。
$\mathbb{U}_\mathrm{ph}$ 是 $\univ{phenomenon}$ 的简写，
表示现象类型中所有的元素。
$\mathbb{U}_\mathrm{str}$ 是 $\univ{string}$ 的简写。
$\mathrm{Ps}$ 是 PointerSize 的简写。
 EVERY 是 HOL 系统库中的函数，$\mathrm{EVERY}\ s$ 
表示所有元素都属于 $s$ 集的所有列表构成的集合。
\item[注1] 理解 $i \times j$ 的现象集是 $\{\PhS p_1\ p_2
\mbar p_1\in \Sp_i\land p_2 \in \Sp_j\}$，表格空间有限故列于此。
\item[注2] 理解 $i \times j$ 的\textbf{Tr}映射是 
    $\lambda p.\ (\Tr_i(\PL\ \Si_i\ p),\ \Tr_j(\PU\ \Si_i\ p))$，
    表格空间有限故列于此。
\end{tablenotes}
\end{threeparttable}
\newline \newline
\begin{threeparttable}
\centering \caption{\amlhS 中实现的理解（绪）} \label{tab.IC.noesis2}
\begin{tabular}{ |c|p{14.8cm}| } \hline
\textbf{理解} & \textbf{描述} \\ \hline
$\NatSegI\ n$ & 不超过 $n$ 的自然数 \\ \hline
$\BoolI$ & bool 值 \\ \hline $\AddressI$ & 
智能合约场景下的账户标识，在以太坊中是 \texttt{address} 类型，
EOS.IO 中是 \texttt{name} 类型，常量 AdrSize 表示标识的大小，
    以字节为单位\\ \hline
  $\OneI\ x$ & 单元素集合 $\{x\}$ 的理解，用于表示状态输入 \\ \hline
$\ListI\ i$ & 对元素使用 $i$ 理解的列表理解，虚构定义而来，
在内存中的表示是一个指针，故有 PointerSize 的大小 \\ \hline
$\CWI$ & 是链数据的写入命令的理解，虚构定义而来 \\ \hline
$i\times j$ & 表示理解 $i,\ j$ 的笛卡儿积 \\ \hline
\end{tabular}\end{threeparttable}\end{table}%
\begin{table}[hp]%
\begin{threeparttable}
\centering \caption{\amlhS 中的常量} \label{tab.IC.const}
\begin{tabularx}{\linewidth}{ |c|c|X| }\hline
  \textbf{常量} & \textbf{Noesis 对应} & \textbf{定义与描述} \\ \hline
$\Li_{\NatSegI n} x$ & $\Li_{\NatSegI n} x \widesim[2]{\NatSegI\ n}
  x$ & $\Li_{\NatSegI n} x = \PhV\ x\ \B_n \quad\quad$ 自然数常量
\\\hline\emptylist & $\emptylist \widesim{\ListI\ i} \mathrm{Nil}$ &
  虚构定义而来，Nil 是 HOL 中定义的空序列。\\ \hline
\texttt{T} & $\texttt{T} \widesim{\BoolI} \T$ & $\texttt{T} = \PhV 1\ 1$
\\ \hline 
\texttt{F} & $\texttt{F} \widesim{\BoolI} \F$ & $\texttt{F} = \PhV 0\ 1$
\\ \hline
\end{tabularx}
\end{threeparttable}%
  \newline \newline
\begin{threeparttable}%
\centering \caption{\amlhS 中基元函数的定义} \label{tab.IC.primop2}
\begin{tabularx}{\linewidth}{ |c|X| }\hline
\textbf{基元函数} & \textbf{定义} \\ \hline
$\mathbf{IAdd}\ n$ & $\PB p_1 = \PB p_2 = n \vdash
\mathbf{IAdd}\ n\ p_1\ p_2 \coloneqq
\PhV\ (\PX p_1 + \PX p_2 \mod 256^n)\ n$ \\ \hline
$\mathbf{ISub}\ n$ & $\PB p_1 = \PB p_2 = n \vdash
\mathbf{ISub}\ n\ p_1\ p_2 \coloneqq
\PhV\ (\PX p_1 - \PX p_2 \mod 256^n)\ n$ \\ \hline
$\mathbf{IMul}\ n$ & $\PB p_1 = \PB p_2 = n \vdash
\mathbf{IMul}\ n\ p_1\ p_2 \coloneqq
\PhV\ (\PX p_1 * \PX p_2 \mod 256^n)\ n$ \\ \hline
$\mathbf{ILt}\ n$ & $\PB p_1 = \PB p_2 = n \vdash
\mathbf{ILt}\ n\ p_1\ p_2 \coloneqq
\PhV\ (\xif \PX p_1 < \PX p_2 \xthen 1 \xelse 0)\ n$ \\ \hline
$\mathbf{ILe}\ n$ & $\PB p_1 = \PB p_2 = n \vdash
\mathbf{ILe}\ n\ p_1\ p_2 \coloneqq
\PhV\ (\xif \PX p_1 \leq \PX p_2 \xthen 1 \xelse 0)\ n$ \\ \hline
$\mathbf{IEq}\ n$ & $\PB p_1 = \PB p_2 = n \vdash
\mathbf{IEq}\ n\ p_1\ p_2 \coloneqq
\PhV\ (\xif \PX p_1 = \PX p_2 \xthen 1 \xelse 0)\ n$ \\ \hline
    $\mathbf{IConv}_{m,n}$ & $\PB p = m \vdash
\mathbf{IConv}_{m,n}\ p \coloneqq \PhV\ (\PX p \Mod 256^n)\ n$ \\\hline
$\mathbf{INot}$ & $ \PB p = 1 \vdash
\mathbf{INot}\ p = \PhV\ (\xif \PX p = 0 \xthen 1 \xelse 0)\ 1$\\ \hline
$\mathbf{Append}\ i$ & 虚构定义自同构
$\mathbf{Append}\ i \proctr{i|\ListI\ i|\ListI\ 
i}{\lambda x\ l.\ \T} (::)$ \\ \hline
  $\mathbf{Write}\ t$ & 虚构定义自同构 $\mathbf{Write}\ t
  \proctr{i|j|\CWI}{\lambda k\ v.\ \T} \Write t$ \\ \hline
$\mathbf{Read}\ t$ & 虚构定义自同构 $\mathbf{Read}\ t
  \proctr{\OneI\ x|i|j}{\Has\ t} \Read t$ \\ \hline
$\mathbf{Has}\ t$ & 虚构定义自同构 $\mathbf{Has}\ t
  \proctr{\OneI\ x|i|\BoolI}{\lambda x\ k.\ \T} \Has t$ \\\hline
$\mathbf{Read0}\ t$ & 虚构定义自同构 
$\mathbf{Read0}\ t \proctr{\OneI\ x|i|j}{\lambda x\ k.\ \T} \ReadZ\ t$
  \\\hline
$\mathbf{Cart}\ n_1\ n_2$ & $\PB p_1 = n_1,\ \PB p_2 = n_2 \vdash
  \mathbf{Cart}\ p_1\ p_2 \coloneqq \PhS p_1\ p_2$ \\ \hline
    $\mathbf{Seg}_{l,m,n}$ & $\PB p = l \vdash
    \mathbf{Seg}_{l,m,n}\ p \coloneqq 
    \PhV\ (\PX p \Div 256^m \Mod 256^n)\ n$ \\ \hline
$\mathbf{If}$ & $\PB p_c = 1\vdash \mathbf{If}\ p_c\ p_a\ p_b 
  \coloneqq \xif \PX p_c = 1 \xthen p_a \xelse p_b$ \\ \hline
\end{tabularx}\end{threeparttable}\end{table}
\begin{table}[hp]\begin{threeparttable}
\centering \caption{\amlhS 中基元函数的 Noesis 同构}
\label{tab.IC.primop} \begin{tabular}{ |c|p{5.4cm}|p{7.7cm}| } \hline
\textbf{基元函数} & \textbf{ Noesis 同构 } & \textbf{描述} \\ \hline
$\mathbf{IAdd}\ \B_n$ &
$\mathbf{IAdd}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
\NatSegI\ n}{\lambda x\ y.\ x + y < 256^n} (+) $ &
$\B_n$ 字节整数加法的自然数加法对应 \\ \hline
$\mathbf{ISub}\ \B_n$ & $\mathbf{ISub}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
\NatSegI\ n}{\lambda x\ y.\ x \geq y} (-)$ & $\B_n$ 字节整数减法的自然数减法
对应 \\ \hline
  $\mathbf{IMul}\ \B_n$ & $\mathbf{IMul}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
\NatSegI\ n}{\lambda x\ y.\ x * y < 256^n} (\times)$ & $\B_n$ 字节整数乘法
的自然数乘法对应 \\ \hline
  $\mathbf{ILt}\ \B_n$ & $\mathbf{ILt}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
\BoolI}{\lambda x\ y.\ \T} (<)$ & $\B_n$ 字节整数小于判断的自然数小于对应 
\\ \hline
$\mathbf{ILe}\ \B_n$ & $\mathbf{ILe}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
\BoolI}{\lambda x\ y.\ \T} (\leq)$ & $\B_n$ 字节整数小于等于的自然数小于等于对应 \\ \hline
$\mathbf{IEq}\ \B_n$ & $\mathbf{IEq}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
\BoolI}{\lambda x\ y.\ \T} (=)$ & $\B_n$ 字节整数等于判断的自然数等于对应 \\ \hline
$\mathbf{IEq}\ \mathrm{AdrSize}$ & $\mathbf{IEq}\ \mathrm{AdrSize}
\proctr{\AddressI|\AddressI|\BoolI}{\lambda x\ y.\ \T} (=)$ & 
$\B_n$ 字节整数等于判断的账户标识对应 \\ \hline
$\mathbf{IConv}\ \Si_i\ \Si_j$ & $\mathbf{IConv}\ \Si_i\ \Si_j \proctr
    {\NatSegI\ \Si_i|\NatSegI\ \Si_j}{\lambda x.\ x < 256^{\Si_j}}\I$
    & 表示自然数的现象的等值范围变换 \\ \hline
$\mathbf{INot}$ & $\mathbf{INot} \proctr{\BoolI|\BoolI}
{\lambda x.\ \T} (\lnot)$ & bool 值取反 \\ \hline
$\mathbf{Append}\ i$ & $\mathbf{Append}\ i \proctr{i|\ListI\ i|\ListI\ 
i}{\lambda l\ x.\ \T} (::)$ & 增加元素到列表的末尾，$(::)$
是 HOL 系统库中列表的增加函数，$1::[2]$ 表示 $[1,2]$ \\ \hline
$\mathbf{Has}\ t$ & $\mathbf{Has}\ t \proctr{\OneI\ x|i|\BoolI}
{\K (\K \T)} \Has\ t$ &
查询链数据$x$的标识为$c$的表是否拥有键 $k$
  \\ \hline
$\mathbf{Read}\ t$ & $\mathbf{Read}\ t\proctr{\OneI\ x|i|j}{\Has t}
  \Read\ t$ &
读取链数据$x$的标识为$c$的表的$k$键 \\ \hline
$\mathbf{Read0}\ t$ & $\mathbf{Read0}\ t \proctr{\OneI\ x|i|j}
  {\K (\K \T)} \ReadZ\ t$ &
若链数据$x$的表$c$中存在$k$键则读取，否则返回 $j$ 理解的字节大小的0值
\\ \hline $\mathbf{Write}\ t$ & $\mathbf{Write}\ t \proctr{i|j|\CWI}
  {\lambda k\ v.\ \T} \Write\ t$ &
写入链数据的表$c$的键$k$为$v$的操作，产生写入命令 \\ \hline
$\mathbf{Cart}\ \Si_i\ \Si_j$ & $\mathbf{Cart}\ \Si_i\ \Si_j
  \proctr{i|j|i\times j}{\lambda x\ y.\ \T}$\newline
  $(\lambda x\ y.\ (x,\ y))$ & 合并两个值而构造元组 \\ \hline
$\mathbf{Cart}\ \Si_i\ \Si_j$ & $\mathbf{Cart}\ \Si_i\ \Si_j
  \proctr{\ListI\ \CWI|i|\RsI\ i}
  {\lambda l\ x.\ \T}$\newline$(\lambda l\ x.\ (l,\ x))$ &
  当第一个元素为链写入指令序列时，由定义 
  \ref{D.contract.interface} 此元组就构成了智能合约的响应 \\ \hline
$\mathbf{Seg}_{\Si_i+\Si_j,0,\Si_i}$ & $\mathbf{Seg}_
  {\Si_i+\Si_j,0,\Si_i} \proctr{i\times j|i}{\K \T} \mathrm{fst}$ &
取出元组的第一个元素 \\ \hline
    $\mathbf{Seg}_{\Si_i+\Si_j,\Si_i,\Si_j}$ & $
    \mathbf{Seg}_{\Si_i+\Si_j,\Si_i,\Si_j} 
    \proctr{i\times j|j}{\K \T} \mathrm{snd}$ &
取出元组的第二个元素 \\ \hline
  \textbf{If} & 不具有 Noesis 同构，但具有类似性质，见定理
  \ref{T.If.prop}& 分支 \\ \hline
\end{tabular}
  \begin{tablenotes} \small
  \item 因空间不够，记号 $\B_n \coloneqq \lceil \log_{256} n \rceil$。
    fst 与 snd 在 HOL 中预定义。
\end{tablenotes}
\end{threeparttable} 
\end{table}

\begin{theo}[分支 $\mathbf{If}$ 的性质] \label{T.If.prop}
值得一提的是分支 $\mathbf{If}$，其定义已在表 \ref{tab.IC.primop2} 中列出
，其不具有 Noesis 同构形式的性质，而是
\[ \begin{split}
\forall p_c\ P\ p_a\ i\ \epsilon_a\ p_b\ &\epsilon_b.\ 
  p_c \widesim{\BoolI} P \Rightarrow (P \Rightarrow p_a \widesim{i}
  \epsilon_a) \Rightarrow (\lnot P \Rightarrow p_b \widesim{i}
  \epsilon_b) \Rightarrow \\
  & \mathbf{If}\ p_c\ p_a\ p_b \widesim{i} \xif P \xthen \epsilon_a
  \xelse \epsilon_b
\end{split} \]
  \begin{proof} 若 $\PX p_c = 1$ 则由 $\mathbf{If}$ 定义，有
   $ \mathbf{If}\ p_c\ p_a\ p_b = p_a $，
  再由理解 $\BoolI$ 前提 $p_c \widesim {\BoolI} P$ 下 $P = \T$ 于是
    有 $p_a \widesim{i} \epsilon_a$ 于是命题得证。
若 $\PX p_c \neq 1$ 则由 $\mathbf{If}$ 定义，有
   $ \mathbf{If}\ p_c\ p_a\ p_b = p_b $，
  再由理解 $\BoolI$ 前提 $p_c \widesim {\BoolI} P$ 下 $P = \F$ 于是
    有 $p_b \widesim{i} \epsilon_b$ 于是命题得证。
  \end{proof}
\end{theo}

\begin{defin}[智能合约的外部接口] \label{D.contract.interface}
定义理解 $\RsI\ i$ 表示以 $i$ 理解为返回内容的智能合约调用响应
  \[ \RsI\ i \coloneqq i \times (\ListI\ \CWI) \]
所有 \amlhS 的智能合约所暴露的可供外部调用的接口应是一种现象函数，
且其具有至少一种 Noesis 同构，此同构满足第一个参数的理解必为 
$\OneI\ (x:\mathrm{chain})$，且返回值的理解必为 $\RsI\ k$。即
函数 $f$ 应满足如下形式的 Noesis 同构
\[ f \proctr{\OneI\ x|\cdots|\RsI\ k}{cond} \phi \]
\end{defin}

表 \ref{tab.IC.primop2} 定义的基元指令可以直接应用但过于基层，
诸如$\mathbf{IAdd}\ n$ 操作要求给定运算的位宽，显然并不适宜要求用户
每次都显示地给出位宽。\amlhS 提供基于这些基元函数构建的高层函数库。

$\mathbf{AddN_S},\ \mathbf{SubN_S},\ \mathbf{MulN_S},\ 
\mathbf{LeN_S},\ \mathbf{LtN_S},\ \mathbf{EqN_S}$ 
提供自动范围扩张的自然数运算。
\begin{align*}
  \mathbf{AddN_S}\ n\ m\ p\ q \coloneqq\ & \mathbf{IAdd}\ \max(\B_n,\B_m)\ 
  (\xif \B_n \geq \B_m \xthen p \xelse \mathbf{IConv}\ \B_n\ \B_m\ p)\\
  &(\xif \B_m \geq \B_n \xthen p \xelse \mathbf{IConv}\ \B_m\ \B_n\ q)\\
\mathbf{SubN_S}\ n\ m\ p\ q \coloneqq\ & \mathbf{ISub}\ n\ p\ 
  (\xif \B_m = \B_n \xthen p \xelse \mathbf{IConv}\ \B_m\ \B_n\ q)\\
\mathbf{MulN_S}\ n\ m\ p\ q \coloneqq\ & \mathbf{IMul}\ \max(\B_n,\B_m)\ 
  (\xif \B_n \geq \B_m \xthen p \xelse \mathbf{IConv}\ \B_n\ \B_m\ p)\\
  &(\xif \B_m \geq \B_n \xthen p \xelse \mathbf{IConv}\ \B_m\ \B_n\ q)\\
\mathbf{LeN_S}\ n\ m\ p\ q \coloneqq\ &\mathbf{ILe}\ \max(\B_n,\B_m)\ 
  (\xif \B_n \geq \B_m \xthen p \xelse \mathbf{IConv}\ \B_n\ \B_m\ p)\\
  &(\xif \B_m \geq \B_n \xthen p \xelse \mathbf{IConv}\ \B_m\ \B_n\ q)\\
\mathbf{LtN_S}\ n\ m\ p\ q \coloneqq\ &\mathbf{ILt}\ \max(\B_n,\B_m)\ 
  (\xif \B_n \geq \B_m \xthen p \xelse \mathbf{IConv}\ \B_n\ \B_m\ p)\\
  &(\xif \B_m \geq \B_n \xthen p \xelse \mathbf{IConv}\ \B_m\ \B_n\ q)\\
\mathbf{EqN_S}\ n\ m\ p\ q \coloneqq\ &\mathbf{IEq}\ \max(\B_n,\B_m)\ 
  (\xif \B_n \geq \B_m \xthen p \xelse \mathbf{IConv}\ \B_n\ \B_m\ p)\\
  &(\xif \B_m \geq \B_n \xthen p \xelse \mathbf{IConv}\ \B_m\ \B_n\ q)\\
\end{align*}
\[ \begin{array}{lcr} \forall n\ m.\ 
  \mathbf{AddN_S}\ n\ m &\proctr{\NatSegI\ n|
  \NatSegI\ m|\NatSegI\ \max(n,m)}{\lambda x\ y.\ x + y < \max
  (n,m)}& (+) \\\forall n\ m.\ 
  \mathbf{SubN_S}\ n\ m &\proctr{\NatSegI\ n|
\NatSegI\ m|\NatSegI\ n}{\lambda x\ y.\ x \geq y}& (-)\\ \forall n\ m.\ 
  \mathbf{MulN_S}\ n\ m &\proctr{\NatSegI\ n|
  \NatSegI\ m|\NatSegI\ \max(n,m)}{\lambda x\ y.\ x \times y < \max
  (n,m)}& (\times)\\ \forall n\ m.\ 
  \mathbf{LeN_S}\ n\ m &\proctr{\NatSegI\ n|
\NatSegI\ m|\NatSegI\ \max(n,m)}{\K\ (\K \T)}& (\leq)\\ \forall n\ m.\ 
  \mathbf{LtN_S}\ n\ m &\proctr{\NatSegI\ n|
  \NatSegI\ m|\NatSegI\ \max(n,m)}{\K\ (\K \T)}& (<)\\ \forall n\ m.\ 
  \mathbf{EqN_S}\ n\ m &\proctr{\NatSegI\ n|
  \NatSegI\ m|\NatSegI\ \max(n,m)}{\K\ (\K \T)}& (=)
\end{array} \] \newline
容易证明 $\mathbf{AddN_S},\ \mathbf{SubN_S},\ \mathbf{MulN_S},\ 
\mathbf{LeN_S},\ \mathbf{LtN_S},\ \mathbf{EqN_S}$ 具有
上述 Noesis 同构，允许进行如下的定理推导以程序构造。
\begin{center}
\begin{prooftree}
  \AxiomC{$\forall n\ m.\ \mathbf{AddN_S}\ n\ m \proctr{\NatSegI\ n|
  \NatSegI\ m|\NatSegI\ \max(n,m)}{\lambda x\ y.\ x + y < \max
  (n,m)} (+)$} 
  \AxiomC{$x \widesim{\NatSegI\ 42} \omega$}
  \RightLabel{(Noesis 调用)} \BinaryInfC{$\forall m.\ 
  \mathbf{AddN_S}\ 42\ m\ x \proctr{\NatSegI\ m|\NatSegI\ \max(42,m)}
  {\lambda y.\ \omega + y < \max(42,m)} (+\ \omega)$}
\end{prooftree}
  \begin{prooftree}
    \AxiomC{$\omega + \upsilon < 666$}
\AxiomC{$\forall m.\ 
\mathbf{AddN_S}\ 42\ m\ x \proctr{\NatSegI\ m|\NatSegI\ \max(42,m)}
  {\lambda y.\ \omega + y < \max(42,m)} (+\ \omega)$}
  \AxiomC{$y \widesim{\NatSegI\ 666} \upsilon$}
  \RightLabel{(Noesis 调用)}
  \BinaryInfC{$\mathbf{AddN_S}\ 42\ 666\ x\ y \proctr{\NatSegI\ 666}
  {\omega + \upsilon < 666} (\omega + \upsilon)$}
    \RightLabel{(Noesis 条件削除)}
    \BinaryInfC{$\mathbf{AddN_S}\ 42\ 666\ x\ y \widesim{\NatSegI\ 666} 
    \omega + \upsilon$}
  \end{prooftree}
\end{center}
而在编译时，将 $\mathbf{AddN_S}\ 42\ 666\ x\ y$ 根据定义展开
\[ \begin{split}
\mathbf{AddN_S}\ 42\ 666\ x\ y =\ & \mathbf{IAdd}\ \max(\B_{42},\B_{666})\ 
  (\xif \B_{42} \geq \B_{666} \xthen x \xelse \mathbf{IConv}\ \B_{42}\ \B_{666}\ x)\\
  &(\xif \B_{666} \geq \B_{42} \xthen x \xelse \mathbf{IConv}\ \B_{666}\ \B_{42}\ y)\\
  =\ & \mathbf{IAdd}\ 2\ (\mathbf{IConv}\ 1\ 2\ x)\ y
\end{split} \]
就得到了编译结果 $\mathbf{IAdd}\ 2\ (\mathbf{IConv}\ 1\ 2\ x)\ y$。

附录 \ref{Ch.example.transfer} 给出了一个完整的 \amlhS 上转账合约的示例。

\input{chapters/implementation/compilation.tex}
