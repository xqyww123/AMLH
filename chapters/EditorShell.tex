\chapter{\ES 编辑壳层}

$\amlh$ 已经在上一章论述清楚。但$\amlh$只是一个抽象机理论，尽管被
定义在 HOL 交互式证明工具的 HOL 逻辑上，借助定理证明工具似乎具象了一点，
但显然不能让用户直接操作数学命题与定理。
需要有一个壳层包裹起$\amlh$理论并向外提供给用户编辑程序的功能，
这是本章将论述的编辑壳层\ES 的意义。

\section{\ES 概述}

实际实现中，上一章的 $\amlh$ 运作在 HOL 交互式定理证明器上，是其中的
理论。要操作 $\amlh$ 以在其上开发程序必须届由 HOL 交互式定理证明器完成。
HOL 定理证明器是一个构建在 SML 语言上的工具，或是不准确但更易于理解地说
，一个 SML 语言的库（library）。
HOL 证明器始终运行在 SML 解释器环境下，其执行程序就是加载了 HOL 工具
并被轻微改造过的 SML 解释器。HOL 证明器暴露了一系列 SML 函数并装入
SML 解释环境中，需要通过编写调用这些函数的 SML 语句并交由 SML 解释器
执行以操作 HOL 证明器工作。

这样对于期望使用 $\amlh$ 的用户，这个体系意味着至少要经过两层，
先编写 SML 语句操作 HOL 证明器，进而操作其上定义的 $\amlh$ 理论，
最后用 $\amlh$ 理论中定义的定理与证明策略构造程序。
这显然难以接受。

\ES  就为此而生，构造一个壳层包裹起一切的中间环节而提供给用户
一个简单的接口，允许轻松地在 $\amlh$ 上进行程序开发。

\ES  壳层首先构造了一种形式语言，名为\ES 形式语言。它同样具有 SML 
所拥有的 System F 式的类型系统，却对 System F 进行了改进而拥有更强
的功能，但保持对 SML 的对应，即 \ES  语言可以翻译到 SML 语言。
进而允许 \ES  壳层包裹在 HOL 证明器定制的 SML 解释器外，
\ES  壳层内部使用 \ES  语言而享受到改进的功能，在与 HOL 证明器对接时
将 \ES  语言翻译到 SML 语言再输入 SML 解释器进而控制 HOL 证明器操作
$\amlh$ 理论进行程序开发。

但 \ES  壳层并不强迫用户使用某种文本上书写的语言进行程序开发。
\ES  形式语言是抽象的理论工具，并不是用于开发程序的编程语言。

\ES  壳层设计了一种状态机并实现在 $\Eamlh$ 软件体系中，不妨就叫做
\ES  机器。\ES  机器既是一个抽象理论也是一个被真实实现的
软件工具，是 $\Eamlh$ 软件体系的后端，
内部执行 \ES  语言，外部暴露确定的两种类型的操作。
\ES  机器启动时加载预先编写的
 \ES  语言环境，包括一系列用于 $\amlh$ 上程序开发的
的预定义值与函数。
通过\ES 机器暴露的两种操作控制\ES 机器执行 \ES  语言，进而使用
提供的函数与值进行 $\amlh$ 上的程序开发。

用户并不是使用 \ES  形式语言进行 $\amlh$ 上的程序开发，而是通过
反复调用 \ES  机器暴露的那两种操作改变 \ES  机器的状态进行的。

故严格来说，这种程序开发方式并不强迫用户使用某种编程语言。而同样严格地说
，$\Eamlh$ 方式开发的程序并没有文本形式的源代码，这种开发方式的源代码
即是 \ES  机器的状态。\ES  机器将提供保存 \ES  机器状态到本地文件以及
从文件中重新加载状态的功能，即是源代码的保存与读取，这种功能也是作为
\ES  语言上的函数的形式被提供与被调用。

即 \ES  机器实质是一种集成开发环境（IDE）。

而尚未提及的前端，可以多种多样，它的功能是对接到后端亦即 \ES 机器并将
用户各种形式对前端的输入转换成 \ES 机器开放的那两种操作。前端的输入
形式是不需要确定的，可以是图形图像界面，可以是命令行，甚至是通过语音输入
或者是云端场景下的某个 Web 服务器。本文的工作实现了相当简易的命令行式
的一个前端。

这么做是因为，既然 $\amlh$ 上的程序开发是在数理抽象的氛围中使用形式定理
与数学对象构造程序，在程序的编辑方面，就不应该吝啬地保持在纸上。
既然一切跟逻辑是如此相关，是如此抽象，程序的编写与编辑就该更抽象一点。

任何时刻开发者思维的注意力集中在一个对象上。
而一切操作都是一种编辑壳层上的函数，每一步可以用意味某种操作的函数调用
此对象，或者如果这对象也是个函数，用它去调用别的什么。
然后将操作的结果，即函数执行的结果，作为一个新的对象，放在开发者的
注意力前。

而程序开发，就是不断地重复这一步骤。
这是 $\Eamlh$ 开发方式对程序开发的建模。
而这显然就是一种状态机模型，就是通过 \ES 机器完成的。

泛泛而谈，\ES 机器的模型是一个状态机，类似函数式语言其上的函数
也是一种值，任意时刻都有一个唯一确定的值$x$
作为状态，且可以进行两种操作进行状态转移而步入下一时刻：
\begin{enumerate}
\item 给一个值 $a$，以 $a$ 调用 $f$，将计算后的结果作为新的状态。
\item 给一个值 $f$，以 $x$ 调用 $f$，将计算后的结果作为新的状态。
\end{enumerate}

一切操作都通过编辑壳层的函数完成，不妨将这函数命名为编辑函数(Editing 
Function)。这些作为函数的操作包括，将值装入一个编辑环境变量，
这是传统语言中等号'\texttt{=}'或者其他赋值符号的含义；
定义一个新的编辑函数；将当前对象压入输入栈并开始一个新的输入空间，
这是传统语言中左括号'\texttt{(}'或者左大括号'\texttt{\{}'的含义；
关闭一个输入空间并弹出输入栈，这是传统语言中右括号'\texttt{)}'
或者右大括号'\texttt{\}}'的含义。于是 \ES 壳层上没有关键字，实际上
文本都没有，一切都是编辑函数。


难以论证这种方式比传统在纸上或者文本编辑器里的方式有何优势，
这是一个全新的方式，仅在本文涉及的非常有限的工作中被尝试，
尚没有任何有说服力的统计实验或者数据以支撑。
但它的确比传统的编辑方式抽象的多的多，一切编辑行为作为一种函数，
允许被包含在别的新被定义的函数中，而那些新的函数也是新的编辑操作，
这看起来似乎富有魅力而能提供强大的编辑功能，也许
古老的 Vim 编辑器的编辑指令能作为一个类似案例。
而 $\amlh$ 上的程序其实是些定理证明器上的定理，
根本没有文本形式的源代码。既然程序始终是高度抽象的，
已经是定理证明器证明完成的数学对象，再尝试用文本编辑工具
去修改编辑，不是很寒碜么，不是弄巧成拙么，
不如直接地交互式地输入编辑指令，交互式地执行各种指令以变换作为程序的
定理，以构造出新的定理也是新的程序，就是 \ES 机器的方式。

接下来将分别论述\ES 形式语言、\ES 机器、\ES 环境。

\section{\ES  形式语言}
\input{chapters/EditorShell/language.tex}
\input{chapters/EditorShell/type.tex}
\input{chapters/EditorShell/type_match_system.tex}
\input{chapters/EditorShell/type_call.tex}
\input{chapters/EditorShell/value.tex}
\input{chapters/EditorShell/machine.tex}


\ES 

类似λ2演算，令字符串集合 $U_v$ 表示\ES 的类型系统上所有的类型变量，
字符串集合$U_0$表示所有预定义的类型，集合$ \UE = U_v \cup U_0 $
\[ \PiE = \bnf{\UE \mbar \UE \rightarrow \UE} \]
表示所有的非全称量化类型或简单地叫做普通类型，
\[ \PiAE = \bnf{\PiE \mbar \forall U_v\ \PiAE } \]
表示全称量化类型或简单地叫做量化类型。


