\chapter{$\ES$编辑壳层}

$\amlh$ 已经在上一章论述清楚。但$\amlh$只是一个抽象机理论，尽管被
定义在 HOL 交互式证明工具的 HOL 逻辑上，借助定理证明工具似乎具象了一点，
但显然不能让用户直接操作数学命题与定理。
需要有一个壳层包裹起$\amlh$理论并向外提供给用户编辑程序的功能，
这是本章将论述的编辑壳层$\ES$的意义。

\section{$\ES$概述}

$\ES$ 是一个形式语言，且具有同名为$\ES$的
基于 System F 的一阶多态类型系统。围绕此构建起同名为$\ES$的状态机，
最后是名为$\ES$编辑壳层的软件工具。

接下来将分别论述$\ES$形式语言、$\ES$类型系统、$\ES$状态机。

\section{$\ES$ 形式语言}

首先定义类型。

\begin{defin}[类型集$\PiE$]
字符串集合 $U$ 为用于表示类型的字母表，
函数$\xa : U \mapsto \mathbb{N}$表示类型的元数（Arity），
从$U$元数为0的子集$U_\mathrm{v}$：
$U_\mathrm{v} \subseteq U\ \land\ \forall u.\ u \in U_\mathrm{v}
\Rightarrow \xa(u) = 0$ 表示类型变量，主要用于全称量化。

所有由字母表 $U$ 组成的字符串记为集合$\mathrm{String}(U)$，
$\ES$ 的类型集 $\Pi_\mathrm{E}$ 是满足以下条件的$\mathrm{String}(U)$最小子集
\begin{equation} \label{Def.PiE}
\forall u.\ u \in U \Rightarrow \forall \bm{v}.\ \bm{v} 
\in \Pi_\mathrm{E}^{\xa(u)} \Rightarrow \underline{(u\ \bm{v}_1\ 
\cdots\ \bm{v}_{\xa(u)})} \in \Pi_\mathrm{E}
\end{equation}
其中 $\Pi_\mathrm{E}^{\xa(u)}$ 表示 $\Pi_\mathrm{E}$ 的 $\xa(u)$ 维向量
空间，特别的 $\Pi_\mathrm{E}^0 = \{\mathbf{0}\}$
\end{defin}

\begin{example}[$\Pi_\mathrm{E}$] 以下命题成立：
\[ \forall u.\ u \in U\ \land\ (\xa(u) = 0)\ \Rightarrow\ 
\underline{(u)} \in \Pi_\mathrm{E} \]
\[ \forall u\ v.\ u \in U\ \land\ v \in U_\mathrm{v}\ \land\ (\xa(u) = 1)
\ \Rightarrow\ \underline{(u\ v)} \in \Pi_\mathrm{E} \]
\[ \forall u\ v.\ u \in U\ \land\ v \in \Pi_\mathrm{E}\ \land\ (\xa(u) = 1)
\ \Rightarrow\ \underline{(u\ v)} \in \Pi_\mathrm{E} \]
\end{example}

\begin{theo}(类型的结构) \label{TS}
\[ \forall u'.\ u' \in \PiE \Rightarrow \exists! u\ \bm{v}.\ 
u \in U_\mathrm{\bm{v}}\ \land\ \bm{v} \in \PiE^{\xa(u)}\ \land\ 
(u' = \underline{(u\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u')})}) \]
\end{theo}
\begin{proof} 首先唯一性是显然的，由字符串理论就可以得到。
对存在性的证明使用反证法，假设
\begin{equation} \label{Hypo.TS}
\exists u'.\ u' \in \PiE \Rightarrow \forall u\ \bm{v}.\ 
u \in U_\mathrm{\bm{v}}\ \land\ \bm{v} \in \PiE^{\xa(u)}\ \land\ 
(u' \neq \underline{(u\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u')})})
\end{equation}
现证明 $\PiE - \{u'\}$ 满足条件 \ref{Def.PiE} 而
$\PiE - \{u'\} \subset \PiE$ 这样就构造了悖论，因为 $\PiE$ 不再是满足
条件 \ref{Def.PiE} 的最小子集，$\PiE - \{u'\}$ 比 $\PiE$更小。
即证明
\[ \forall u.\ u \in U \Rightarrow \forall \bm{v}.\ 
\bm{v} \in \PiE^{\xa(u)} - \{u'\} \Rightarrow
\underline{(u\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u)})} \in \PiE - \{u'\} \]
因为有
\[ \forall u.\ u \in U \Rightarrow \forall \bm{v}.\ 
\bm{v} \in \Pi_\mathrm{E}^{\xa(u)} \Rightarrow
\underline{(u\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u)})} \in \Pi_\mathrm{E} \]
所以只要证明
\[ \underline{(u\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u)})} \neq u' \]
而由反证假设 \ref{Hypo.TS} 这是成立的，故而悖论被构造进而命题得证。
\end{proof}

定理 \ref{TS} 意味着一切类型$u$都具有且唯一地具有如下格式
\[ \underline{u_0\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u_0)}} \]
其中 $u_0 \in \mathrm{U}$，$\bm{v}_1,\ \cdots,\ \bm{v}_{\xa(u_0)} \in \PiE$

即每一个类型都构成一颗树，类型变量与0元类型构造器是叶子。

\begin{defin}[类型的构造器、元数、高度] \label{Def.Th}
函数 $\mathrm{c}:\Pi_\mathrm{E} \mapsto U$ 表示类型的构造器。
\[ \mathrm{c}\ \underline{(u\ v_1\ \cdots\ v_n)} = u\]
函数 $\xa:\Pi_\mathrm{E} \mapsto \mathbb{N}$ 表示类型的元数。
\[ \xa\ \underline{(u\ v_1\ \cdots\ v_n)} = n\]
$\xa:\Pi_\mathrm{E} \mapsto \mathbb{N}$ 不会跟上文定义的
$\xa:U \mapsto \mathbb{N}$冲突，因为定义域不重合，且两者具有相同的意义，
不会造成歧义。

\noindent 函数 $\mathrm{h}:\Pi_\mathrm{E} \mapsto \mathbb{N}$ 表示类型的高度。
\[ \mathrm{h}\ \underline{(u\ v_1\ \cdots\ v_n)} = 1 + \max(\mathrm{h}\ v_1,\ \cdots,\ 
\mathrm{h}\ v_n) \]
\end{defin}

有如下性质

\begin{theo}[类型的元数与高度的性质] \label{T.cah}
\[ \forall u.\ \mathrm{h}\ u  \geq 1 \quad\quad\text{(1)}\quad\quad
\quad\quad\quad\forall u.\ \xa(\mathrm{c}\ u) = \xa\ u \quad\quad\text{(2)} \]
\[ \forall u.\ (\mathrm{h}\ u = 1) \Rightarrow \exists \mathrm{c}.\ \mathrm{c} \in U
\ \land\ u = \underline{(\mathrm{c})} \tag{3} \]
\[ \begin{split}
\forall u.\ (\mathrm{h}\ u > 1) \Rightarrow \exists \mathrm{c}\ &\bm{v}.\ \mathrm{c} \in U
\ \land\ \bm{v} \in \PiE^{\xa(u)}\ \land\ u = \underline{
(\mathrm{c}\ \bm{v}_1\ \cdots\ \bm{v}_{\xa(u)})} \ \land\ \\
&(\forall i.\ 1 \leq i \leq \xa(u) \Rightarrow \mathrm{h}\ \bm{v}_i < \mathrm{h}\ u )
\end{split} \tag{4} \]
\end{theo}
\begin{proof} 由定义 \ref{Def.Th} 与定理 \ref{TS} 直接得到。
\end{proof}

这样就可以关于类型的高度进行归纳法。

\begin{defin}[全称量化类型 $\PiAE$]
集合 $\Pi_\mathrm{E}^\forall$ 表示全称量化类型，由所有满足如下语法的字符串构成。
\[ \Pi_\mathrm{E} \mbar \forall U_\mathrm{v}\ \Pi_\mathrm{E} \]
同样有记号 $\forall v_1\ \cdots\ v_n.\ b$ 表示 $\underline{\forall v_1
\ \cdots\  \forall v_n\ b}$
\end{defin}

\begin{defin}[全称量化类型的相关属性]
函数 $\mathrm{QV} : \Pi_\mathrm{E}^\forall \rightarrow \powerset(
U_\mathrm{v})$ 表示全称量化类型的绑定变量集。
\[ \mathrm{QV}(\forall v_1\ \cdots\ \v_n.\ b) = \{v_1,\ \cdots,\ v_n\} \]
函数 $\mathrm{QB} : \Pi_\mathrm{E}^\forall \rightarrow \Pi_\mathrm{E}$
表示全称量化的类型体。
\[ \mathrm{QB}(\forall v_1\ \cdots\ \v_n.\ b) = b \]
\end{defin}

\begin{defin}[实例化] \label{Def.Inst}
函数 $\mathrm{Inst} : (U_\mathrm{v} \rightarrow \Pi_\mathrm{E})
\rightarrow \Pi_\mathrm{E} \rightarrow \Pi_\mathrm{E}$ 对类型
进行变量实例化。
\begin{align*}
\mathrm{Inst}\ f\ \underline{(v)} &= \xif v \in U_\mathrm{v} \xthen
 f\ v \xelse \underline{(v)} \\
\mathrm{Inst}\ f\ \underline{(u\ v_1\ \cdots\ v_{\xa(u)})} &= 
\underline{(u\ f(v_1)\ \cdots\ f(v_{\xa(u)}))}
\end{align*}

以及部分实例化 $\Inst_V$ 
\[ \Inst_V f = \Inst (\lambda v.\ \xif v \in V \xthen f\ v \xelse v) \]

函数 $\mathrm{Inst}_\forall : (U_\mathrm{v} \rightarrow \Pi_\mathrm{E})
\rightarrow \Pi_\mathrm{E}^\forall \rightarrow \Pi_\mathrm{E}$ 
实例化全称量化类型。
\begin{gather*}
\mathrm{Inst}_\forall\ f\ q = \Inst_{\ \mathrm{QV}(q)} f\ \mathrm{QB}(q)
\end{gather*}
即$\mathrm{Inst}_\forall$只会实例化全称量化的类型变量。
\end{defin}

\begin{algorithm}
\caption{实例化函数 $\Inst_V$} \label{alg:Iv}
\begin{algorithmic}[1]
\Require 集合 $V \in \powerset(\Uv)$ 表示实例化的范围
\Require 实例化函数 $f : \Uv \rightarrow \PiE$ 表示变量到值的对应
\Require $u \in \PiE,\ u = \underline{(c\ v_1\ \cdots\ v_o)}$
表示要实例化的目标
\Ensure $\Inst_V f\ u \in \PiAE$
\If {$o = 0$}
\If {\quad $c \in \Uv$ \quad} \quad 以 $c$ 调用 $f$ 将结果输出
\Else {\quad 输出 $\underline{(c)}$}
\EndIf
\Else
\For{$i=1,\ \dots,\ o$}
\State 调用算法\ref{alg:Iv}自身，输入$V,\ f,\ v_i$，记输出为 $v_i'$
\EndFor
\State 输出 $\underline{(c\ v_1'\ \cdots\ v_o')}$
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{defin}[α等价] \label{Def.aE}
二元关系$\sim_\alpha$ 定义为
\[ (q_1 \sim_\alpha q_2) = (\forall f.\ \mathrm{Inst}_\forall\ f\ q_1
= \mathrm{Inst}_\forall\ f\ q_2) \]
显然是一种等价关系，被叫做α等价。
\end{defin}

α等价类$\Pi_\mathrm{E}^\forall/[\sim_\alpha]$即是本质不同的全称量化类型。

\begin{defin}[实例化类型集] \label{Def.QI}
全称量化类型$q$的实例化类型集$\mathrm{QI}\ q$为
\[ \mathrm{QI}\ q = \{\mathrm{Inst}_\forall\ f\ q\mbar f \in 
(U_\mathrm{v} \rightarrow \Pi_\mathrm{E})\} \]
\end{defin}
\begin{theo}[实例化类型集的相等即是$\sim_\alpha$等价]
\[(q_1 \sim_\alpha q_2) = (\mathrm{QI}\ q_1 = \mathrm{QI}\ q_2)\]
\end{theo}
\begin{proof} 由定义 \ref{Def.aE} 与定义 \ref{Def.QI} 直接得到。
\end{proof}
\begin{theo}[实例化类型集非空]
\[\forall q.\ \mathrm{QI}\ q \neq \emptyset\]
\end{theo}
\begin{proof}
因为 $\quad\forall q.\ \mathrm{Inst}_\forall\ \I\ q = \mathrm{QB}\ q 
\quad$ 所以有 $\quad\forall q.\ \mathrm{QB}\ q \in \mathrm{QI}\ q$
\end{proof}

接下来尝试证明一个重要命题 
\[ \forall q_1\ q_2.\ q_1,\ q_2 \in \Pi_\mathrm{E}^\forall 
\ \land\ (\mathrm{QI}\ q_1 \cap \mathrm{QI}\ q_2 \neq \emptyset)
\Rightarrow
\exists q.\ q \in \Pi_\mathrm{E}^\forall\ \land\ ((\mathrm{QI}\ q_1)
\cap (\mathrm{QI}\ q_2) = \mathrm{QI}\ q) \]
并找到一个算法用于求解上述的 $q$

首先要引入诸多工具的定义。

\begin{defin}[类型匹配系统(Type Match System)] 类型匹配系统集 $\EQs$ 是集合
\[ \EQs = \powerset(\Uv) \times \powerset(\PiE \times \PiE) \]
类型匹配系统是所有集合 $\EQs$ 中的元素。
\[ (V,\ \{ (x_1, y_1),\ (x_2, y_2),\ (x_3, y_3),\ \cdots \}) \]
其中 $\{ (x_1, y_1),\ (x_2, y_2),\ (x_3, y_3),\ \cdots \}$ 叫做
匹配系统中的方程组，$x_1 = y_1,\ \cdots$ 是方程组中的方程，
$V \subseteq \Uv$ 是类型匹配系统的变量集。
\end{defin}
\begin{notation}[类型匹配系统的记号] 
记号
\[ \begin{Bmatrix}
x_1 &=& y_1 \\
x_2 &=& y_2 \\
x_3 &=& y_3 \\
&\cdots& 
\end{Bmatrix}_V \]
表示类型匹配系统
\[ (V,\ \{ (x_1, y_1),\ (x_2, y_2),\ (x_3, y_3),\ \cdots \}) \]
\end{notation}
\begin{defin}[类型匹配系统的解与解集] \label{Def.MF}
一个类型匹配系统$(V,X)$的解$f$是一个$(\Uv \rightarrow \PiE)$函数，
满足
\[ \forall u_1\ u_2.\ (u_1,u_2) \in X \Rightarrow 
\Inst f\ u_1 = \Inst f\ u_2 \]
所有这样的解构成的集合叫解集。

函数 $\MF : \EQs \rightarrow \powerset(\Uv \rightarrow \PiE)$
将一个类型匹配系统映射到其解集
\[ \MF (V,X) = \{ f \mbar \forall u_1\ u_2.\ (u_1,u_2) \in X
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2 \} \]
\end{defin}

\begin{defin}[类型匹配系统的M等价] \label{Def.Meq}
二元等价关系 $\Meq$
\[ \forall A\ B.\ (A \Meq B) = (\MF A = \MF B) \]
\end{defin}
\begin{theo}
\[ \forall X\ V\ v.\ (V,X) \Meq (V, X \cup \{(v,v)\}) \]
\end{theo}
\begin{proof} 由定义 \ref{Def.Meq} 定义 \ref{Def.MF} 直接得到
\end{proof}

\begin{defin}[有意义类型方程组] \label{Def.SF}
有意义（Senseful Form）类型方程组函数
$\SF : \powerset(\PiE \times \PiE) \rightarrow \powerset(\PiE \times \PiE)$
\[ \SF X = \{(x,y) \mbar (x,y) \in X \ \land\ x \neq y\} \]
即是削除了恒等式 $(x,x)$ 后的方程。
\end{defin}

\begin{defin}[已解的类型匹配系统] \label{Def.Solved}
类型匹配系统在的{\it 已解}形式下的未知量（Unknown Variable）函数
$\UV : (\PiE \times \PiE) \rightarrow \powerset(\Uv)$
\[ \UV X = \{x \mbar (x,y) \in \SF X\} \]
一个类型匹配系统 $(V,X)$ 若满足 $\Solved (V,X)$ 则被叫做{\it 已解}的。
\[ \begin{split}
\Solved (V,X) = (\forall x\ &y.\ (x,y) \in \SF X \Rightarrow
  x \in V \ \land\ \BV y \cap \UV X = \emptyset)\ \land \\
  & (\forall x\ y_1\ y_2.\ (x,y_1) \in \SF X \ \land\ (x,y_2) \in \SF X
  \Rightarrow (y_1 = y_2))
\end{split} \]
\end{defin}

有一些显然的性质，
\begin{equation} \Solved(V,X) \vdash \UV X \subseteq V \end{equation}
\begin{equation} \Solved(V,X) \vdash \forall x\ y.\ (x,y) \in X
\Rightarrow x \in \UV X \label{UVX} \end{equation}

\begin{lemma} \label{Lem.SFXF}
\[ \Solved(V,X) \vdash \SF X \in (\UV X \rightarrow \PiE) \]
即在已解形式下，有意义的方程组 $\SF X$ 就是一个$V$到$\PiE$的函数。
\end{lemma}
\begin{proof}
由定义 \ref{Def.Func}，命题等价于
\[ \Solved(V,X) \vdash \forall x\ y_1\ y_2.\ (x,y_1) \in \SF X \ \land\ 
(x,y_2) \in \SF X \Rightarrow (y_1 = y_2) \ \land\ x \in \UV X \ \land\ 
y_1 \in \PiE \]
由定义 \ref{Def.Solved} 这是显然的。
\end{proof}
\begin{lemma}[引理\ref{Lem.SFXF}的推论] \label{Lem.SFXapplied}
结合引理\ref{Lem.SFXF}与公式 \ref{UVX}
\[ \Solved(V,X),\ (x,y) \in X \vdash \SF X\ x = y \]
\end{lemma}

\begin{defin}[部分函数的I扩展]
$\EI\ f$ 将一个部分函数 $f$ 扩展成完全函数
\[ \EI\ f\ x = \xif x \in \Dom f \xthen f\ x \xelse x \]
\end{defin}

\begin{theo}[已解方程组的解]
\[ \Solved (V,X) \vdash \MF(V,X) = \{ \Inst_V g
\circ \EI (\SF X) \mbar g \} \]
\end{theo}
\begin{proof} 由定义 \ref{Def.MF} 命题等价于
\[ \begin{split}
\Solved&(V,X) \vdash (\forall u_1\ u_2.\ (u_1,u_2) \in X
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2) = \\
&(\exists g.\ \forall x.\ x \in \Uv \Rightarrow 
(f(x) = \Inst_V g(\EI (\SF X)\ x)))
\end{split} \]
当 $X = \emptyset$ 时等式左边即是 $T$，右边也是 $T$ 因为
$\Dom (\SF X) = \emptyset$ 故而 $\EI(\SF X) = I$ 这样右式就等于
\[ \exists g.\ \forall x.\ x \in \Uv \Rightarrow
(f\ x = \Inst_V\ g\ x)\]
而这样的 $g$ 是始终存在的，令 $g = f$ 则有
\[ \forall x.\ x \in \Uv \Rightarrow (f\ x = \Inst_V\ f\ x)\]
而由 $\Inst_V$ 的定义，当 $x \in \Uv$ 时，$\Inst_V f\ x = f\ x$，
故而右式就是恒真式。

\hfill

\noindent 接下来证明 $X \neq \emptyset$ 的情况，先
证明 $\Rightarrow$，即命题
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall x\ y.\ &(x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)) \vdash\\
&\exists g.\ \forall u.\ u \in \Uv \Rightarrow
(f(u) = \Inst_V g(\EI (\SF X)\ u)) \end{split}\]
存在这样的 $g = f$，命题变为
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (&\forall x\ y.\ (x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)) \vdash\\
&\forall u.\ u \in \Uv \Rightarrow
(f\ u = \Inst_V f(\EI (\SF X)\ u))
\end{split} \]
由引理 \ref{Lem.SFXF}，$\Dom(\SF X) = \UV X$，再由$\EI$的定义，
当 $u \notin \UV X$ 时，$\EI(\SF X) u = u$，
而由 $\Inst_V$ 的定义，在$u \in \Uv$时$\Inst_V u = u$，
故而最后只要下述证明命题
\[ \begin{split}
X \neq \emptyset,\ 
Solved(V,X),\ &(\forall x\ y.\ (x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)) \vdash\\
&\forall u.\ u \in \UV\ X
\Rightarrow (f\ u = \Inst_V f\ (\SF X\ u)) \end{split} \]
再由公式 \ref{UVX} 且 $X \neq \emptyset$
\[X \neq \emptyset,\ 
\Solved(V,X),\ (x, y) \in \SF X,\ 
\Inst_V f\ x = \Inst_V f\ y \vdash f\ x = \Inst_V f\ (\SF X\ x)\]
引理 \ref{Lem.SFXapplied}
\[X \neq \emptyset,\ 
\Solved(V,X),\ (x, y) \in \SF X,\ 
\Inst_V f\ x = \Inst_V f\ y \vdash f\ x = \Inst_V f\ y\]
而 $\Solved(V,X)\ \land\ (x, y) \in \SF X$ 所以 $x \in \Uv$ 所以
$\Inst_V\ f\ x = x$ 于是命题得证。

\hfill

\noindent 接下来证明 $\Leftarrow$，即命题
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g(\EI (\SF X)\ u))) \vdash \\
&\forall x\ y.\ (x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)
\end{split}\]
等价于
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ (x, y) \in \SF X
\vdash \\
& \Inst_V f\ x = \Inst_V f\ y
\end{split}\]
$(x,y) \in \SF X$ 故而 $x \in \UV X$
故而 $x \in \Uv$ 这样 $\Inst_V f\ x = f\ x$ 且
$f\ x = \Inst_V g\ (\EI (\SF X)\ x)$

\noindent 且因为 $x \in \UV X$ 所以 $\EI (\SF X)\ x = \SF X\ x = y$
最后命题等价于
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ (x, y) \in \SF X
\vdash \\
& \Inst_V g\ y = \Inst_V f\ y
\end{split}\]
\end{proof}

\begin{defin}[类型匹配系统的实例集] \label{Def.MI}
类型匹配系统 $(V,X) \in \EQs$ 在 $u \in \PiE$ 上的实例集 
$\MI\ (V,X)\ u \in \powerset(\PiE)$
\[\MI\ (V,X)\ u = \{ \Inst_V f\ u \mbar f \in \MF(V,X) \}\]
\end{defin}
\begin{lemma}[类型匹配系统的实例集的M等价] \label{Lem.MI.Meq}
\[ \forall M_1\ M_2.\ (M_1 \Meq M_2) \Rightarrow (\MI M_1 \Meq \MI M_2)
\]
\end{lemma}
\begin{proof} 由$\MI$的定义 \ref{Def.MI}，M等价的定义 \ref{Def.Meq}
直接得到
\end{proof}

\begin{lemma} \label{Lem.RecIv}
\[ \Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X)) = \Inst_V g \circ \Inst_V (\EI\ (\SF X))\]
\end{lemma}
\begin{proof} 等价于
\[ \Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ u = \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ u)\]
对 $u$ 进行高度的归纳法，当 $\h u = 1$ 时，$u = \underline{(c)}$，
$c \in U$ 由 $\Inst$ 的定义 \ref{Def.Inst} 命题成立。

\noindent 当 $\h u = \Suc n$ 时，$u = \underline{(c\ v_1\ \cdots\ v_o)}
,\ \h v_1 \leq n,\ \cdots,\ \h v_o \leq n$，且有
\[ \Solved(V,X),\ \h u \leq n \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ u = \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ u)
\tag{归纳假设} \]
由 $\Inst$ 的定义 \ref{Def.Inst} 命题等价于
\begin{align*}
\Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ v_1\ &= \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ v_1)\\
\cdots&\\
\Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ v_o\ &= \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ v_o)
\end{align*}
逐个应用归纳假设，命题得证。
\end{proof}

\begin{lemma} \label{L.QIMI}
\[ \Solved(V,X),\ \QV q = V,\ \QB q = 
\Inst_V\ (\EI (\SF X))\ u \vdash
\QI q = \MI\ (V,X)\ u \]
\end{lemma}
\begin{proof}
等价于
\[ \begin{split}
\Solved(V,&X),\ \QV q = V,\ \QB q = 
\Inst_V\ (\EI (\SF X))\ u\vdash\\
&\{\Inst_{\ \QV q} f\ \QB(q)\mbar f\} = \{\Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ u \mbar g\} \end{split} \]
由引理 \ref{Lem.RecIv}
\[ \begin{split}
\Solved(V,&X),\ \QV q = V,\ \QB q =  
\Inst_V\ (\EI (\SF X))\ u\vdash\\
&\{\Inst_{\ \QV q} f\ \QB(q)\mbar f\} = \{\Inst_V g\ (
\Inst_V (\EI\ (\SF X))\ u) \mbar g\} \end{split} \]
这是显然成立的。
\end{proof}

引理 \ref{L.QIMI} 意味着很多，首先对于任意的类型匹配系统 $M \in \EQs$
如果其有可解形式 $M'$ 即 $\Solved M'\ \land\ M \Meq M'$，
那么必定存在存在一个 $q \in \PiAE$ 使得 $\QI q = \MI M$，
其次，可以有一个算法由 $\Solved M'$ 求解 $q$

\begin{theo} \label{T.QIMI.S}
\[ \forall M.\ \Solved M \Rightarrow \exists q.\ \QI q = \MI M \]
\end{theo}
\begin{proof} 由引理 \ref{L.QIMI} 直接得到。
\end{proof}

\begin{algorithm}
\caption{已解类型匹配系统的全称量化类型} %\label{alg:put-into-refri}
\begin{algorithmic}[1]
\Require 类型匹配系统$(V,X)$ 满足 $\Solved(V,X)$
\Ensure $q \in \PiAE$ 满足 $\QI q = \MI (V,X)$
\State 先热热身:)
\For{$i=1,\dots ,N$} \Comment{我是个For循环}
\If {是猪八戒}
	\State 打开冰箱门，把第$i$个放进冰箱，关上冰箱门
\Else 
	\State 下一个
\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{theo}[类型匹配系统有解与实例化类型集交集的关系]
\[ \begin{split}
\forall q_1\ q_2.\ &(\QV q_1 \cap \QV q_2 = \emptyset) \Rightarrow\\
(\QI q_1 \cap \QI q_2 =\ &
\MI(\QV q_1 \cup \QV a_2,\ \{\QB q_1 = \QB q_2\}))
\end{split}\]
\end{theo}
\begin{proof}
\[\begin{split}
\QV q_1 \cap \QV q_2&\ = \emptyset \vdash \{u \mbar
  u = \Inst_{\ \QV(q_1)} f_1\ \QB(q_1) = \Inst_{\ \QV(q_2)} f_2\ 
  \QB(q_2) \} = \\
\{ \Inst_\forall f\ q_1 \mbar  \}
\end{split}\]
\end{proof}



\begin{theo} 
\[ \forall q_1\ q_2.\ q_1,\ q_2 \in \Pi_\mathrm{E}^\forall 
\ \land\ (\mathrm{QI}\ q_1 \cap \mathrm{QI}\ q_2 \neq \emptyset)
\Rightarrow
\exists q.\ q \in \Pi_\mathrm{E}^\forall\ \land\ ((\mathrm{QI}\ q_1)
\cap (\mathrm{QI}\ q_2) = \mathrm{QI}\ q) \]
\end{theo}

\begin{proof} 证明等价命题
\[ \begin{split}
\forall n\ q_1\ q_2\ u_1\ u_2.\ q_1,\ &q_2 \in \Pi_\mathrm{E}^\forall 
\ \land\ (\mathrm{QI}\ q_1 \cap \mathrm{QI}\ q_2 \neq \emptyset)
\ \land\ (u_1 = \mathrm{QB}\ q_1) \ \land\  (u_2 = \mathrm{QB}\ q_2)\\
\land\ (n = &\max(\mathrm{h}\ u_1,\ \mathrm{h}\ u_2)) \Rightarrow
\exists q.\ q \in \Pi_\mathrm{E}^\forall\ \land\ ((\mathrm{QI}\ q_1)
\cap (\mathrm{QI}\ q_2) = \mathrm{QI}\ q)
\end{split} \]
对 $n$ 使用归纳法

\noindent 在 $n = 0$ 时，由定理 \ref{T.cah} 性质1
不存在 $q_1,\ q_2$ 使得 $n = \max(\mathrm{h}\ q_1,\ \mathrm{h}\ q_2)$

\noindent 在 $n = 1$ 时，由定理 \ref{T.cah} 性质1
$\quad \mathrm{h}\ q_1 = \mathrm{h}\ q_2 = 1\quad$
由定理 \ref{T.cah} 性质3
\[ u_1 = \underline{(c_1)} \quad\quad u_2 = \underline{(c_2)}
\quad\quad c_1,\ c_2 \in U \]
\end{proof}


类型变量主要用于全称量化中，
集合$U_0$ 表示预定义的类型如整数 int 以及类型构造器（Type Constructor）
如列表类型构造器 α list，


$\ES$ 形式系统是一种改造过的 λ2 演算，且非常接近SML语言


但抛开与 λ2 的联系而
直接论述$\ES$ 形式系统本身更易与表述。先暂且不管与 λ2 的联系而开始直接
论述。

\subsection{类型系统}

$\ES$

类似λ2演算，令字符串集合 $U_v$ 表示$\ES$的类型系统上所有的类型变量，
字符串集合$U_0$表示所有预定义的类型，集合$ \UE = U_v \cup U_0 $
\[ \PiE = \bnf{\UE \mbar \UE \rightarrow \UE} \]
表示所有的非全称量化类型或简单地叫做普通类型，
\[ \PiAE = \bnf{\PiE \mbar \forall U_v\ \PiAE } \]
表示全称量化类型或简单地叫做量化类型。


