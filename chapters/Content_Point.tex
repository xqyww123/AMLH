\section{研究内容导论}

机器决定了程序。抽象机器（Abstract Machine）\cite{van1990handbookC1}
亦决定其上的程序。
若将抽象机器良好地定义在形式系统（Formal System）
\cite{shoenfield2018mathematicalC1}中，
即在这形式系统中符号地定义抽象机器，
则其上的程序亦可以被此形式系统符号地表达。
若将需求亦在同一形式系统中表述，即 Formal Specification，
那么此形式系统可以良好地形式化证明程序对此描述的满足性。
即若抽象机器是形式化的，程序是形式化的，而描述若亦在统一形式系统中表述，
则可形式化证明程序对于描述的正确性，即满足性与正确执行性。

这一论述很美好。

编程语言本就是形式的，计算机的抽象模型也可以轻易地抽象化，充分利用状态机
就能做到。
而显然，这些语言上的程序、计算机上的程序理论上都可以被形式化地验证。

但实际上，非常困难，稍微实践一下就会知道。
著名的 seL4 内核的形式化验证，仅8700行的C语言与600行的汇编语言
消耗了200,000行 Isabelle 代码与20人年\cite{klein2009sel4}。

现实的计算设备的抽象模型往往出于工程的角度，
使用了大量利于工程实现的模型如状态机等，是不利于数学证明的。
而由理念出发的对程序的描述，往往是贴近数学的抽象。
亦即，现实的计算设备往往是基于状态机等工程应用式的，
而程序功能的期望描述是更加抽象的。
理念的抽象与实际工程应用间的差异，
是形式化方法特别是其中的形式化验证在现在的软件工程工业界所遇到的问题。
难以想象，将如何从一个状态机的各种状态转移中还原一个素数判定程序的抽象意义。

理论上任何形式系统下表达的程序均可以被形式化验证，但实际上
并非都易于验证。
本文认为，形式化验证之所以困难重重是因为期望被验证的目标，
在不易于分析的形式化系统下的程序，不易于被验证。即，这个问题太难了。
所以\textbf{本文的思路是，修改问题本身}——设计一个易于分析与验证的形式系统，
并开发出一套在此形式系统上开发软件的方案，而要求用户一开始就在其上开发软件。
即，不是努力尝试解决问题，而是反过来修改问题本身。

本文不是第一个这么想的。Agda\cite{norell2008dependently},
Idris\cite{brady2013idris}, MCMQ\cite{ioannidis2019extracting} 等是先驱。
它们基于 Curry–Howard 同构\cite{sorensen2006lectures} 构造的
依赖类型（Dependent type system）\cite{pierce2005advancedC2}
令形式系统既可以用于程序编写又可以用于证明，即“程序即证明”。
但问题在于编程工具与证明工具的混淆，依赖类型本身的过度复杂对编程的妨碍，
构造主义（Constuctism）的证明方式固然可以允许“程序即证明”但也增加了
证明难度并缺失了半自动的证明辅助，函数式的架构又不利于程序的执行性能。
这些具体的比较会在？？？章详细论述。

本文认为，最易于分析且能够允许软件开发的形式系统就是 $\lambda$ 演算
\cite{sorensen2006lecturesC1, barendregt1984lambda, pierce2002typesC59}，
而最易于证明的形式系统是经典高阶逻辑（Classical High Order Logic）
\cite{constructive_classic_logic}，
此处经典旨在区别于新兴的直觉逻辑（Intuitionistic Logic），
\cite{girard1989proofsC3, sorensen2006lecturesC2}，
而经典高阶逻辑仍然是目前数学领域的主流。

尤其是，目前大量的数学形式化证明工具已成熟，
特别是已有40年历史的交互式定理证明工具（Interactive Theorem Prover），
提供了有效的形式化分析与证明的手段。
HOL 理论证明器（HOL Theorem Prover）是其中的先行者，并活跃地发展至今，
已广泛应用于学界的各个领域，其提供了一套基于经典高阶逻辑的形式化证明系统。

本文的思路是，在交互式理论证明器提供的经典高阶逻辑的证明系统上
再构造一个简单类型$\lambda$演算（$\lamst$演算）的子形式系统，
并巧妙地设定将其构造成用于软件开发的抽象机器，
令此抽象机可用于软件开发，又能使用外层的证明系统对内层的抽象机进行分析与证明。
即在一层经典逻辑的证明系统上再构造一个$\lamst$演算的
子形式系统作为抽象机，
或者说是将基于$\lamst$演算的抽象机构造在交互式定理证明器
提供的形式化的经典逻辑证明系统上。
就可以通过外层定理证明器的辅助，在内层基于$\lamst$演算
构造抽象机上的运算以进行编程，
又可以使用外层定理证明器对其符号分析与证明以编程辅助与验证，
因为这抽象机是架构在定理证明器提供的证明系统上。
更进一步，这种符号分析可以是满足内层$\lamst$演算
的等价关系的变换，就可以对内层抽象机进行符号运算，
且这运算的正确性又在外层证明系统的保障之下。
而这种符号运算既可以是向下的求值，也可以是横向的编译变换，
即用外层证明系统对内层抽象机演算上的程序进行以编译为目的的等价变换，
而这就是编译。

内层抽象机定义在外层证明系统内，亦是被证明系统形式化地表达，
即表达为定理证明器上的数理结构。
而抽象机上的程序显然被抽象机形式地表达，
就亦被外层证明系统形式表达，即同样是定理证明器上的数理结构。
以数理结构同时承载用户的抽象思维与程序的具象执行，
就不会因传统程序语言表达从抽象到具象的转换过程丢失信息。

程序的各种特性即是证明系统上的命题，也就是定理证明器上的命题，
就可以有效地对这些特性进行一切可能的数学分析与证明，
一如定理证明器对任何普通命题的证明，因为关于程序的一切都发生在抽象机上，
而抽象机构建在证明系统内。
就可以彻底地证明程序的正确性，可停机性，与对描述的满足性。

内层抽象机基于$\lamst$演算实现，非常简洁仅围绕一个基本类型，
被非常巧妙地设定以易于外层证明系统对其分析。
而其上的程序编写通过外层证明系统实现，证明系统与定理证明器提供充分的辅助
以良好地支持抽象机上的程序开发。

抽象机器到抽象机器的程序翻译是确定且固定的，
构造抽象机到真实计算机或JVM等虚拟机间的翻译程序，就可以
将此抽象机上的抽象程序编译到现实的执行环境中。
而这一翻译发生在证明系统内，因为证明系统就是抽象机的外环境，
于是这翻译本身就是定理证明器上依照抽象机定义的等价关系的变换，
这变换被证明系统保障，也就是编译正确性被定理证明器验证。
尽管直接在定理证明器内生成目标指令代码并不容易，但可以利用
中间表达（Intermediate Representation）技术，只是在证明系统内编译到
基于数理表达式的中间表达，此处的编译是被验证的，再在外部
尽管无验证保障但更方便且高效地将中间表达编译至目标指令。

事实上一切对内层抽象机上程序的编写、分析、到中间表达的编译，
都发生在外层证明系统内，
证明系统是其外环境，即从始至终程序开发发生在定理证明器提供的数理环境内。

这意味着质的变化。得以允许
巧妙的设定让这一体系拥有实际的软件工业生产能力的同时保持良好的数学亲和性——
既然编程就是直接的数理结构构造，编程范式就应当更加地贴近数理方式，
一切程序开发发生在证明系统上数理范畴内就允许
类型系统等编程语言的种种设计从抽象出发并始终围绕数理思维方式，
进而使用户的编程思维以数理的角度进行。
于上本文认为这种编程范式更亲和于程序的抽象模型就更利于程序设计，
于下亲和数理的程序表达又更利于数学分析与证明，
而其间数理分析由始至终为程序设计与开发提供强有效的辅助。
于是其分析、辅助、编译均从始至终以数学亲和的方式在抽象的范畴内进行，
其下的定理证明器所提供的本就优秀的数理分析功能就能发挥强劲的功效，
进而不输传任何传统的软件工程工具。

为论述方便，以符号 $\amlh$ 表示本文提出的
基于经典逻辑的基于简单类型$\lambda$演算的抽象机，其中 $\mathrm{A}$ 表示抽象机
（Abstract Machine），$\mathrm{HOL}$ 是高阶逻辑（High Order Logic）的缩写，
高阶逻辑是经典逻辑仅是侧重点不同的别称，$\mathrm{HOL}$ 另外也是本文工作基于的
HOL 交互式定理证明器的缩写，最后$\lamst$是简单类型$\lambda$演算的通用符号，
$\lamst$为上标而$\mathrm{HOL}$为下标意味着在经典逻辑构建的简单类型$\lambda$演算。

总结一下，本工作的要义是在交互式定理证明器的证明系统上构建一台抽象机，即$\amlh$，
并提供其上的编程语言和一系列方案与必须的封装，特别是最后将$\amlh$上的程序
编译到现实的计算机上的方法。
在证明系统上进行软件开发与调试、测试、分析一系列的软件工程，
即令程序直接变作抽象的数理对象而可以被表达为证明系统上的表达式；
令编程本身变作证明系统上数理结构的构造；程序分析是对数理结构的分析；
而编译是证明系统上对这些数理结构的等价变换，最后输出易于编译到目标执行平台
的中间表达。

即摒弃传统软件工程的方案与思路，而是尝试在数理的抽象环境中，
以数理对象表达程序，提供一整套新的软件开发方案。
结合定理证明器提供的强大数学分析能力，以提供更有效的形式化辅助与验证，
本文相信会比传统方式更好。

也意味着大量的工作。

\section{具体工作内容与章节安排}


不同于Agda, Idris 仅仅是基于新型的依赖类型系统设计一门编程语言，更不同于
MCMQ 仅仅是一个编译器。
围绕编程语言为核心，涉及类型系统、编译器、证明器、编辑器等本工作实际要
涉及的是一套完整的开发环境。

崭新的基于数理抽象思维出发的软件开发思路意味着借鉴传统方式的同时大量
新的路子值得被设计，包括类型系统、编译、编辑在内的诸多方面都有新的探索。

首先第二章讲述$\amlh$的具体设计。
第一节讲述$\amlh$相关思想概念与原理，包括其上程序的编写与编译原理。
第二节讲述系统状态相关问题。
$\lambda$ 演算简洁优雅，使用$\lambda$演算建模现实计算机的主要困难在于
现实计算机有大量的状态，故相对而言状态机更适合建模现实计算机。
第二节讲述如何解决此问题，有两种方案。
一种是通过单源单汇有向无环网络流记录所有
的状态修改历史以将系统状态数值化而成功用$\lambda$演算表达系统状态转移。
另一种是力图将计算与状态分离，而将计算本身无状态化。
第三节正式定义$\amlh$，包括本工作研究的两种版本，
细粒度$\amlh$与粗粒度$\amlh$。

第三章讲述类型系统，本工作受现象与本质这两个哲学概念的启发，设计了
基于现象与本质对应关系的类型系统。
本章主要以理论的形式叙述组成，第一节讲述
数值的现象-本质对应类型系统，第二节讲述系统状态的分析模型。

第四章讲述用户接口，本工作设计了一种具有 Girard 多态类型的状态机作为
用户接口，并设计了一系列编辑用的算子。
第一节讲述编辑状态机与编辑语言的设计。
第二节讲述其上的各种算子，包括懒惰算子，可变算子，调用算子，输入栈算子。
第三节综合论述此编辑接口的实现并包含案例分析。

第五章讲述一个以 WASM 为编译目标平台智能合约为应用场景的抽象机$\amlhWASM$的实现，
实现并验证一个 ERC20 合约。
第一节讲述$\amlhWASM$的指令集设定。
第二节讲述验证与半自动证明策略。
第三节讲述编译方法与半与半自动编译变换函数。
第四节讲述用户接口上的开发环境实现。
第五节讲述 ERC20 合约的实现、验证与测试。

第六章讲述相关工作与比较。
第一节概述交互式定理证明器。
第二节概述与比较相关的形式化验证方法。

\section{本工作的特性与优势}

暂时跳过具体的论述而预先给出本工作的特性与优势。

\begin{itemize}
  \item 内在支持并行。基于计算依赖与逻辑依赖的自动并行。
  \item 支持对程序强大的静态分析，可以计算程序的最糟运行时间，甚至理论上
  给定输入的概率密度函数可以计算程序运行时间的概率分布。
\end{itemize}
