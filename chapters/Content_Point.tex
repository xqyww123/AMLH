\subsection{形式化方法的主流方向与困境}

现代编程语言基本都是形式语言，编程语言上的程序是这一形式语言上的表达，
而类型系统是编程语言上的形式系统，类型系统对程序的分析与推断构成了
对程序的形式化验证。

但类型系统的形式语言的表达能力往往是有限的，只能表达有限的性质进而
只能推导与证明这些有限的。
这样对于软件工程的实际结果就是，类型系统只能削除有限种类的缺陷，
大量别的缺陷依旧可能存在。
程序实现的正确性无法被彻底证明。
这就是为什么这个世界的形式化方法这一领域还依旧活跃
并存在如此多的问题尚未解决。

基于此学界有多个思路以解决。第一种思路围绕 model checker，通过各种
针对于不同缺陷种类的模型静态地分析程序以削除特定种类的缺陷。
这种方案依旧无法削除全部的缺陷，根本无法彻底证明实现的正确性。

第二种思路尝试将编程语言上的程序装入另一个表达能力更强的证明系统，
即将程序翻译进另一个证明系统以此完成原本类型系统无法触及的，
对程序实现正确性的证明。
这有诸多困难，首先程序到证明系统的翻译必须正确，既然是形式化证明
而非主观臆测的断言这翻译就必须被证明，这并不容易。其次
在一种形式语言上的程序翻译到另一个证明系统内，其表达一定会更加复杂。
根本上，程序验证的困难来自于编程语言一开始就未考虑证明而
仅针对程序的执行，将程序翻译到证明系统中除了增加复杂并不能使
程序更易于证明，因为根本的问题并未得到解决。

著名的 seL4 内核的形式化验证是这种思路的代表，
仅8700行的C语言与600行的汇编语言的程序被翻译到Isabelle/HOL 证明系统上
去形式化验证，最后生成了200,000行 Isabelle 代码并消耗
20人年才得以完成\cite{klein2009sel4}。

简化程序形式化验证的困难一定要从编程语言上着手，一开始就未考虑到证明
难度的编程语言上的程序一定是难以证明的。

第三种思路围绕依赖类型（Dependent typed system）踩在了点上，
这一类型系统基于 Curry–Howard 同构\cite{sorensen2006lectures} 而等价
于直觉逻辑，几乎可以表达所有性质，
而可以彻底证明程序的正确性。
Coq[?????], Agda\cite{norell2008dependently}, 
Idris\cite{brady2013idris} 是其中的代表。
但很可惜，高度抽象的类型系统意味着
这种编程语言难以生产高性能的编译结果。依赖类型的编程语言一定是函数式
的，而仅百年尝试的结果是函数式编程语言，因为性能包括空间性能与时间性能，
然后是易用性等种种原因，从一度占据的编程语言界的王座上退让下来而留下了
被过程式编程语言统治的软件工业界。而依赖类型的编程语言，更慢也更难，
不一定比上一种方案容易多少。

值得一提的是 MCMQ\cite{ioannidis2019extracting} 非常优秀，它将 Coq 
代码翻译到C++语言而拥有非常好的执行性能。
与本文相比仅缺少并行编程与对程序符号分析的能力，
在？？？章的相关工作与比较中将详细讨论。

本文将提出第四种思路。

\section{研究内容导论}

程序是一组机器的操作指令故而机器决定了其上的程序。

抽象机器（Abstract Machine）\cite{van1990handbookC1}
亦决定其上的程序。

若将抽象机器良好地定义在形式系统（Formal System）
\cite{shoenfield2018mathematicalC1}中，
即使用形式系统的形式语言符号地定义抽象机器，
则其上的程序亦可以被此形式语言表达。
若将需求也用同一形式语言中表述，即 Formal Specification，
那么此形式系统可以良好地形式化证明程序对此描述的满足性。
即若抽象机器是形式化的，程序是形式化的，而描述若亦用同一形式语言表述，
则可形式化证明程序对于描述的正确性，即满足性与正确执行性，
那么就是程序实现的正确性的证明。

若这个形式系统又是针对于形式证明设计的——可以直接地叫做证明系统，
且我们遵循着这证明系统的精神而不粗鲁地违抗，遵循着它的优雅性而
小心翼翼地在其上用它的形式语言特别保持友好地定义这抽象机器，
进而是抽象机器上的程序，始终让这些定义都与证明系统友好，是遵循证明系统
的精神的，那么由这些定义复合衍生构建出的程序就自然地理应与
证明系统友好，就理应能够容易且自然地形式化证明。

如果我们更幸运，保持对证明系统友好性的同时又可以保持对机器执行的友好性，
即这抽象机器的定义可以让其上的程序非常容易地编译到现实计算机，
且编译结果是高效的无论在时间上还是空间上，那这就太完美了。

事实证明的确如此幸运。
本文就是对这一思路的实践，本文的结果就是对其的验证。

这抽象机叫做$\amlh$，基于简单类型λ演算构建在 HOL 逻辑上，
这些都将在第 \ref{Ch.AmLH} 章论述。
$\amlh$ 上的软件开发通过编辑壳层 \ES  完成，将在 \ref{Ch.ES} 章论述。
两者联合构成$\Eamlh$给出在$\amlh$上的软件工程方案。

总结本工作的内容，在一个证明系统上友好地定义一台抽象机器，
包括对证明系统的友好性与对工程的友好性，并开发一套
在其上开发程序的软件工程方法，包括将程序从抽象机器上翻译到现实世界
的计算机上的方法，且一切都保持对证明系统友好的方式进行以确保证明的简洁
与容易，进而高效地生产实现正确性既被彻底证明的执行起来又很高效的程序。

实现正确性，编程效率，证明效率，执行效率，本文尝试四者兼顾。

本文跟现有思路的一些区别在于，本文的确是在探索一些新的
构建实现正确性被验证的程序，而并非寻找对已有程序验证的方法，
但本文不尝试设计新的形式语言更不尝试在其上构建新的类型系统，
故不同于依赖类型编程语言的思路，并非寻求一个用于编程的具有强大证明能力
的形式系统（于此，此形式系统被叫做类型系统）。
本文尝试在一个强大证明能力的形式系统（于此，此形式系统被叫做证明系统）
上进行程序开发，由此证明易于进行，且是贴合工程的程序开发，由此易于
开发并使编译结果有良好执行性能。
即本文尝试寻找一个证明系统上的软件开发方法，探索如何利用证明系统以提供
包括但不仅限于类型系统的功能。
接下来的论述会阐明，这种新的软件开发方法，严格来说没有
编程语言，证明系统取代了类型系统而严格来说没有类型系统。

最易于分析且能够允许程序编写的形式系统是 $\lambda$ 演算
\cite{sorensen2006lecturesC1, barendregt1984lambda, pierce2002typesC59}，
而最易于证明的形式系统本文认为是经典逻辑（Classical Logic）
或者说高阶逻辑（High Order Logic）
\cite{constructive_classic_logic}，
此处经典旨在区别于新兴的直觉逻辑（Intuitionistic Logic），
\cite{girard1989proofsC3, sorensen2006lecturesC2}，
而经典高阶逻辑仍然是目前数学领域的主流，这两者实际指代同一事物。

目前大量的数学形式证明工具已成熟，
特别是已有近50年历史的交互式定理证明工具（Interactive Theorem Prover），
提供了有效的形式化分析与证明的手段。
HOL 理论证明器（HOL Theorem Prover）是其中的先行者，并活跃地发展至今，
已广泛应用于学界的各个领域，其提供了一套类似经典逻辑的形式化证明系统。

本文选择了HOL理论证明器，尝试在这个交互式理论证明器提供的
类似经典逻辑的证明系统上
基于简单类型$\lambda$演算（$\lamst$演算）构造一台
可以用于软件开发的抽象机器。
抽象机可用于软件开发，外层的证明系统又能对内层的抽象机进行分析与证明，
进而对抽象机上的程序分析与证明，再进而提供编程辅助，
因为这抽象机是定义在定理证明器提供的证明系统上。

内层抽象机定义在外层证明系统内，是证明系统上的数理对象
（Mathematical Object），
抽象机上的程序亦是证明系统上的数理对象。
以数理对象同时承载用户的抽象思维与程序的具象执行，
就不会因传统程序语言表达从抽象到具象的转换过程丢失信息。
以构造数理对象的方式编织程序，程序不是通过编程语言编写的，
故没有编程语言。

程序的各种特性成为证明系统上的命题，也就是定理证明器上的命题，
就可以有效地对这些特性进行一切可能的数学分析与证明，
一如定理证明器对任何普通命题的证明，因为关于程序的一切都发生在抽象机上，
而抽象机构建在证明系统内。
就可以彻底地证明程序的正确性，可停机性，与对描述的满足性，
即实现的正确性。
如此一来也就根本不需要类型系统，证明系统替代了一切类型系统的功能，
这也并不意味着失去了自动类型推导，证明系统上的演绎规则（Deductive rule）
足以允许相当多的自动性质推导。

内层抽象机基于$\lamst$演算实现，非常简洁仅围绕一个基本类型，
被非常巧妙地设定以易于外层证明系统对其分析。
而其上的程序编写通过外层证明系统实现，定理证明器提供充分的辅助
以良好地支持抽象机上的程序开发，实现类似集成开发环境（IDE）等诸多
工具对程序开发的辅助功能。

更进一步，这样的符号分析可以是满足抽象机所定义的等价关系的变换，
就可以对抽象机上的程序进行符号运算，
且这运算的正确性又在外层证明系统的保障之下。
而这种符号运算既可以是向下的求值，也可以是横向的编译变换，
即用外层证明系统对内层抽象机演算上的程序进行以编译为目的的等价变换，
而这就是编译。

抽象机器到抽象机器的程序翻译是确定且固定的，
构造抽象机到真实计算机或JVM等虚拟机间的翻译程序，就可以
将此抽象机上的抽象程序编译到现实的执行环境中。
而这一翻译发生在证明系统内，因为证明系统就是抽象机的外环境，
于是这翻译本身就是定理证明器上依照抽象机定义的等价关系的变换，
这变换被证明系统保障，也就是编译正确性被定理证明器验证。
尽管直接在定理证明器内生成目标指令代码并不容易，但可以利用
中间表达（Intermediate Representation）技术，只是在证明系统内编译到
基于数理表达式的中间表达，此处的编译是被验证的，再在外部
尽管无验证保障但更方便且高效地将中间表达编译至目标指令。

事实上一切对内层抽象机上程序的编写、分析、到中间表达的编译，
都发生在外层证明系统内，
证明系统是其外环境，即从始至终程序开发发生在定理证明器提供的数理环境内。

这意味着质的变化。得以允许
巧妙的设定让这一体系拥有实际的软件工业生产能力的同时保持良好的数学亲和性——
既然编程就是直接的数理对象的构造，编程范式就应当更加地贴近数理方式，
一切程序开发发生在证明系统上数理范畴内就允许
程序设计方法学的种种从抽象出发并始终围绕数理思维方式，
进而使用户的编程思维以数理的角度进行。
于上本文认为这种编程范式更亲和于程序的抽象模型就更利于程序设计，
于下亲和数理的程序表达又更利于数学分析与证明，
而其间数理分析由始至终为程序设计与开发提供强有效的辅助。
于是其分析、辅助、编译均从始至终以数学亲和的方式在抽象的范畴内进行，
其下的定理证明器所提供的本就优秀的数理分析功能就能发挥强劲的功效，
进而不输任何传统的软件工程工具。

本文将这种高阶逻辑上的抽象机叫做 $\amlh$，$\mathrm{A}$ 表示抽象机器
（Abstract Machine），上标$\lamst$表示简单类型λ演算，下标
$\mathrm{HOL}$表示其所基于的HOL证明系统这一形式系统。
抽象机 $\amlh$ 将在第\ref{Ch.AmLH}章论述。
单纯的 $\amlh$ 仅是一系列理论，无法直接用于程序开发，第\ref{Ch.ES}章
论述\ES 编辑壳层，一种基于λ2演算上的下推自动机（Pushdown automata）
的状态机与同名的软件工具。
这一工具向下对接到HOL交互式证明器并开放给用户用于编辑数理对象。
将$\amlh$理论在HOL交互式定理证明器并装入编辑壳层\ES 中，
就构成了本文最终的成果，程序开发工具 $\Eamlh$ 与同名的软件工程方法。


%
%
%
%
%------------------------
%
%
%
%
%
%
%
%这一论述很美好。
%
%编程语言本就是形式的，计算机的抽象模型也可以轻易地抽象化，充分利用状态机
%就能做到。
%而显然，这些语言上的程序、计算机上的程序理论上都可以被形式化地验证。
%
%但实际上，非常困难，稍微实践一下就会知道。
%
%现实的计算设备的抽象模型往往出于工程的角度，
%使用了大量利于工程实现的模型如状态机等，是不利于数学证明的。
%而由理念出发的对程序的描述，往往是贴近数学的抽象。
%亦即，现实的计算设备往往是基于状态机等工程应用式的，
%而程序功能的期望描述是更加抽象的。
%理念的抽象与实际工程应用间的差异，
%是形式化方法特别是其中的形式化验证在现在的软件工程工业界所遇到的问题。
%难以想象，将如何从一个状态机的各种状态转移中还原一个素数判定程序的抽象意义。
%
%理论上任何形式系统下表达的程序均可以被形式化验证，但实际上
%并非都易于验证。
%本文认为，形式化验证之所以困难重重是因为期望被验证的目标，
%在不易于分析的形式系统下的程序，以及那些被不易于分析的形式表达的程序，
%不易于被验证。即，这个问题太难了。
%所以\textbf{本文的思路是，修改问题本身}——设计一个易于分析与验证的形式系统，
%并开发出一套在此形式系统上开发软件的方案，而要求用户一开始就在其上开发软件。
%即，不是努力尝试解决问题，而是反过来修改问题本身。
%
%但问题在于编程工具与证明工具的混淆，依赖类型本身的过度复杂对编程的妨碍，
%构造主义（Constuctism）的证明方式固然可以允许“程序即证明”但也增加了
%证明难度并缺失了半自动的证明辅助，函数式的架构又不利于程序的执行性能。
%这些具体的比较会在？？？章详细论述。
%
%
%
%为论述方便，以符号 $\amlh$ 表示本文提出的
%基于经典逻辑的基于简单类型$\lambda$演算的抽象机，其中 $\mathrm{A}$ 表示抽象机
%（Abstract Machine），$\mathrm{HOL}$ 是高阶逻辑（High Order Logic）的缩写，
%高阶逻辑是经典逻辑仅是侧重点不同的别称，$\mathrm{HOL}$ 另外也是本文工作基于的
%HOL 交互式定理证明器的缩写，最后$\lamst$是简单类型$\lambda$演算的通用符号，
%$\lamst$为上标而$\mathrm{HOL}$为下标意味着在经典逻辑构建的简单类型$\lambda$演算。
%
%总结一下，本工作的要义是在交互式定理证明器的证明系统上构建一台抽象机，即$\amlh$，
%并提供其上的编程语言和一系列方案与必须的封装，特别是最后将$\amlh$上的程序
%编译到现实的计算机上的方法。
%在证明系统上进行软件开发与调试、测试、分析一系列的软件工程，
%即令程序直接变作抽象的数理对象而可以被表达为证明系统上的表达式；
%令编程本身变作证明系统上数理结构的构造；程序分析是对数理结构的分析；
%而编译是证明系统上对这些数理结构的等价变换，最后输出易于编译到目标执行平台
%的中间表达。
%
%即摒弃传统软件工程的方案与思路，而是尝试在数理的抽象环境中，
%以数理对象表达程序，提供一整套新的软件开发方案。
%结合定理证明器提供的强大数学分析能力，以提供更有效的形式化辅助与验证，
%本文相信会比传统方式更好。
%
%也意味着大量的工作。
%
%\section{具体工作内容与章节安排}
%
%不同于Agda, Idris 仅仅是基于新型的依赖类型系统设计一门编程语言，更不同于
%MCMQ 仅仅是一个编译器。
%围绕编程语言为核心，涉及类型系统、编译器、证明器、编辑器等本工作实际要
%涉及的是一套完整的开发环境。
%
%崭新的基于数理抽象思维出发的软件开发思路意味着借鉴传统方式的同时大量
%新的路子值得被设计，包括类型系统、编译、编辑在内的诸多方面都有新的探索。
%
%首先第二章讲述$\amlh$的具体设计。
%第一节讲述$\amlh$相关思想概念与原理，包括其上程序的编写与编译原理。
%第二节讲述系统状态相关问题。
%$\lambda$ 演算简洁优雅，使用$\lambda$演算建模现实计算机的主要困难在于
%现实计算机有大量的状态，故相对而言状态机更适合建模现实计算机。
%第二节讲述如何解决此问题，有两种方案。
%一种是通过单源单汇有向无环网络流记录所有
%的状态修改历史以将系统状态数值化而成功用$\lambda$演算表达系统状态转移。
%另一种是力图将计算与状态分离，而将计算本身无状态化。
%第三节正式定义$\amlh$，包括本工作研究的两种版本，
%细粒度$\amlh$与粗粒度$\amlh$。
%
%第三章讲述类型系统，本工作受现象与本质这两个哲学概念的启发，设计了
%基于现象与本质对应关系的类型系统。
%本章主要以理论的形式叙述组成，第一节讲述
%数值的现象-本质对应类型系统，第二节讲述系统状态的分析模型。
%
%第四章讲述用户接口，本工作设计了一种具有 Girard 多态类型的状态机作为
%用户接口，并设计了一系列编辑用的算子。
%第一节讲述编辑状态机与编辑语言的设计。
%第二节讲述其上的各种算子，包括懒惰算子，可变算子，调用算子，输入栈算子。
%第三节综合论述此编辑接口的实现并包含案例分析。
%
%第五章讲述一个以 WASM 为编译目标平台智能合约为应用场景的抽象机$\amlhWASM$的实现，
%实现并验证一个 ERC20 合约。
%第一节讲述$\amlhWASM$的指令集设定。
%第二节讲述验证与半自动证明策略。
%第三节讲述编译方法与半与半自动编译变换函数。
%第四节讲述用户接口上的开发环境实现。
%第五节讲述 ERC20 合约的实现、验证与测试。
%
%第六章讲述相关工作与比较。
%第一节概述交互式定理证明器。
%第二节概述与比较相关的形式化验证方法。
%
%\section{本工作的特性与优势}
%
%暂时跳过具体的论述而预先给出本工作的特性与优势。
%
%\begin{itemize}
%  \item 内在支持并行。基于计算依赖与逻辑依赖的自动并行。
%  \item 支持对程序强大的静态分析，可以计算程序的最糟运行时间，甚至理论上
%  给定输入的概率密度函数可以计算程序运行时间的概率分布。
%\end{itemize}
