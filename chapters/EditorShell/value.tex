\subsection{值}

现在定义值（Value）。

\begin{defin}[值的单词集] 
无穷单词集 $\hLv$ 为表示值变量的字母表 $\hLv \subseteq
\Words$，无穷单词集 $\hLc$ 为用于表示预定义常量的字母表 $\hLc \subseteq
\Words$，两集合不相交 $\hLc \cap \hLv = \emptyset$, 且 $\hLc$ 包含所有的数字单词、所有的小数单词、所有的字符串字面量单词。
\[ \underline{0},\ \underline{1},\ \underline{2},\cdots,\ 
\underline{0.1},\ \underline{0.01},\cdots,\ \underline{\squote
a \squote},\ \underline{\squote ab \squote},\ 
\cdots \in \hLc \]
\end{defin}

\begin{defin}[值常量、值变量、值] \label{D.Value}
所有的值常量构成集合 $L_c$ ，所有值变量构成集合 $L_v$ 
$L_c^2$
\begin{align*} 
L_c &= \bnf{\hLc : \PiAE}&L_v &= \bnf{\hLv : \PiE}&\end{align*}
所有的值构成的集合 $\LE$ 是所有满足如下规则的最小集合
\[ \begin{array}{rcl}
x \in L_c & \Rightarrow & x \in \LE\\
x \in L_v & \Rightarrow & x \in \LE \\
\underline{x\ :\ (\ \rightarrow\ \sigma\ \tau\ )} \in \LE\ \land\ 
\underline{y\ :\ \sigma} \in \LE & \Rightarrow & 
\underline{(\ x\ :\ (\ \rightarrow\ \sigma\ \tau\ )\ y\ :\ \sigma\ )}
\in \LE\\
v \in L_v\ \land\ x \in \LE & \Rightarrow & \underline{(\ λ\ v\ x\ )}
\in \LE
\end{array} \]
上述的第三条规则类似 λ 演算中的组合律，也可以将 $\LE$ 集理解为
满足 λ 类型规则（主要是组合律）的满足语法
\[ L_c \mbar L_v \mbar (\ \LE\ \LE\ ) \mbar (\ \lambda\ L_v\ \LE \ )\]
的集合。

然后是量化值集 $\LE^2$ 量化值常量集 $L_c^2$
\begin{align*}
\LE^2 &= \bnf{\LE \mbar \Lambda \Uv\ \LE^2}& 
L_c^2 &= \bnf{L_c \mbar \Lambda \Uv\ L_c^2} &
\end{align*}
$\underline{(\ \lambda\ x_1\ (\ \lambda\ x_2\ 
\cdots\ (\ \lambda\ x_n\ u\ )\ \cdots\ )\ )}$ 同样可以被写作
$\lambda x_1\ x_2\ \cdots\ x_n.\ u$ \quad，

\noindent
 $\underline{(\ \Lambda\ \tau_1\ (\ \Lambda\ \tau_2\ \cdots\ (\ \Lambda
\ \tau_m u\ )\ \cdots\ )\ )}$ 可以被写作
$\Lambda \tau_1\ \tau_2\ \cdots\ \tau_m.\ u$ \quad，

\noindent 抽象变量是有类型标记的，类似Church式。另外显然有
\begin{align*} L_c &\subseteq \LE& L_v &\subseteq \LE&
L_c \cap L_v &=\emptyset& L_c^2 &\subseteq \LE^2
\end{align*}
量化值的量化类型变量 $\LV : \LE^2 \rightarrow \powerset(\Uv)$ 被递归定义
\begin{align*} \LV x &= \{\}&&\text{当}\quad x \in \LE&\\
\LV \underline{\Lambda \tau\ x} &=\{\tau\} \cup \LV x&&\text{当}\quad
\underline{\Lambda \tau\ x}\in \LE^2&
\end{align*}
自然地同样递归定义量化值的值 $\LB : \LE^2 \rightarrow \LE$
\begin{align*} \LB x &= x&&\text{当}\quad x \in \LE&\\
\LB \underline{\Lambda \tau\ x} &=\LB x&&\text{当}\quad
\underline{\Lambda \tau\ x}\in \LE^2&
\end{align*}
递归定义值的值重量（value only weight）
    $\vw : \LE \rightarrow \mathbb{N}$
\[ \begin{array}{lclcl}
\vw \underline{(\ u:\tau\ )} & = & 1 & \when & \underline{(\ u:\tau\ )}
\in \LE\\
\vw \underline{(\ f\ a\ )} & = & \vw(f) + \vw(a) & \when & 
    \underline{(\ f\ a\ )} \in \LE\\
\vw \underline{(\ \Lambda\ v\ x\ )} & = & 1 + \vw(x) & \when & 
    \underline{(\ \Lambda\ v\ x\ )} \in \LE\\
\end{array} \]
注意不要混淆值重量与类型重量，它们同为符号 w，但定义域不同且不相交，可
根据定义域区分。
递归定义值的类型重量（type only weight）$\vwt : \LE \rightarrow \mathbb{N}$
\[ \begin{array}{lclcl}
\vwt \underline{(\ u:\tau\ )} & = & \TS \tau & \when & \underline{(\ u:\tau\ )}
    \in \LE\quad\text{注意}\ \TS \tau\ \text{是类型重量}\\
\vwt \underline{(\ f\ a\ )} & = & \vwt(f) + \vwt(a) & \when & 
    \underline{(\ f\ a\ )} \in \LE\\
\vwt \underline{(\ \Lambda\ v\ x\ )} & = & 1 + \vwt(x) & \when & 
    \underline{(\ \Lambda\ v\ x\ )} \in \LE\\
\end{array} \]
最后是值的总重量 $\vW : \LE \rightarrow \mathbb{N}$
\[ \vW x = \vw x + \vwt x \]
以及相应的量化值的值重量、类型重量、总重量
\begin{align*} 
    \Vw z &= \abs{\LV z} + \vw(\LB z) \\
    \Vwt z &= \abs{\LV z} + \vwt(\LB z) \\
    \VW z &= \Vw z + \Vwt z
\end{align*}
同样可以通过定义域区分这些量化值的重量与值的重量，额外的，因为任何值
也都是一种量化值 $\LE \subseteq \LE^2$，任何值被视作量化值时的量化值
的各种重量跟作为普通值时值的各种重量是相同的，故不会引起冲突。
\end{defin}

\begin{defin}[$\LE$ 与 $\LE^2$ 的类型] \label{D.type}
递归函数 $\type : \LE \rightarrow \PiE$ 计算值的类型
\[ \begin{array}{lcl}
\type \underline{(\ x\ :\ \tau\ )}  =  \tau &\when&
\underline{(\ x\ :\ \tau\ )} \in L_c \cup L_v\\
\type \underline{(\ x\ :\ (\ \rightarrow\ \sigma\ \tau\ )\ y\ :\ 
\sigma\ )}  =  \tau &\when&
\underline{x\ :\ (\ \rightarrow\ \sigma\ \tau\ )} \in \LE\ \land\ 
\underline{y\ :\ \sigma} \in \LE\\
\type \underline{(\ \lambda\ v\ x\ )}  =  \type(v) \rightarrow 
\type(x) & \when & x \in \LE \ \land\ v \in \LE
\end{array} \]
由字符串代数的定义 \ref{D.StringAlgebra} 中字符串的有限性以及定义
\ref{D.Value} 这样的递归定义是可行的。

定义量化值的类型 $\type^2 : \LE^2 \rightarrow \PiAE$
\begin{align*} \QB \type^2(x) &= \type \LB(x)&
\QV \type^2(x) &= \LV(x) & \end{align*}
\end{defin}

这一定义也给出了计算值的类型的递归算法 \ref{alg:type} type，与
计算量化值了类型的算法 \ref{alg:type2} $\type^2$。

\begin{algorithm}
\caption{值的类型 type} \label{alg:type} \algcase
\begin{multicols}{2}
\begin{algorithmic}[1]
\Require 值 $x \in \LE$
\Ensure $\type x$
    \Case {x} \When {$\underline{(\ v:\tau\ )}$} \State 输出 $\tau$
    \When {$\underline{(\ f\ a\ )}$} \State $\type(f) \rightarrow
    \underline{(\ \rightarrow\ \sigma\ \tau\ )}$
    \State 输出 $\sigma$ \When {$\underline{(\ λ\ v\ x\ )}$} \State
    输出 $\type(v) \rightarrow \type(x)$
    \EndCase
\TimeComplexity $O(\vw x)$
\end{algorithmic}
\end{multicols}
\end{algorithm}
\begin{algorithm}
\caption{量化值的类型 $\type^2$} \label{alg:type2} \algcase
\begin{multicols}{2}
\begin{algorithmic}[1]
\Require 值 $z \in \LE^2$
\Ensure $\type^2 z$
\Case {$z$} \When $\underline{(\ \Lambda\ v\ x\ )}$
\State $\type^2 x \rightarrow \tau$
\State $\type v \rightarrow \sigma$
\State $\underline{(\ \forall\ \sigma\ \tau\ )}$
\ElseCase \Comment{那么 $z \in \LE$}
    \State 输出 $\type z$ \EndCase
\TimeComplexity $O(\Vw x)$
\end{algorithmic}
\end{multicols}
\end{algorithm}

值集 $\LE$ 上也具有 β 规约，与定义 \ref{D.breduce} 是一样的。

\begin{lemma} \label{L.Le.expand}
\[ \begin{array}{lcc}
\underline{(\ x\ y\ )} \in \LE&\vdash& x \in \LE\ \land\ y \in \LE\\
\underline{(\ \lambda\ v\ x\ )} \in \LE&\vdash& x \in \LE
\ \land\ v \in L_v\\
\end{array} \]
\begin{proof} 由$\LE$的定义 \ref{D.Value} 这是显然的。
\end{proof}
\begin{lemma} \label{L.breduce.in1}
\[ \underline{(\ (\ \lambda\ v\ x\ )\ y\ )} \in \LE \vdash
x \in \LE \]
\begin{proof} 由引理 \ref{L.Le.expand} 直接推论。 \end{proof}
\end{lemma}
\begin{lemma} \label{L.breduce.in2}
\[ a \in \LE,\ a \breduce b \vdash b \in \LE \]
\begin{proof} 由引理 \ref{L.breduce.in1} 以及归纳法证得。 \end{proof}
\end{lemma}
\begin{lemma} \label{L.breduce.in3}
\[ a \in \LE,\ a \bbreduce b \vdash b \in \LE \]
\begin{proof} 由引理 \ref{L.breduce.in2} 以及 $\bbreduce$ 的定义
\ref{D.breduce} 证得。 \end{proof}
\end{lemma}

\begin{defin}[\LE 上的 β 规约函数]
由β规约的唯一性定理 \ref{T.bbreduce.11} 和显然的存在性定理，
以及引理 \ref{L.breduce.in3} 证明的闭包性，允许
定义进行 β 规约的函数 $\B : \LE \rightarrow \LE$
\[ \forall x \in \LE.\ x \bbreduce \B x \]
\end{defin}

\end{lemma}
\begin{lemma} \label{L.Le.Comp.Texpand}
\[ \underline{(\ x\ y\ )} \in \LE,\ \tau \in \PiE,\ 
(\type \underline{(\ x\ y\ )} = \tau) \vdash \exists \sigma \in \PiE
.\ (\type x = \sigma \rightarrow \tau)\ \land\ (\type y = \sigma) \]
\begin{proof} 由引理 \ref{L.Le.expand} 与定义 \ref{D.type} 
定义 \ref{D.Value} 证得。
\end{proof}
\end{lemma}
\begin{lemma} \label{L.Le.type.lxyv}
\[ \underline{(\ (\ \lambda\ x\ y\ )\ v\ )} \in \LE \vdash
\type \underline{(\ (\ \lambda\ x\ y\ )\ v\ )} = \type x \]
\begin{proof} 由引理 \ref{L.Le.Comp.Texpand} 与定义 \ref{D.type} 
定义 \ref{D.Value} 证得。
\end{proof}
\end{lemma}
\begin{lemma}[$\LE$上β规约类型不变] \label{L.breduce.type.consist}
\[ x,y \in \LE,\ x \breduce y \vdash \type x = \type y \]
\begin{proof} 由引理 \ref{L.Le.type.lxyv} 以及对 β 规约归纳法证得。
\end{proof}
\end{lemma}
\begin{lemma}[$\LE$上多步β规约类型不变] \label{L.bbreduce.type.consist}
\[x,y \in \LE,\ x \bbreduce y \vdash \type x = \type y \]
\begin{proof} 由引理 \ref{L.breduce.type.consist}
以及多步 β 规约的定义 \ref{D.breduce} 证得。
\end{proof}
\end{lemma}
\begin{theo}[B规约函数类型不变]
\[x \in \LE \vdash \type \B(x) = \type x\]
\end{theo}

\begin{defin}[值的调用与可调用性] \label{D.V.call}
若值 $f$ 与值 $a$ 满足条件 $f \vcallable a$则被叫做 $f$ 可被 $a$ 调用。
\[ f \vcallable a = \exists \sigma,\ \tau \in \PiE.\ 
(\type f = \sigma \rightarrow \tau)\ \land\ (\type a = \sigma) \]
显然有
\[ f \vcallable a \Rightarrow \underline{(\ f\ a\ )} \in \LE \]
进而有值的调用函数 $(\vcall) : \LE \times \LE \rightarrow \LE$
\[ f \vcallable a \Rightarrow (f \vcall a = \B\underline{(\ f\ a\ )}) \]
同样此处的符号 $(\vcall)$ 不应被混淆因为定义域不同。
\end{defin}

\begin{algorithm}
\caption{值的可调用测试 suit} \label{alg:suit}
\begin{algorithmic}[1]
\Require 值 $f,\ x \in \LE$
\Ensure Bool 值 $f \vcallable x$
    \State 输出 $(\type f\ \text{是函数类型}\quad\land\quad \Dom(\type f) =  \type x)$
    \TimeComplexity $O(1)$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{值的调用 vCall} \label{alg:vCall}
\begin{algorithmic}[1]
\Require 值 $f,\ x \in \LE\quad$满足 $f \vcallable x$
\Ensure $f \vcall x$
\State 对 $\underline{(\ f\ x\ )}$ 进行 β 规约，然后输出。
    \TimeComplexity $O(\vw(f) + \vw(x))$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}\algcase
\caption{值的特化 Inst} \label{alg:Inst}
\begin{multicols}{2}
\begin{algorithmic}[1]
\Require 特化范围 $V \in \powerset(\Uv)$，类型特化函数 $f : \Uv \rightarrow \PiE$，值 $x \in \LE$
\Ensure $\Inst_V\ f\ x$
    \Case {$x$}
    \When {$\underline{(\ v:\tau\ )}$}
    \State $\inst(V,f,\tau) \rightarrow \tau'$
    \State 输出 $\underline{(\ v:\tau'\ )}$
    \When {$\underline{(\ u\ v\ )}$}
    \State $\Inst(V,f,u) \rightarrow u'$
    \State $\Inst(V,f,v) \rightarrow v'$
    \State 输出 $\underline{(\ u'\ v'\ )}$
    \When {$\underline{(\ \lambda\ v\ u\ )}$}
    \State $\Inst(V,f,u) \rightarrow u'$
    \State $\Inst(V,f,v) \rightarrow v'$
    \State 输出 $\underline{(\ \lambda\ v'\ u'\ )}$
    \EndCase
\TimeComplexity $O(\vW x)$
\end{algorithmic} \end{multicols}
\end{algorithm}
\begin{algorithm}
\caption{值量化 MakeQV} \label{alg:MakeQV}
\begin{algorithmic}[1]
\Require 类型变量集 $V \in \powerset(\Uv)$，量化目标 $x \in \LE$
\Ensure $z \in \LE^2\quad$ 满足 $\LV z = V\quad\land\quad\LB z = x$
\For {$v \in V$} \State $\underline{\Lambda}\concat v \concat
    x \rightarrow x$ \EndFor
\State 输出 $x$ \TimeComplexity $O(\abs{V})$
\end{algorithmic} 
\end{algorithm}

至此定义完了普通值的调用运算，可以由此执行大量的函数调用。接下来将定义
量化值的调用运算。首先从量化值的特化开始。

\begin{defin}[值的特化] \label{D.Inst}
递归定义值的特化函数 $\Inst : (\Uv \rightarrow \PiE) \rightarrow \LE
\rightarrow \LE$，但其值域 $\LE$ 是需要证明，这将在引理 \ref{D.Inst.LE}
中完成，追求严谨的读者可以先认定其值域为 $\String$
\[ \begin{array}{llcr}
\Inst f\ \underline{(\ x : \tau\ )} = \underline{(\ x : \tau' \ )}
,& \tau' = \inst f\ \tau & \when & \underline{(\ x : \tau\ )}
\in \LE\\
\Inst f\ \underline{(\ g\ a\ )} = \underline{(\ g'\ a'\ )},&
g' = \Inst f\ g,\quad a' = \Inst f\ a& \when & \underline{(\ g\ a\ )}
\in \LE\\
\Inst f\ \underline{(\ \lambda\ v\ x\ )} = \underline{(\ \lambda\ v'
\ x'\ )},&v' = \Inst f\ v,\quad x' = \Inst f\ x&\when&
\underline{(\ \lambda\ v\ x\ )} \in \LE
\end{array} \]
同样的部分特化 $\Inst_V$
\[ \begin{array}{llcr}
\Inst_V f\ \underline{(\ x : \tau\ )} = \underline{(\ x : \tau' \ )}
,& \tau' = \inst_V f\ \tau & \when & \underline{(\ x : \tau\ )}
\in \LE\\
\Inst_V f\ \underline{(\ g\ a\ )} = \underline{(\ g'\ a'\ )},&
g' = \Inst_V f\ g,\quad a' = \Inst_V f\ a& \when & \underline{(\ g\ a\ )}
\in \LE\\
\Inst_V f\ \underline{(\ \lambda\ v\ x\ )} = \underline{(\ \lambda\ v'
\ x'\ )},&v' = \Inst_V f\ v,\quad x' = \Inst_V f\ x&\when&
\underline{(\ \lambda\ v\ x\ )} \in \LE
\end{array} \]
最后是量化值的特化 $\Inst_\Lambda : (\Uv \rightarrow \PiE) \rightarrow 
    \LE^2 \rightarrow \LE$
    \[ \Inst_\Lambda f\ z = \Inst_{\ \LV z}\ f\ \LB(z) \]
\end{defin}

\begin{lemma} \label{D.Inst.LE}
\begin{align*}
    &x \in \LE \vdash \Inst\ f\ x \in \LE&
    &x \in \LE \vdash \Inst_V\ f\ x \in \LE&
\end{align*}
\begin{proof} 由$\LE$集的定义 \ref{D.Value} 特化的定义 \ref{D.Inst}
    容易得到。
\end{proof}
\end{lemma}


值的特化的递归定义 \ref{D.Inst} 同时也给出了值特化的算法，形式地写作
算法 \ref{alg:Inst} Inst。



\begin{defin}[量化值的特化集]
量化值的特化集函数 $\VI : \LE^2 \rightarrow \powerset(\LE)$
    \[ \VI z = \{ \Inst_\Lambda\ f\ z \mbar f \} \]
即所有量化值 $z$ 可以特化成的值构成的集合。
\end{defin}

\begin{defin}[量化值的 α 等价]
$\LE^2 \times \LE^2$ 上的等价关系 $\sim_\alpha$
    \[ z_1 \sim_\alpha z_2 = (\VI z_1 = \VI z_2) \]
即可以理解为本质不同的量化值。
\end{defin}

接下来构建量化值的调用，方法跟 \ref{S.T.Call} 节一样，先定义特化集
的调用而后证明存在一个量化值其特化集等于此调用集，于是此量化值
就能代表特化集调用的结果。

\begin{defin}[值的集的调用]
值的集的调用是函数 $(\vcalls) : \powerset(\LE) \times \powerset(\LE)
    \rightarrow \powerset(\LE)$
    \[ Z_1 \vcalls Z_2 = \{ z_1 \vcall z_2 \mbar z_1 \in Z_1\ \land\ 
    z_2 \in Z_2\ \land\ z_1 \vcallable z_2 \} \]
同样此 $(\vcalls)$ 不应跟任何别的运算诸如类型的调用 $(\cdot)$ 混淆，
因为定义域不同，可以通过区分定义域而区分这些运算。
\end{defin}

\begin{algorithm}
\caption{量化值调用 VCall} \label{alg:VCall}
\begin{multicols}{2}
\begin{algorithmic}[1]
\Require 量化值 $z_1, z_2 \in \LE^2$
\Ensure $z \in \LE^2\quad$ 满足 $\quad \VI z = \VI z_1 \vcalls \VI z_2
    \quad$或者输出 {\it 无解}
\State $\type^2 z_1 \rightarrow \zeta_1$ 
\State $\type^2 z_2 \rightarrow \zeta_2$ 
\If {$\mathrm{QCall}(\zeta_1,\ \zeta_2) =\ \text{\it 无解}$}
    \State 输出 {\it 无解}
\Else \State $\mathrm{QCall}(\zeta_1,\ \zeta_2) \rightarrow (\zeta,\ f)$
\EndIf
    \State $\Inst(f,\ \LV z_1) \rightarrow x_1$
    \State $\Inst(f,\ \LV z_2) \rightarrow x_2$
    \If {$\mathrm{vCall}(x_1,\ x_2) =\ \text{无解}$}
    \State 输出 {\it 无解}
    \Else
\State $\mathrm{vCall}(x_1,\ x_2) \rightarrow x$
    \EndIf
    \State 输出 $\mathrm{MakeQV}(\QV \zeta,\ x)$
    \TimeComplexity $O((\abs{\LV z_1} + \abs{\LV z_2} + 1)(
    \TS(\type \LB(z_1)) + \TS(\type \LB(z_2))) + \vW(\LB z_1) + 
    \vW(\LB z_2))$
\end{algorithmic}
\end{multicols}
\end{algorithm}

\begin{theo} \label{T.VCall}
    \[ \VI z_1 \vcalls \VI z_2 \neq \emptyset \vdash \exists z \in \LE^2
    .\ \VI z_1 \vcalls \VI z_2 = \VI z\]
\begin{proof} 算法 \ref{alg:VCall} VCall 就是寻找这样的 $z$，且根据
    算法 \ref{alg:QCall} QCall 的正确性定理与停机性定理 \ref{T.QCall}
    算法 \ref{alg:VCall} VCall 也是有限停机的。
\end{proof}
\end{theo}

算法 \ref{alg:VCall} VCall 的时间复杂度比较复杂，但是多项式的。
由算法 \ref{alg:VCall} VCall 以及定理 \ref{T.VCall} 可以定义量化值的
调用。

\begin{defin}[量化值的调用]
量化值的可调用性测定函数 $\vcallable : \LE^2 \times \LE^2 \rightarrow
    \Bool$
\[ z_1 \vcallable z_2 = (\VI z_1 \vcalls \VI z_2 \neq \emptyset) \]
算法 \ref{alg:VCall} VCall 可计算 $\vcallable$，当 $\mathrm{VCall}(
    z_1,\ z_2)$ 有解时 $z_1 \vcallable z_2 = \T$ 无解时 $z_1 \vcallable
    z_2 = \F$。接下来是
量化值的调用函数 $(\vcall)$
    \[ z_1 \vcallable z_2 \vdash \VI (z_1 \vcall z_2) = \VI z_1 \vcalls
    \VI z_2 \]
在 $z_1 \vcallable z_2$ 时算法 \ref{alg:VCall} VCall 有解且其结果即是
对 $z_1 \vcall z_2$ 的计算。
\end{defin}

量化调用的灵感在于，可以将量化值对应到一个集合，集合由此量化值所有
可以特化出的值组成，即特化集合，
$z_1 \vcallable z_2$ 的情况下 $z_1 \vcall z_2$ 是也一个量化值而此
量化值对应的特化集合即是将$z_1,\ z_2$对应的特化集的所有值一一尝试调用
得到的结果构成的集合。

一个值 $z$ 是全称量化的，意味它可以特化到很多非量化类型，
其本身代表了一种泛性，例如 $\I$ 函数就是全称量化的，它的类型是
$\forall \tau.\ \tau \rightarrow \tau$

