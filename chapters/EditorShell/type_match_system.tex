\subsection{类型匹配系统}

\begin{defin}[类型匹配系统(Type Match System)] 类型匹配系统集 $\TMs$ 是集合
\[ \TMs = \powerset(\Uv) \times \powerset(\PiE \times \PiE) \]
类型匹配系统是所有集合 $\TMs$ 中的元素。
\[ (V,\ \{ (x_1, y_1),\ (x_2, y_2),\ (x_3, y_3),\ \cdots \}) \]
其中 $\{ (x_1, y_1),\ (x_2, y_2),\ (x_3, y_3),\ \cdots \}$ 叫做
匹配系统中的方程组，$x_1 = y_1,\ \cdots$ 是方程组中的方程，
$V \subseteq \Uv$ 是类型匹配系统的变量集。
\end{defin}
\begin{notation}[类型匹配系统的记号] 
记号
\[ \begin{Bmatrix}
x_1 &=& y_1 \\
x_2 &=& y_2 \\
x_3 &=& y_3 \\
&\cdots& 
\end{Bmatrix}_V \]
表示类型匹配系统
\[ (V,\ \{ (x_1, y_1),\ (x_2, y_2),\ (x_3, y_3),\ \cdots \}) \]
\end{notation}
\begin{defin}[类型方程组的重量]
类型方程组的重量函数 $\EQW : (\PiE \times \PiE) \rightarrow \mathbb{N}$
    \[ \EQW X = \sum_{(x,y) \in X} \TS(x) + \TS(y) \]
$\abs{\UV X}$ 表示集合 $\UV X$ 的大小，$\EQW$ 仅在 $X$ 有限时被定义。
\end{defin}
\begin{defin}[类型匹配系统的重量]
类型匹配系统的重量函数 $\TMW : \TMs \rightarrow
    \mathbb{N} \times \mathbb{N}$
    \[ \TMW (V,X) = (\abs{V},\EQW X)\]
同样 $\TMW$ 仅在 $X$ 有限时被定义。
\end{defin}
\begin{defin}[类型匹配系统的解与解集] \label{Def.MF}
一个类型匹配系统$(V,X)$的解$f$是一个$(\Uv \rightarrow \PiE)$函数，
满足
\[ \forall u_1\ u_2.\ (u_1,u_2) \in X \Rightarrow 
\Inst f\ u_1 = \Inst f\ u_2 \]
所有这样的解构成的集合叫解集。

函数 $\MF : \TMs \rightarrow \powerset(\Uv \rightarrow \PiE)$
将一个类型匹配系统映射到其解集
\[ \MF (V,X) = \{ f \mbar \forall u_1\ u_2.\ (u_1,u_2) \in X
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2 \} \]
\end{defin}

\begin{defin}[类型匹配系统的M等价] \label{Def.Meq}
二元等价关系 $\Meq$
\[ \forall A\ B.\ (A \Meq B) = (\MF A = \MF B) \]
\end{defin}
\begin{lemma} \label{L.Meq.refl}
\[ \forall X\ V\ v.\ (V,X) \Meq (V, X \cup \{(v,v)\}) \]
\begin{proof} 由定义 \ref{Def.Meq} 定义 \ref{Def.MF} 直接得到
\end{proof}
\end{lemma}

\begin{lemma} \label{L.MF.XUX}
\[ \MF (V,X_1 \cup X_2) = \MF(V,X_1) \cap \MF(V,X_2) \]
\begin{proof} 将$\MF$ 的定义展开，命题等价于
\begin{multline*}
(\forall u_1\ u_2.\ (u_1,u_2) \in (X_1 \cup X_2)
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2) = \\
(\forall u_1\ u_2.\ 
(u_1,u_2) \in X_1
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2)\ \land\\
(\forall u_1\ u_2.\ (u_1,u_2) \in X_2
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2)
\end{multline*}
这时显然的。
\end{proof}
\end{lemma}

\begin{defin}[有意义类型方程组] \label{Def.SF}
有意义（Senseful Form）类型方程组函数
$\SF : \powerset(\PiE \times \PiE) \rightarrow \powerset(\PiE \times \PiE)$
\[ \SF X = \{(x,y) \mbar (x,y) \in X \ \land\ x \neq y\} \]
即是削除了恒等式 $(x,x)$ 后的方程。
\end{defin}


\begin{algorithm}
\caption{计算有意义的类型方程组 $\SF X$} \label{alg:SF}
\begin{algorithmic}[1]
\Require 类型方程组 $X$
\Ensure 类型方程组的有意义形式 $\SF X$
\State $\{\} \rightarrow X'$
\For {$(x,y) \in X$}
\If {$x \neq y$} \State 将 $(x,y)$ 加入 $X'$ \EndIf
\EndFor
\State 输出 $X'$
\TimeComplexity $O(\abs{X})$
\end{algorithmic}
\end{algorithm}

\begin{defin}[类型匹配系统的并] \label{Def.M.U}
类型匹配系统 $(V,X)$ 与 $(V',X')$ 的并 $(V,X)\cup(V',X')$ 定义为
\[ (V,X)\cup(V',X') = (V \cup V',\ X \cup X') \]
\end{defin}

\begin{defin}[已解的类型匹配系统] \label{Def.Solved}
类型匹配系统在的{\it 已解}形式下的未知量（Unknown Variable）函数
$\UV : (\PiE \times \PiE) \rightarrow \powerset(\Uv)$
\[ \UV X = \{x \mbar (x,y) \in \SF X\} \]
一个类型匹配系统 $(V,X)$ 若满足 $\Solved (V,X)$ 则被叫做{\it 已解}的。
\[ \begin{split}
\Solved (V,X) = (\forall x\ &y.\ (x,y) \in \SF X \Rightarrow
  x \in V \ \land\ \BV y \cap \UV X = \emptyset)\ \land \\
  & (\forall x\ y_1\ y_2.\ (x,y_1) \in \SF X \ \land\ (x,y_2) \in \SF X
  \Rightarrow (y_1 = y_2))
\end{split} \]
\end{defin}

有一些显然的性质，
\begin{equation} \Solved(V,X) \vdash \UV X \subseteq V \end{equation}
\begin{equation} \Solved(V,X) \vdash \forall x\ y.\ (x,y) \in X
\Rightarrow x \in \UV X \label{UVX} \end{equation}
\begin{equation} \label{Solved.sub.refl}
\Solved(V,X) \vdash \Solved(V,X - {u,u}) \end{equation}

\begin{lemma} \label{Lem.SFXF}
\[ \Solved(V,X) \vdash \SF X \in (\UV X \rightarrow \PiE) \]
即在已解形式下，有意义的方程组 $\SF X$ 就是一个$V$到$\PiE$的函数。
\end{lemma}
\begin{proof}
由定义 \ref{Def.Func}，命题等价于
\[ \Solved(V,X) \vdash \forall x\ y_1\ y_2.\ (x,y_1) \in \SF X \ \land\ 
(x,y_2) \in \SF X \Rightarrow (y_1 = y_2) \ \land\ x \in \UV X \ \land\ 
y_1 \in \PiE \]
由定义 \ref{Def.Solved} 这是显然的。
\end{proof}
\begin{lemma}[引理\ref{Lem.SFXF}的推论] \label{Lem.SFXapplied}
结合引理\ref{Lem.SFXF}与公式 \ref{UVX}
\[ \Solved(V,X),\ (x,y) \in X \vdash \SF X\ x = y \]
\end{lemma}

\begin{defin}[部分函数的I扩展]
$\EI\ f$ 将一个部分函数 $f$ 扩展成完全函数
\[ \EI\ f\ x = \xif x \in \Dom f \xthen f\ x \xelse x \]
\end{defin}

\begin{lemma} \label{L.vEi}
\[ x \in V \vdash \mathrm{v}(\Inst_V\ (\EI \{(x,y)\})\ u) =
\mathrm{v}(u) - \{x\} \]
\begin{proof} 对 $u$ 进行类型高度的归纳法，只需要证明叶子类型的情形
命题就能得证。
\[ x \in V,\ u\in \Uv \vdash \mathrm{v}(\Inst_V\ (\EI \{(x,y)\})\ u) =
\mathrm{v}(u) - \{x\} \]
由 $\Inst_V$ 的定义 \ref{Def.Inst}
\[ x \in V,\ u\in \Uv \vdash \mathrm{v}(\EI \{(x,y)\}\ u) =
\mathrm{v}(u) - \{x\} \]
分类讨论 $u = x$ 的情况，结合$\mathrm{v}$的定义 \ref{Def.Th} 命题得证。
\end{proof}
\end{lemma}

\begin{algorithm}
\caption{二元组集的函数扩张 $\mathrm{AsFunc}$} \label{alg:AsFunc}
\begin{algorithmic}[1]
\Require 二元组集 $f \in \powerset(X \times Y)$ 满足
$\forall x\ y_1\ y_2.\ (x,y_1) \in f \ \land\ (x,y_2) \in f \Rightarrow
(y_1 = y_2)$
\Statex 以哈希表形式表达
\Ensure $\EI f \in (X \rightarrow Y)$
\Function{F\ }{$v$}
\If {$\exists y.\ (v,y) \in f$} \Comment {$v$ 是否作为键存在于哈希表 $f$ 中}
\State 返回 $y$ \Else \State 返回 $v$
\EndIf
\EndFunction
\State 输出 F
\TimeComplexity AsFunc 的时间复杂度 $O(1)$，输出 F 的时间复杂度 $O(1)$，因为使用了
    哈希表
\end{algorithmic}
\end{algorithm}

\begin{theo}[已解方程组的解]
\[ \Solved (V,X) \vdash \MF(V,X) = \{ \Inst_V g
\circ \EI (\SF X) \mbar g \} \]
\end{theo}
\begin{proof} 由定义 \ref{Def.MF} 命题等价于
\[ \begin{split}
\Solved&(V,X) \vdash (\forall u_1\ u_2.\ (u_1,u_2) \in X
\Rightarrow \Inst_V f\ u_1 = \Inst_V f\ u_2) = \\
&(\exists g.\ \forall x.\ x \in \Uv \Rightarrow 
(f(x) = \Inst_V g(\EI (\SF X)\ x)))
\end{split} \]
当 $X = \emptyset$ 时等式左边即是 $T$，右边也是 $T$ 因为
$\Dom (\SF X) = \emptyset$ 故而 $\EI(\SF X) = I$ 这样右式就等于
\[ \exists g.\ \forall x.\ x \in \Uv \Rightarrow
(f\ x = \Inst_V\ g\ x)\]
而这样的 $g$ 是始终存在的，令 $g = f$ 则有
\[ \forall x.\ x \in \Uv \Rightarrow (f\ x = \Inst_V\ f\ x)\]
而由 $\Inst_V$ 的定义，当 $x \in \Uv$ 时，$\Inst_V f\ x = f\ x$，
故而右式就是恒真式。

\hfill

\noindent 接下来证明 $X \neq \emptyset$ 的情况，先
证明 $\Rightarrow$，即命题
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall x\ y.\ &(x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)) \vdash\\
&\exists g.\ \forall u.\ u \in \Uv \Rightarrow
(f(u) = \Inst_V g(\EI (\SF X)\ u)) \end{split}\]
存在这样的 $g = f$，命题变为
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (&\forall x\ y.\ (x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)) \vdash\\
&\forall u.\ u \in \Uv \Rightarrow
(f\ u = \Inst_V f(\EI (\SF X)\ u))
\end{split} \]
由引理 \ref{Lem.SFXF}，$\Dom(\SF X) = \UV X$，再由$\EI$的定义，
当 $u \notin \UV X$ 时，$\EI(\SF X) u = u$，
而由 $\Inst_V$ 的定义，在$u \in \Uv$时$\Inst_V u = u$，
故而最后只要下述证明命题
\[ \begin{split}
X \neq \emptyset,\ 
Solved(V,X),\ &(\forall x\ y.\ (x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)) \vdash\\
&\forall u.\ u \in \UV\ X
\Rightarrow (f\ u = \Inst_V f\ (\SF X\ u)) \end{split} \]
再由公式 \ref{UVX} 且 $X \neq \emptyset$
\[X \neq \emptyset,\ 
\Solved(V,X),\ (x, y) \in \SF X,\ 
\Inst_V f\ x = \Inst_V f\ y \vdash f\ x = \Inst_V f\ (\SF X\ x)\]
引理 \ref{Lem.SFXapplied}
\[X \neq \emptyset,\ 
\Solved(V,X),\ (x, y) \in \SF X,\ 
\Inst_V f\ x = \Inst_V f\ y \vdash f\ x = \Inst_V f\ y\]
而 $\Solved(V,X)\ \land\ (x, y) \in \SF X$ 所以 $x \in \Uv$ 所以
$\Inst_V\ f\ x = x$ 于是命题得证。

\hfill

\noindent 接下来证明 $\Leftarrow$，即命题
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g(\EI (\SF X)\ u))) \vdash \\
&\forall x\ y.\ (x, y) \in \SF X \Rightarrow
(\Inst_V f\ x = \Inst_V f\ y)
\end{split}\]
等价于
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ (x, y) \in \SF X
\vdash \\
& \Inst_V f\ x = \Inst_V f\ y
\end{split}\]
$(x,y) \in \SF X$ 故而 $x \in \UV X$
故而 $x \in \Uv$ 这样 $\Inst_V f\ x = f\ x$ 且
$f\ x = \Inst_V g\ (\EI (\SF X)\ x)$

\noindent 且因为 $x \in \UV X$ 所以 $\EI (\SF X)\ x = \SF X\ x = y$
最后命题等价于
\[ \begin{split}
X \neq \emptyset,\ 
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ (x, y) \in \SF X
\vdash \\
& \Inst_V g\ y = \Inst_V f\ y
\end{split}\]
对 $y$ 进行类型高度的递归法，只要证明下式命题就能得证。
\[ \begin{split}
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ y \in \Uv,\ (x, y) \in \SF X
\vdash \\
& \Inst_V g\ y = \Inst_V f\ y
\end{split}\]
进而
\[ \begin{split}
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ y \in \Uv,\ (x, y) \in \SF X
\vdash \\ & g\ y = f\ y
\end{split}\]
由前提中的 $(\forall u.\ u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u)))$
\[ \begin{split}
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ y \in \Uv ,\ (x, y) \in \SF X
\vdash \\& g\ y = \Inst_V g\ (\EI (\SF X)\ y)
\end{split}\]
注意至今为止一直没用到的 $\Solved$ 的一个条件
\[ \Solved(V,X),\ (x,y) \in \SF X \vdash \BV y \cap \UV X = \emptyset \]
而 $\Dom (\SF X) = \emptyset$，这意味着  $\EI (\SF X)\ y = y$
于是命题变成
\[ \begin{split}
\Solved(V,X),\ (\forall u.\ &u \in \Uv \Rightarrow
(f(u) = \Inst_V g\ (\EI (\SF X)\ u))),\ y \in \Uv ,\ (x, y) \in \SF X
\vdash \\& g\ y = \Inst_V g\ y
\end{split}\]
因为 $y \in \Uv$ 所以 $\Inst_V g\ y = g\ y$ 命题得证。
\end{proof}

\begin{defin}[类型匹配系统的实例集] \label{Def.MI}
类型匹配系统 $(V,X) \in \TMs$ 在 $u \in \PiE$ 上的实例集 
$\MI\ (V,X)\ u \in \powerset(\PiE)$
\[\MI\ (V,X)\ u = \{ \Inst_V f\ u \mbar f \in \MF(V,X) \}\]
\end{defin}
\begin{lemma}[类型匹配系统的实例集的M等价] \label{Lem.MI.Meq}
\[ \forall M_1\ M_2\ u.\ u \in \PiE\ \land\ (M_1 \Meq M_2) 
\Rightarrow (\MI M_1\ u \Meq \MI M_2\ u) \]
\end{lemma}
\begin{proof} 由$\MI$的定义 \ref{Def.MI}，M等价的定义 \ref{Def.Meq}
直接得到
\end{proof}

\begin{lemma} \label{Lem.RecIv}
\[ \Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X)) = \Inst_V g \circ \Inst_V (\EI\ (\SF X))\]
\end{lemma}
\begin{proof} 等价于
\[ \Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ u = \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ u)\]
对 $u$ 进行高度的归纳法，当 $\h u = 1$ 时，$u = \underline{(\ c\ )}$，
$c \in U$ 由 $\Inst$ 的定义 \ref{Def.Inst} 命题成立。

\noindent 当 $\h u = \Suc n$ 时，$u = \underline{(\ c\ v_1\ \cdots\ v_o\ )}
,\ \h v_1 \leq n,\ \cdots,\ \h v_o \leq n$，且有
\[ \Solved(V,X),\ \h u \leq n \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ u = \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ u)
\tag{归纳假设} \]
由 $\Inst$ 的定义 \ref{Def.Inst} 命题等价于
\begin{align*}
\Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ v_1\ &= \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ v_1)\\
\cdots&\\
\Solved(V,X) \vdash \Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ v_o\ &= \Inst_V g\ (\Inst_V (\EI\ (\SF X))\ v_o)
\end{align*}
逐个应用归纳假设，命题得证。
\end{proof}

\begin{lemma} \label{L.QIMI}
\[ \Solved(V,X),\ \QV q = V,\ \QB q = 
\Inst_V\ (\EI (\SF X))\ u \vdash
\QI q = \MI\ (V,X)\ u \]
\end{lemma}
\begin{proof}
等价于
\[ \begin{split}
\Solved(V,&X),\ \QV q = V,\ \QB q = 
\Inst_V\ (\EI (\SF X))\ u\vdash\\
&\{\Inst_{\ \QV q} f\ \QB(q)\mbar f\} = \{\Inst_V (\Inst_V g \circ
\EI\ (\SF X))\ u \mbar g\} \end{split} \]
由引理 \ref{Lem.RecIv}
\[ \begin{split}
\Solved(V,&X),\ \QV q = V,\ \QB q =  
\Inst_V\ (\EI (\SF X))\ u\vdash\\
&\{\Inst_{\ \QV q} f\ \QB(q)\mbar f\} = \{\Inst_V g\ (
\Inst_V (\EI\ (\SF X))\ u) \mbar g\} \end{split} \]
这是显然成立的。
\end{proof}

引理 \ref{L.QIMI} 意味着很多，首先对于任意的类型匹配系统 $M \in \TMs$
如果其有可解形式 $M'$ 即 $\Solved M'\ \land\ M \Meq M'$，
那么必定存在存在一个 $q \in \PiAE$ 使得 $\QI q = \MI M$，
其次，算法 \ref{alg:QIMI} QIMI 可以由 $\Solved M'$ 求解 $q$，
其正确性直接由引理 \ref{L.QIMI} 得到。

\begin{theo} \label{T.QIMI.S}
\[ \forall M\ u.\ 
\Solved M \Rightarrow \exists q.\ \QI q = \MI M\ u \]
\end{theo}
\begin{proof} 由引理 \ref{L.QIMI} 直接得到。
\end{proof}


\begin{algorithm}
\caption{已解类型匹配系统的实例化 MI} \label{alg:MI}
\begin{algorithmic}[1]
\Require 已解的类型匹配系统$(V,X)$ 满足 $\Solved(V,X)$
\Require 类型 $u \in \PiE$
\Ensure $\Inst_V\ (\EI(\SF X))\ u$
\State $\mathrm{AsFunc}(\SF X) \rightarrow f$
\Comment {调用算法 \ref{alg:SF} 和算法 \ref{alg:AsFunc}，
由引理 \ref{Lem.SFXF} $\SF X$ 满足
算法 \ref{alg:AsFunc} 的条件 }
\State 输出 $\Inst(V,f,u)$  \Comment {调用算法 \ref{alg:Iv}}
    \TimeComplexity $O(\abs{X} + \TS u)$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{已解类型匹配系统的全称量化类型 QIMI} \label{alg:QIMI}
\begin{algorithmic}[1]
\Require 已解的类型匹配系统$(V,X)$ 满足 $\Solved(V,X)$
\Require 类型 $u \in \PiE$
\Ensure $q \in \PiAE$ 满足 $\QI q = \MI (V,X)\ u$
\State $\MI((V,X),u) \rightarrow b$  \Comment {调用算法 \ref{alg:MI}}
\State 输出 $\mathrm{MakeQT}(V,b)$
\Comment {调用算法 \ref{alg:MakeQT}}
    \TimeComplexity $O(\abs{X} + \abs{V} + \TS u)$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{无冲突化量化类型对 $\NC$} \label{alg:NC}
\begin{algorithmic}[1]
\Require $q_1,\ q_2 \in \PiAE,\quad q_1 = \underline{\forall a_1\ \cdots\ 
    \forall a_n\ u},\quad q_2 = \underline{\forall b_1\ \cdots\ 
    \forall b_m\ w}$
\Ensure $q_1', q_2' \in \PiAE$ 满足 $q_1 \sim_\alpha q_1'\ \land\ q_2 \sim_\alpha q_2'
    \ \land\ q_1' \NC q_2'$
\State $\{\} \rightarrow f_1\quad\quad \{\} \rightarrow f_2$
    \Comment {构造 $f_1,\ f_2$ 为 $\Uv$ 到 $\Uv$ 的哈希表}
\For {$i=1,\cdots,n$} \State $\{(a_i,v_i)\} \cup f_1 \rightarrow f_1$ 
\Comment {取 $v_i \in \Uv\quad\quad i=1,\cdots,n+m$}
\EndFor
\For {$i=1,\cdots,m$} \State $\{(b_i,v_{n+i})\} \cup f_2 \rightarrow f_2$ 
\EndFor
\State $\Inst(\Dom f_1,\ f_1,\ u) \rightarrow q_1'\quad\quad \Inst(\Dom
    f_2,\ f_2,\ w) \rightarrow q_2'$ \Comment{算法 \ref{alg:Iv} $\Inst$}
\For {$i=1,\cdots,n$} \State $\underline{\forall}\concat v_i \concat q_1'
    \rightarrow q_1'$ \EndFor
\For {$i=1,\cdots,m$} \State $\underline{\forall}\concat v_{n+i} \concat q_2'
\rightarrow q_2'$ \EndFor
    \State 输出 $(q_1',q_2')$
    \TimeComplexity $O(\abs{\QV q_1}) + \abs{\QV q_2} + \TS(\QB q_1) + \TS(\QB q_2)$
\end{algorithmic}
\end{algorithm}

\begin{defin}[无冲突全称量化类型]
定义$\PiAE \times \PiAE$上的二元关系 $\NC$ 表示两个全称量化类型的全称量化变量不相互冲突。
\[ q_1 \NC q_2 = (\QV q_1 \cap \Qv q_2 = \emptyset) \ \land\ 
(\QV q_2 \cap \Qv q_1 = \emptyset) \]
显然有
\[ q_1 \NC q_2 \vdash \QV q_1 \cap \QV q_2 = \emptyset \]
\end{defin}

\begin{theo}[$\QI$ 等价的无冲量化类型对] \label{T.NCize}
    \[ \forall q_1,\ q_2 \in \PiAE\ \ \exists q_1',\ q_2' \in \PiAE\ \ .\ 
    (\QI q_1 = \QI q_1')\ \land\ (\QI q_2 = \QI q_2')\ \land\ (q_1' \NC q_2')\]
\begin{proof} 算法 \ref{alg:NC} NC 就是寻找这样的 $q_1',\ q_2'$ 且其显然有限停机。
\end{proof}
\end{theo}




\begin{theo}[类型匹配系统与实例化类型集交集的关系] \label{T.TMS.I.I}
\[ q_1 \NC q_2 \vdash \QI q_1 \cap \QI q_2 =\ 
\MI\ (\QV q_1 \cup \QV a_2,\ \{\QB q_1 = \QB q_2\})\ \QB(q_1)\]
\end{theo}
\begin{proof} 简洁起见，令
\begin{align*}
&u_1 = \QB q_1&&u_2 = \QB q_2&\\
&V_1 = \QV q_1&&V_2 = \QV q_2&
\end{align*}
将QI的定义与MI的定义展开，原命题等价于
\[ \begin{split} q_1\ &\NC q_2 \vdash \\
&\{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1 = \Inst_{V_2} g\ u_2 \}
= \{\Inst_{V_1 \cup V_2} f\ u_1 \mbar \Inst_{V_1 \cup V_2} f\ u_1
= \Inst_{V_1 \cup V_2} f\ u_2 \} \end{split} \]
由 $q_1 \NC q_2$ 可得
$(V_1 \cup V_2) \cap V_1 = V_1$，
$(V_1 \cup V_2) \cap V_2 = V_2$，
用引理 \ref{Lem.Iv.V}，得到
\begin{align*}
&\Inst_{V_1 \cup V_2} f\ u_1 = \Inst_{V_1} f\ u_1&
&\Inst_{V_1 \cup V_2} f\ u_2 = \Inst_{V_2} f\ u_2&
\end{align*}
带入命题，命题变为
\[ q_1\ \NC q_2 \vdash
\{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1 = \Inst_{V_2} g\ u_2 \}
= \{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1= \Inst_{V_1} f\ u_2 \}\]
显然有
\[ \{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1 = \Inst_{V_2} g\ u_2 \}
\supseteq
\{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1= \Inst_{V_1} f\ u_2 \}\]
只要证明
\[ q_1\ \NC q_2 \vdash
 \{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1 = \Inst_{V_2} g\ u_2 \}
\subseteq
\{\Inst_{V_1} f\ u_1 \mbar \Inst_{V_1} f\ u_1= \Inst_{V_1} f\ u_2 \}\]
即证明命题
\[ q_1\ \NC q_2 ,\ 
\Inst_{V_1} f\ u_1 = \Inst_{V_2} g\ u_2 \vdash \exists h.\ 
\Inst_{V_1} h\ u_1 = \Inst_{V_2} h\ u_2 \]
$h = (\lambda v.\ \xif v \in V_1 \xthen f\ v \xelse g\ v)$ 
是满足上述条件的实例，因为 $V_1 \cap V_2 = \emptyset$

\noindent 这样命题得证。
\end{proof}

\begin{defin}[无解的类型匹配系统] \label{Def.NS}
谓词 $\NoSolution$ 表示一个类型匹配系统是无解的。
\[ \NoSolution M = (\MF M = \emptyset) \]
相反的 $\Solvable$ 表示有解
\[ \Solvable M = (\MF M \neq \emptyset) \]
$\MNS$ 是某个无解的类型匹配系统
\[ \NoSolution \MNS \]
$\MNS$ 具体的表达是无关紧要的，例如下面的类型匹配系统即可
\[ (\emptyset,\ \{u_1 = u_2\})\quad\quad u_1 \neq u_2 \]
\end{defin}

\begin{theo} \label{T.TMS.NS}
    \[ \NoSolution M \vdash \MI M\ u = \emptyset \]
\begin{proof} 由 $\MI$ 的定义 \ref{Def.MI} 与 $\NoSolution$ 的定义 \ref{Def.NS}
    直接得到。
\end{proof}
\end{theo}

\begin{lemma} \label{L.Rec.NoSolution}
    \[ (x,y) \in X,\ x \in \BV y,\ x \neq y \vdash \NoSolution(V,X) \]
\begin{proof}
    弱于以下命题
    \[ x \in \BV y,\ x \neq y \vdash \nexists f.\ \Inst_V f\ x = \Inst_V f\ y \]
证明等价的逆否命题
\[ x \in \BV y,\ \Inst_V f\ x = \Inst_V f\ y \vdash x = y\]
因为 $x \in \Uv$ 命题等价于
\[ x \in \BV y,\ x = \Inst_V f\ y \vdash x = y\]
$\h x = 1$ 于是 $\h(\Inst_V f\ y) = 1$，由引理 \ref{L.Iv.h}，
$\h y \leq \h(\Inst_V f\ y)$ 而 $\forall u.\ \h u \geq 1$
于是 $\h y = 1$ 于是 $y \in U$ 于是 $\Inst_V f\ y = y$ 于是命题得证。
\end{proof}
\end{lemma}

\begin{defin}[类型方程组中全部的类型变量]
对类型方程组 $X \in \powerset(\PiE \times \PiE)$
\[ \MV\ X = \bigcup_{(x,y) \in X} \mathrm{v}(x) \cup \mathrm{v}(y) \]
表示 $X$ 中每一个类型方程的所有类型变量的合并。
\end{defin}

\begin{defin}[类型匹配系统的实例化] \label{Def.IM}
$\IM : (\Uv \rightarrow \PiE) \rightarrow \TMs \rightarrow \TMs$ 
将一个类型匹配系统的所有方程的等式两边都实例化
\[ \IM f\ (V,X) = \{(\Inst_V f\ x,\ \Inst_V f\ y) \mbar (x,y) \in X\}\]
\end{defin}

\begin{algorithm}
\caption{类型匹配系统的实例化 $\IM$} \label{alg:IM}
\begin{algorithmic}[1]
\Require 类型匹配系统 $(V,X) \in \TMs$，
实例化函数 $f : \Uv \rightarrow \PiE$ 表示变量到值的对应
\Ensure $\IM\ f\ (V,X) \in \TMs$
\State $\{\} \rightarrow X'$
\For {$(x,y) \in X$}
\State $\Inst(V,f,x) \rightarrow x'\quad\quad
    \Inst(V,f,y) \rightarrow y' \quad\quad
    \{(x',y')\} \cup X' \rightarrow X'$
\Comment {算法 \ref{alg:Iv} $\Inst$}
\EndFor
\State 输出 $X'$
    \TimeComplexity $O(t\EQW(X))$，$t$ 是 $f$ 的时间复杂度
\end{algorithmic}
\end{algorithm}


\begin{lemma} \label{L.IIuv}
\[ (u,v) \in X,\ u \in V,\ \Inst_V g\ u = \Inst_V g\ v,\ x \in \PiE
\vdash \Inst_V g\ (\Inst_V\ \{(u,v)\}\ x) = \Inst_V\ g\ x \]
\begin{proof} 对 $x$ 进行类型高度的归纳法，只需要证明叶子类型时的情况
\[ (u,v) \in X,\ u \in V,\ \Inst_V g\ u = \Inst_V g\ v,\ x \in \Uv
\vdash \Inst_V g\ (\Inst_V\ \{(u,v)\}\ x) = \Inst_V\ g\ x \]
由 $\Inst_V$ 的定义，此时 $\Inst_V\ \{(u,v)\}\ x = \{(u,v)\}\ x$

\noindent 当 $x \neq v$，$\Inst_V\ \{(u,v)\}\ x = x$，命题显然成立

\noindent 当 $x = v$，$\Inst_V\ \{(u,v)\}\ x = v$
\[ (u,v) \in X,\ u \in V,\ \Inst_V g\ u = \Inst_V g\ v,\ x \in \Uv
\vdash \Inst_V g\ v = \Inst_V\ g\ x \]
于前提 $\Inst_V g\ u = \Inst_V g\ v$ 命题得证。
\end{proof}
\end{lemma}

\begin{lemma} \label{L.EM.IMEiX}
\[ (u,v) \in X,\ u \in V \vdash (V,X) 
\Meq (V,(\IM\ \EI\{(u,v)\}\ \ (X - \{(u,v)\})) \cap \{(u,v)\})\]
\begin{proof} 命题等价于
\[ \begin{split} (u,v) \in X,\ &u \in V\ \vdash
\{g \mbar (x,y) \in X\ \land\  \Inst_V g\ x = \Inst_V g\ y \} = \\
\{g \mbar &(x,y) \in (X-\{(u,v)\})\ \land\  \Inst_V g\ (\Inst_V\ \{(u,v)\}\ x) = 
\Inst_V g\ (\Inst_V\ \{(u,v)\}\ y)\ \land\\
&\quad\quad\Inst_V g\ u = \Inst_V g\ v \} \end{split} \]
分步证明等式两端
\begin{align}
\begin{split} (u,v) \in X,\ u \in V,&\ 
\forall x\ y.\ (x,y) \in X\Rightarrow (\Inst_V g\ x = \Inst_V g\ y)
\vdash \\ \forall x\ y.\ (x,y) \in\ (X-\{(u,v)\})&\Rightarrow
(\Inst_V g\ (\Inst_V\ \{(u,v)\}\ x) = 
\Inst_V g\ (\Inst_V\ \{(u,v)\}\ y))\\
&\land\ (\Inst_V g\ u = \Inst_V g\ v)
\end{split} \tag{1}\\ \notag \\
\begin{split} (u,v) \in X,\ u \in V,&\ \Inst_V g\ u = \Inst_V g\ v,\ \\
\forall x\ y.\ 
(x,y) \in (X-\{(u,v)\})&\Rightarrow
(\Inst_V g\ (\Inst_V\{(u,v)\}\ x) = 
\Inst_V g\ (\Inst_V\{(u,v)\}\ y)) \vdash \\
\forall x\ y.\ (x,&y) \in X\Rightarrow  \Inst_V g\ x = \Inst_V g\ y
\end{split} \tag{2}
\end{align}
对于 (1) 有
\[ \begin{split} (u,v) \in X,\ u \in V,\ 
\forall x\ y.\ (x,y)\ &\in X\Rightarrow (\Inst_V g\ x = \Inst_V g\ y)
\vdash \\
\Inst_V g\ u = \Inst_V g\ v
\end{split} \]
对于 (2) ，$\Inst_V g\ u = \Inst_V g\ v$ 就在前提列表中

\noindent 在这两种情况都可以应用引理 \ref{L.IIuv}，这样命题就瞬间被简化成非常简单的形式
\begin{align}
\begin{split} (u,v) \in X,\ u \in V,&\ 
\forall x\ y.\ (x,y) \in X\Rightarrow(\Inst_V g\ x = \Inst_V g\ y)
\vdash \\ (\forall x\ y.\ 
(x,y) \in &(X-\{(u,v)\})\Rightarrow \Inst_V g\ x = \Inst_V g\ y)\ 
\land\ (\Inst_V g\ u = \Inst_V g\ v)
\end{split} \tag{1'}\\
\begin{split} (u,v) \in X,\ u \in V,&\ \Inst_V g\ u = \Inst_V g\ v,\\
\forall x\ y.\ &(x,y)
\in (X-\{(u,v)\})\Rightarrow \Inst_V g\ x = \Inst_V g\ y \vdash \\
\forall x\ y.\ (x,y) \in &X\Rightarrow (\Inst_V g\ x = \Inst_V g\ y)
\end{split} \tag{2'}
\end{align}
这些显然是成立的。
\end{proof}
\end{lemma}

\begin{lemma} \label{L.MVIM}
\[ (u,v) \in X,\ u \in V \vdash \MV(\IM\ \EI\{(u,v)\}\ (X-\{(u,v)\}))
= \MV(X) - \{u\} \]
\begin{proof} 由引理 \ref{L.vEi} 以及 $\IM$ 的定义 \ref{Def.IM} 直接得到。
\end{proof}
\end{lemma}

\begin{defin} \label{Def.SBP}
$\SBP\ (V_x,X_x)\ (V_o,X_o)$ 描述类型匹配系统 
$(V_x,X_x),\ (V_o,X_o) \in \TMs$ 具有如下性质
\[ \SBP\ (V_x,X_x)\ (V_o,X_o) = \Solved(V_o,X_o) \ \land\ 
(V_o = \UV X_o)\ \land\ (\MV X_x \cap V_o = \emptyset) \]
\end{defin}
\begin{lemma} \label{L.SBP.1}
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,x) \in X_x \vdash
\SBP\ (V_x,X_x - \{(x,x)\})\ (V_o,X_o)\ \land\\
&((V_x,X_x - \{(x,x)\})\cup(V_o,X_o) \Meq (V_x,X_x)\cup(V_o,X_o)) \end{split}\]
\begin{proof}
$((V_x,X_x - \{(x,x)\})\cup(V_o,X_o) \Meq (V_x,X_x)\cup(V_o,X_o))$
是显然的，由引理 \ref{L.Meq.refl} 直接得到。
现证明
\[ \SBP\ (V_x,X_x)\ (V_o,X_o),\ (x,x) \in X_x \vdash
\SBP\ (V_x,X_x - \{(x,x)\})\ (V_o,X_o)\]
由$\SBP$ 的定义，命题变为
\[ \SBP\ (V_x,X_x)\ (V_o,X_o),\ (x,x) \in X_x \vdash 
(\MV (X_x - \{(x,x)\}) \cap V_o = \emptyset) \]
而这是显然的。
\end{proof}
\end{lemma}

\begin{lemma} \label{L.SBP.2}
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x = \underline{(\ c\ v_1\ \cdots\ v_n \ )},\ 
y = \underline{(\ c\ w_1\ \cdots\ w_n \ )} \vdash\\
&\SBP\ (V_x,X_x')\ (V_o,X_o)\ \land\ 
((V_x,X_x')\cup(V_o,X_o) \Meq (V_x,X_x)\cup(V_o,X_o)) \end{split}\]
\[ \text{其中\quad} X_x' = X_x - \{(x,y)\} \cup \bigcup_{i=1\cdots n} \{(v_i,w_i)\} \]
\begin{proof}
首先证明 $((V_x,X_x')\cup(V_o,X_o) \Meq (V_x,X_x)\cup(V_o,X_o))$ 部分，

\noindent 这是成立的因为
$x = \underline{(\ c\ v_1\ \cdots
\ v_n\ )},\ y = \underline{(\ c\ w_1\ \cdots\ w_n\ )}$ 下
\[ \{f \mbar \Inst_V f\ x = \Inst_V f\ y \} = 
\{ f \mbar \bigwedge_{i=1\cdots n} \Inst_V f\ v_i = \Inst_V f\ w_i \} \]
然后证明 $\SBP\ (V_x,X_x')\ (V_o,X_o)$ ，只要证明如下命题即可
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x = \underline{(\ c\ v_1\ \cdots\ v_n \ )},\ 
y = \underline{(\ c\ w_1\ \cdots\ w_n \ )} \vdash\\
&\MV(X_x - \{(x,y)\} \cup \bigcup_{i=1\cdots n} \{(v_i,w_i)\}) = 
\MV(X_x)
\end{split} \]
这是成立的因为
\[ x = \underline{(\ c\ v_1\ \cdots\ v_n \ )},\ 
y = \underline{(\ c\ w_1\ \cdots\ w_n \ )} \vdash
\mathrm{v}(x)\cup\mathrm{v}(y) = \bigcup_{i=1\cdots n} \mathrm{v}(v_i)
\cup \mathrm{v}(w_i) \]
\end{proof}
\end{lemma}

\begin{lemma} \label{L.SBP.subst}
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x \in V_x,\ x \notin \BV y \vdash\\
&\SBP\ (V_x',X_x')\ (V_o',X_o')\ \land\ 
((V_x',X_x')\cup(V_o',X_o') \Meq (V_x,X_x)\cup(V_o,X_o)) \end{split}\]
其中
\begin{align*}
&X_x' = \IM\ (\EI \{(x,y)\})\ (X_x - \{(x,y)\})&
&V_x' = V_x - \{x\}&\\
&X_o' = X_o \cup \{(x,y)\}&
&V_o' = V_o \cup \{x\}&
\end{align*}
\begin{proof}
令$V = V_x \cup V_o$
\[ V_x' \cup V_o' = (V_x - \{x\}) \cup (V_o \cup \{x\}) = V \]
首先证明 $(V_x',X_x')\cup(V_o',X_o') \Meq (V_x,X_x)\cup(V_o,X_o)$ 部分，即
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x \in V_x,\ x \notin \BV y \vdash\\
&(\MF(V,X_x' \cup X_o') = \MF(V,X_x \cup X_o)) \end{split}\]
\[ X_x' \cup X_o' = \IM\ (\EI\{(x,y)\})\ (X_x - \{(x,y)\})\cup
\{(x,y)\}\cup X_o\]
由引理 \ref{L.MF.XUX} 命题等价于
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x \in V_x,\ x \notin \BV y \vdash\\
(\MF(V,\IM\ (\EI\{(x,y)\})\ (X_x - &\{(x,y)\})\cup
\{(x,y)\}) \cap \MF(V,X_o) = \MF(V,X_x) \cap \MF(V,X_o))
\end{split}\]
弱于
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x \in V_x,\ x \notin \BV y \vdash\\
&(\MF(V,\IM\ (\EI\{(x,y)\})\ (X_x - \{(x,y)\})\cup
\{(x,y)\}) = \MF(V,X_x)
\end{split}\]
而这就是引理 \ref{L.EM.IMEiX} 所证明的。

\hfill

\noindent 接下来证明 $\SBP\ (V_x',X_x')\ (V_o',X_o')$ 部分，命题
\[ \begin{split} \SBP\ &(V_x,X_x)\ (V_o,X_o),\ (x,y) \in X_x,\ 
x \in V_x,\ x \notin \BV y \vdash\\
&\SBP\ (V_x',X_x')\ (V_o',X_o')
\end{split}\]
将$\SBP$ 的定义 \ref{Def.SBP} 展开
\[ \begin{split} 
\Solved&(V_o,X_o)\ \land\ (V_x\cap V_o = \emptyset)\ \land\ 
(\MV X_x \cap V_o = \emptyset),\ (x,y) \in X_x,\ 
x \in V_x,\ x \notin \BV y \vdash\\
&\Solved(V_o',X_o')\ \land\ (V_o' = \UV X_o')\ \land\ 
(\MV X_x' \cap V_o' = \emptyset)
\end{split}\]
$(V_o' = \UV X_o')$ 是显然的。

\noindent $\MV X_x' \cap V_o' = \emptyset$ 由引理 \ref{L.MVIM} 对
$\MV(X_x') = \MV(X_x) - \{x\}$ 的证明得到

\noindent 现证明 $\Solved(V_o',X_o')$，现将 $\Solved$ 的定义 \ref{Def.Solved}
展开
\[ \begin{split}
\Solved (V_o',X_o') = (\forall x\ &y.\ (x,y) \in \SF X_o' \Rightarrow
  x \in V_o' \ \land\ \BV y \cap \UV X_o' = \emptyset)\ \land \\
  & (\forall x\ y_1\ y_2.\ (x,y_1) \in \SF X_o' \ \land\ (x,y_2) \in \SF X_o'
  \Rightarrow (y_1 = y_2))
\end{split} \]
\[ \begin{split}
\Solved (V_o,X_o) = (\forall x\ &y.\ (x,y) \in \SF X_o \Rightarrow
  x \in V_o \ \land\ \BV y \cap \UV X_o = \emptyset)\ \land \\
  & (\forall x\ y_1\ y_2.\ (x,y_1) \in \SF X_o \ \land\ (x,y_2) \in \SF X_o
  \Rightarrow (y_1 = y_2))
\end{split} \]
\begin{align*}
&V_o' = V_o\cup \{x\}&&X_o' = X_o\cup\{(x,y)\}& \end{align*}

因为 $\BV y \subseteq \MV X_x$ 而由命题假设有 $\MV X_x \cap V_o = 
\emptyset$ 于是 $\BV y \cap V_o = \emptyset$
另外 $x \notin \BV y$ 于是
$\BV y \cap (V_o \cup \{x\}) = \emptyset$
这样 $\Solved(V_o',X_o')$ 中的第一部分
\[\forall x\ y.\ (x,y) \in \SF X_o' \Rightarrow
  x \in V_o' \ \land\ \BV y \cap \UV X_o' = \emptyset\]
得证。

又因为 $V_o = \UV X_o$ 于是 $\MV X_x \cap \UV X_o = \emptyset$
而 $x \in \MV X_x$ 于是
\[ \nexists y.\ (x,y) \in X_x \]
这样 $\Solved(V_o',X_o')$ 中的第二部分
\[ (\forall x\ y_1\ y_2.\ (x,y_1) \in \SF X_o \ \land\ (x,y_2)
\in \SF X_o \Rightarrow (y_1 = y_2)) \]
得证。

于是所有子命题得证，引理 \ref{L.SBP.subst} 得证。
\end{proof}
\end{lemma}

\begin{algorithm}
\caption{ $\mathrm{SolveM_r}$ } \label{alg:SolveMr}
\begin{algorithmic}[1]
\Require 任意的类型匹配系统 $(V_x,X_x)$，
已解的类型匹配系统 $\Solved(V_o,X_o)$
\Statex 满足 $X_x \neq \emptyset \ \land\ \SBP\ (V_x,X_x)\ (V_o,X_o)$
\Ensure 类型匹配系统 $(V_x',X_x')$，已解的类型匹配系统 $\Solved (V_o',X_o')$
\Statex 满足 $\SBP\ (V_x,X_x)\ (V_o,X_o)
\ \land\ ((V_x,X_x) \cup (V_o,X_o) \Meq (V_x',X_x') \cup 
(V_o',X_o')) $
\State 从 $X_x$ 中随意取出元素 $(x,y) \in X_x$，
$x = \underline{(\ c\ v_1\ \cdots\ v_n \ )},\ 
y = \underline{(\ d\ w_1\ \cdots\ w_m \ )}$
\State $X_x - (x,y) \rightarrow X_x$
\Comment {接下来将削除方程组中的等式 $(x,y)$ 而保持方程组的解不变}
\If {$x = y$} \label{l:mrif1}
\State 输出 $((V_x,X_x),(V_o,X_o))$ \label{l:mro1}
\Comment{恒等式的情况可以直接削除} \Else
\If {$n \neq 0 \ \land\ m \neq 0$} \label{l:mrif2}
\Comment {若等式两边均不是类型变量或单个类型}
\If {$c = d$}
\Comment {$(c = d) \Rightarrow (n = m)$}
\For {$i = 1\cdots n$}
\Comment {等式$(x,y)$就可以分解为$n$个子等式 $(v_i,w_i)$}
\State $\{(v_i,w_i)\} \cup X_x \rightarrow X_x$ \label{l:mrot1}
\Comment{将这些等式分别加入方程组}
\EndFor
\State 输出 $((V_x,X_x),(V_o,X_o))$ \label{l:mro2}
\Comment{就完成了$(x,y)$ 的削除}
\Else \State 输出 $(\MNS,\MNS)$ \Comment{$c \neq d$ 时，方程组一定无解}
\label{l:mro3} \EndIf
\Else \Comment{等式两边某一方是类型变量或单个类型}
\If {$c \in \Uv\ \lor\ d \in \Uv$} 
\Comment{若等式两边某一方是类型变量}
\State 令 $c,\ d$ 中属于 $\Uv$ 的为 $u$，另一方为 $v$
\State 若 $u \in \BV v$ 则直接输出 $(\MNS,\MNS)$ \label{l:mro6}
\State $\{(u,v)\} \cup X_o \rightarrow X_o\quad,\quad
\{u\} \cup V_o \rightarrow V_o\quad,\quad V_x - \{u\} \rightarrow V_x$
\State $\IM(X_x,\mathrm{AsFunc}(\{(u,v)\})) \rightarrow X_x$
\label{l:mrot2} \Comment {算法 \ref{alg:IM} $\IM$}
\State 输出 $((V_x,X_x'),(V_o,X_o))$ \label{l:mro4}
\Else \Comment{若等式两边都是单个类型而不是类型变量}
\State 输出 $(\MNS,\MNS)$ \Comment{因为$x \neq y$ 这时也是不可解的}
\label{l:mro5} \EndIf
 \EndIf \EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{求解类型匹配系统 SolveM } \label{alg:SolveM}
\begin{algorithmic}[1]
\Require 任意的类型匹配系统 $(V,X)$
\Ensure $M' \in \TMs$ 满足 $M'$ 是已解的即 $\Solved M'$ 或者等于 $\MNS$ 
，且 $M \Meq M'$
\State $\{\} \rightarrow V' \quad,\quad \{\} \rightarrow X'$
\While {$(V,X) \neq \MNS \ \land\ X \neq \emptyset$}
\State $\mathrm{SolveM_r}((V,X),(V',X')) \rightarrow ((V,X),(V',X'))$
\Comment {$\mathrm{SolveM_r}$ 是算法 \ref{alg:SolveMr}}
\EndWhile
\State 输出 $(V',X')$
\TimeComplexity $O((\abs{V} + 1)(\EQW(X) + 1))$
\end{algorithmic}
\end{algorithm}


算法 SolveM 用于求解任意给定的类型匹配系统，主要是对子算法 \SolveMr
的迭代。接下来将分析 \SolveMr 的性质以证明 SolveM 的正确性。

\begin{lemma}[\SolveMr 的正确性] \label{L.SMr.Correct}
\begin{multline*}
\SBP\ (V_x,X_x)\ (V_o,X_o),\ X_x \neq \emptyset,\\
(\mathrm{SolveM_r}((V_x,X_x),(V_o,X_o)) = ((V_x',X_x'),(V_o',X_o')))
\vdash\\ \SBP\ (V_x',X_x')\ (V_o',X_o')\ \land\ 
((V_x,X_x) \cup (V_o,X_o) \Meq (V_x',X_x') \cup (V_o',X_o'))
\end{multline*}
\begin{proof} 
行 \ref{l:mro1} 的输出的正确性是引理 \ref{L.SBP.1}。
行 \ref{l:mro2} 的输出的正确性是引理 \ref{L.SBP.2}。
行 \ref{l:mro3} 的情况下，$M_x \cup M_o$ 是无解的因为
$(x,y) \in X_x, x = \underline{(\ c\ v_1\ \cdots
\ v_n\ )},\ y = \underline{(\ d\ w_1\ \cdots\ w_p\ )}$ 时
\[ c \neq d \Rightarrow \nexists f.\ \Inst_V f\ x = \Inst_V f\ y \]
行 \ref{l:mro5} 的无解情况也是一样的。
行 \ref{l:mro6} 的无解情况由引理 \ref{L.Rec.NoSolution} 证明。
行 \ref{l:mro4} 的输出的正确性则是引理 \ref{L.SBP.subst}。

\noindent 所有输出的正确性就被证明。
\end{proof}
\end{lemma}

接下来证明 $\mathrm{SolveM}$ 的停机性。

\begin{defin}[$\mathbb{N} \times \mathbb{N}$ 上的良序 $<$]
$\mathbb{N} \times \mathbb{N}$ 上的良序关系 $<$
    \[ (n_1,w_1) < (n_2,w_2) \Leftrightarrow (n_1 < n_2)\ \lor\ 
    (n_1 = n_2\ \land\ w_1 < w_2)\]
\end{defin}

\begin{lemma}[\SolveMr 重量递减] \label{L.SMr.W}
\[ \begin{split}
\SBP\ (V_x,X_x)\ (V_o,X_o),\ &X_x \neq \emptyset,\ \FINITE\ X_x\\
(\mathrm{SolveM_r}((V_x,X_x),(V_o,&X_o)) = ((V_x',X_x'),(V_o',X_o')))
    \vdash\\ (\EQW X_x' < \EQW\ &X_x)\ \lor\ ((V_x',X_x') = \MNS)
\end{split} \]
\begin{proof}
行 \ref{l:mro1}，\ref{l:mro3}，\ref{l:mro5}，\ref{l:mro6} 是显然的，
行 \ref{l:mro2} 用简单的类型高度的归纳法即可证明，
行 \ref{l:mro4} 因为 $\abs{\UV X_x'} < \abs{\UV X_x}$ 所以也是显然的。
    如此所有的输出语句上的引理 \ref{L.SMr.W} 就被证明。
\end{proof}
\end{lemma}

\begin{theo}[算法 SolveM 的正确性与停机性] \label{T.SM}
    \[\text{当输入的类型方程组有限时，算法 SolveM 是正确且可停机的}\]
\begin{proof} 由字符串代数的定义 \ref{D.StringAlgebra} 任何字符串都是
    有限的，故而类型亦如此。故当输入的类型方程组有限，其重量就有限。
    由引理 \ref{L.SMr.W} 算法 SolveM 就是有限停机的。
    再而由引理 \ref{L.SMr.Correct} 算法 SolveM 是正确的。
\end{proof}
\end{theo}

于是直接地推论：

\begin{theo}[类型匹配系统的求解] \label{T.TMS.S}
\[ \forall M.\ \exists M'.\ (M \Meq M') \ \land\ (\Solved M' \lor 
\NoSolution M') \]
另一个等价的表达是
\[ \forall M.\ \Solvable M \Rightarrow \exists M'.\ (M \Meq M')\ \land\ 
\Solved M'\]
    \begin{proof} 由定理 \ref{T.SM} 算法 SolveM 就是寻找这样的 $M'$ 
        的算法，且其有限停机。
\end{proof}
\end{theo}

\begin{theo}[SolveM 的时间复杂度] \label{T.TMS.S.T}
    \[ \text{SolveM 的时间复杂度为}\quad O((\abs{V} + 1)(\EQW(X) + 1)) \]
\begin{proof} 算法 SolveM 对算法 \SolveMr 的不断迭代中，行 \ref{l:mrot1} 
    花费时间 $O(1)$ 最多执行 $O(\EQW(X))$ 次，行 \ref{l:mrot2} 单次花费时间 $O(\EQW(X))$
    最多执行 $O(\abs{V})$ 次，其余均是常量时间，故算法 SolveM 总的时间复杂度
    $O((\abs{V} + 1)(\EQW(X) + 1))$
\end{proof}
\end{theo}

现在，终于是时候把定理 \ref{T.QIMI.S} 定理 \ref{T.TMS.I.I} 定理 \ref{T.TMS.NS} 
定理 \ref{T.TMS.S} 联系到一起。

\begin{lemma} \label{L.inter.q}
    \[ q_1 \NC q_2 \vdash (\QI q_1 \cap \QI q_2 = \emptyset)\ \lor\ 
    (\exists q.\ \QI q_1 \cap \QI q_2 = \QI q)\]
\begin{proof} 首先定理 \ref{T.TMS.I.I}
\[ q_1 \NC q_2 \vdash \QI q_1 \cap \QI q_2 =\ 
\MI\ (\QV q_1 \cup \QV a_2,\ \{\QB q_1 = \QB q_2\})\ \QB(q_1) \tag{定理 \ref{T.TMS.I.I}}\]
令 $M = (\QV q_1 \cup \QV a_2,\ \{\QB q_1 = \QB q_2\})$ 
\[ q_1 \NC q_2 \vdash \QI q_1 \cap \QI q_2 = \MI\ M\ \QB(q_1) \]
使用 SolveM 算法求解得到
$M' = \mathrm{SolveM}\ M$ 且由定理 \ref{T.TMS.S}
    \[ M \Meq M'\ \land\ (\Solved(M')\ \lor\ \NoSolution(M'))\]
再由引理 \ref{Lem.MI.Meq}
\[ q_1 \NC q_2 \vdash \QI q_1 \cap \QI q_2 = \MI\ M'\ \QB(q_1) \]
对 $\Solved(M')$ 的情况，待证命题就是定理 \ref{T.QIMI.S}，对 $\NoSolution(M')$，
待证命题就是定理 \ref{T.TMS.NS} 于是证明完毕。
\end{proof}
\end{lemma}

\begin{algorithm}
\caption{全称量化类型的交 QInter} \label{alg:QInter}
\begin{algorithmic}[1]
\Require 全称量化类型 $q_1,\ q_2 \in \PiAE$
\Ensure $q \in \PiAE$ 满足 $\QI q_1 \cap \QI q_2 = \QI q$，或者 $\QI q_1 \cap \QI q_2 = 
\emptyset$ 时输出 {\it 无解} 。
\State $\NC(q_1,\ q_2) \rightarrow (q_1',\ q_2')$ \Comment{调用算法 \ref{alg:NC} NC}
\State $(\QV q_1' \cup \QV q_2',\ \{\QB q_1' = \QB q_2'\}) \rightarrow M$
\Comment {构造类型匹配系统 $M \in \TMs$}
\State $\mathrm{SolveM}(M) \rightarrow M'$ \Comment{算法 \ref{alg:SolveM} SolveM}
\If {$M' \neq \MNS$}
\State $\mathrm{QIMI}(M',\ \QB q_1') \rightarrow q$ \Comment{算法 \ref{alg:QIMI} QIMI}
\State 输出 $q$
\Else
    \State 输出 {\it 无解}
\EndIf
\TimeComplexity $O(\ \ (\abs{\QV q_1} + \abs{\QV q_2} + 1)\ \ (\TS(\QB q_1) + \TS(
    \QB q_2))\ \ )$
\end{algorithmic}
\end{algorithm}

\begin{theo}[全称量化类型的交] \label{T.inter.q}
    \[\forall q_1,\ q_2 \in \PiAE.\  (\QI q_1 \cap \QI q_2 = \emptyset)\ \lor\ 
    (\exists q.\ \QI q_1 \cap \QI q_2 = \QI q)\]
    \begin{proof} 在引理 \ref{L.inter.q} 的基础上继续应用定理 \ref{T.NCize} 直接得到。
\end{proof}
\end{theo}


算法 QInter 求解这样的 $q$，这样的 $q$ 是 $q_1,\ q_2$ 经最少的实例化操作能得到的
最广的全称量化类型，在下一节类型调用中将发挥重要的作用。


