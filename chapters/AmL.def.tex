\section{抽象机$\aml$的形式定义}

\begin{defin}[$\aml$] \label{Def.aml}
    基于定义\ref{Def.slam}，$\aml$是$\lamst$的应用。
\begin{enumerate}
  \item 设定类型变量集
  \[ U_{\mathrm{A}} = \{ \mathrm{phenomenon} \} \]
  即$\aml$的类型变量集只有一个类型变量 $\mathrm{phenomenon}$。
  因 $\mathrm{phenomenon}$ 过长在以下的论述中将其简写为 $\mathrm{ph}$。
  根据公式\ref{Pi}求得对应的
    \[\Pi_\mathrm{A} = \bnf{U_\mathrm{A} \mbar
        (\Pi_\mathrm{A} \rightarrow \Pi_\mathrm{A})}\]
\item 定义函数$\mathrm{Const}$以构造常量符号，字符串集合 $Const_\mathrm{V}$ 表示常量符号集。

\begin{gather} 
    \mathbf{Const}\ x\ b \coloneqq \underline{\mathrm{Const}\ x\ b} \\
    Const_\mathrm{V} = \{ \mathbf{Const}\ x\ b \mbar x, y \in \mathbb{N} \land x < 2^y \}
\end{gather}

  且 $Const_\mathrm{V}$ 不与 $V$ 重合，即 $Const_\mathrm{V} \cap V = \emptyset$。
  定义常量集$Const$ 为满足如下语法的字符串集合。
        \[ Const = \bnf{Const_\mathrm{V} : \mathrm{phenomenon}} \]
  字符串 $\mathbf{Const}\ x\ b : \mathrm{phenomenon}$ 表示以$b$个二进制位表示的数值 $x$。
\item 定义一个可自由设定的有限字符串集合 $P_\mathrm{V}$ 为基元指令的符号集，
    且 $P_\mathrm{V}$ 不与 $V$ 或$Const_\mathrm{V}$重合。
    定义 $P_\mathrm{V}$ 到 $\Pi$ 的函数 $\mathcal{T}$ 为各个基元指令的类型。
    定义基元指令集$P$。
    \begin{equation}
    P = \{x:\mathcal{T}(x) \mbar x \in P_\mathrm{V} \}
    \end{equation}
\item 定义$\aml$ 的符号集 $V_\mathrm{A}$
    \[ V_\mathrm{A} = V \cup P_\mathrm{V} \cup Const_\mathrm{V} \]
其中 $V$ 是 $\lamst$ 的符号集 $\{v_0, v_1, \cdots\}$
\item $\lambda$表达式 $\Lambda_\mathrm{A}$ 
    \[ \Lambda_\mathrm{A} = \bnf{
        V_\mathrm{A} \mbar V_\mathrm{A}\ V_\mathrm{A} \mbar \lambda V\ V_\mathrm{A}} \] 
    同样简写 $\lambda x_1\ \lambda x_2\ \cdots\ \lambda x_n\ y$ 为
    $\lambda x_1\ x_2\ \cdots\ x_n.\ y$
\item 上下文集合 $C_\mathrm{A} = \powerset \{x:\tau\ |\ x \in V,
    \tau \in \Pi_\mathrm{A}\}$ 定义不变，
    语言的定义 $L_\mathrm{A} ::= \Lambda_\mathrm{A} : \Pi_\mathrm{A}$ 也不变。
    并且有 $P \subseteq L_\mathrm{A}$，$Const \subseteq L_\mathrm{A}$
\item 最后定义 $C_\mathrm{A} \times L_\mathrm{A}$ 上的二元关系 $\vdash_\mathrm{A}$

\hfill

\begin{minipage}[b]{0.5\linewidth}
\begin{prooftree}
    \AxiomC{$\ $} \RightLabel{(参数公理)}
    \UnaryInfC{$\Gamma, x : \tau \vdash_\mathrm{A} x : \tau$}
\end{prooftree}
\end{minipage}%
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
\AxiomC{$\ $} \RightLabel{当 $p \in P$ \quad (基元公理）}
\UnaryInfC{$\Gamma \vdash_\mathrm{A} p$}
\end{prooftree}
\end{minipage}%

\begin{prooftree}
    \AxiomC{$\ $}\RightLabel{当 $x < 2^b$ \quad (常量公理）} 
    \UnaryInfC{$\Gamma \vdash_\mathrm{A} \mathbf{Const}\ x\ b : \mathrm{phenomenon}$}
\end{prooftree}

\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma, x : \sigma \vdash_\mathrm{A} M : \tau$}
\RightLabel{(抽象律)}
\UnaryInfC{$\Gamma \vdash_\mathrm{A} \lambda x\ M : \sigma \leftarrow \tau$}
\end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.3\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash_\mathrm{A} M : \sigma \leftarrow \tau$}
\RightLabel{(组合律)}
\AxiomC{$\Gamma \vdash_\mathrm{A} N : \sigma$}
\BinaryInfC{$\Gamma \vdash_\mathrm{A} M N : \tau$}
\end{prooftree}
\end{minipage}

抽象机 $\aml$就是三元组$(\Lambda_\mathrm{A},\Pi_\mathrm{A},\vdash_\mathrm{A})$。

\end{enumerate}
\end{defin}

此后 $\vdash_\mathrm{A}$ 直接写作 $\vdash$，读者可根据上下文所论述的形式系统确定具体指代的是哪个二元关系。

$\aml$ 可以用来构建程序，并模拟纯计算程序的运行。

\begin{example} 下面是一个 $\aml$上的程序示例，其中
$\mathbf{Add} : \phety \rightarrow \phety \rightarrow \phety \in P$ 是基元指令。

\[ \lambda x\ y.\ \mathbf{Add}\ x\ y : \phety \rightarrow \phety
  \rightarrow \phety\]

由如下推导过程而来。

\begin{prooftree}
%\AxiomC{$x : \phety, y : \phety \vdash x$}
\AxiomC{$\ $}
\RightLabel{(基元公理)}
\UnaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add} : \phety \rightarrow
  \phety \rightarrow \phety$}
\AxiomC{$\ $}
\RightLabel{(参数公理)}
\UnaryInfC{$x : \phety, y : \phety \vdash x : \phety$}
\RightLabel{(组合律)}
\BinaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add}\ x : \phety \rightarrow \phety$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\cdots$}
\UnaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add}\ x : \phety \rightarrow \phety$}
\AxiomC{$\ $}
\RightLabel{(参数公理)}
\UnaryInfC{$x : \phety, y : \phety \vdash y : \phety$}
\RightLabel{(组合律)}
\BinaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add}\ x\ y : \phety$}
\RightLabel{(抽象律)}
\UnaryInfC{$x : \phety \vdash \lambda y\ \mathbf{Add}\ x\ y  : \phety \rightarrow \phety$}
\RightLabel{(抽象律)}
\UnaryInfC{$\vdash \lambda x\ y.\ \mathbf{Add}\ x\ y  : \phety \rightarrow \phety
  \rightarrow \phety$}
\end{prooftree}

\end{example}

$\aml$ 揭示了 \ref{Sec.Overview} 节中叙述的抽象机的大概轮廓与基元指令集的具体方式。

一个关键思想是，$\aml$ 上的一切计算都是对 phenomenon 这一个类型的操作，
% All calculation on $aml$ are operations to the \mathit{phenomenon}.
$\aml$ 上计算的客体是 phenomenon 类型。
% The object of calculation on $\aml$ is \mathit{phenomenon}.
phenomenon 意为“现象”，是哲学上的术语，与其对应的是本质（essence）。
所谓

\begin{center}
    透过现象看本质。
\end{center}

计算机上，计算的客体只是一种东西，数字。
计算机一定是对数字进行计算的设备，计算机中的一切的存在形式也都是数字，无论其被用户或
程序编写者赋予意义是某个学生的分数还是某个字符的编号，其表现都是简单的数字。

但计算机上的运算是人为构造的，是以特定的意义而设计实现的，
数值计算根本上是为了背后的意义而对数字的计算只是为了在机器上得以将设计意义实现
而不得已构造的表象。
重要的是数值计算背后承载的意义，而失去了意义，纯粹的计算毫无意义。
在这点上，计算机世界的本体论是彻底的二元的，计算客体是现象，计算对应的意义是本质。
故而以 phenomenon 命名 $\aml$ 的计算客体是恰当的，而计算客体的意义自然就是本质。

\begin{defin}[现象与本质] 
$\aml$ 及 $\amlh$ 上的计算客体，被叫做{\it 现象}，现象的意义被叫做{\it 本质}。
\end{defin}

对于计算机，计算客体是数字。但对于$\aml$，计算客体 phenomenon 可以
不是数字。虽然phenomenon主要是基于数字类型，但这里有抽象的空间。
在？？？节的实现中可以看到，抽象级别的不同可以导致计算客体的不同，
进而可以适当地设定 phenomenon 类型的具体结构以影响整个 $\aml$。
在最低级别的抽象中，计算客体是数字故而phenomenon 类型就是数字；
在细粒度也是低抽象级别的$\amlhF$中，计算客体是确定大小的数字，是一组一组
确定数目的二进制位，phenomenon 是数字与其二进制位数的二元组；
在粗粒度也是高抽象级别的$\amlhC$中，计算客体是数字与数字之间届由引用联接构成的复杂数据结构
，phenomenon 类型所表达的是确定数目的二进制位组加上这些位组间届由指针相连成的结构，
这样就非常有效地解决了指针的问题并允许复杂数据结构的有效处理。

现象与本质间的对应关系，被叫做\textbf{超越关系}，围绕此关系 $\amlh$ 实现了类型系统的功能。
这样说是因为超越关系及其机制并不能叫做类型系统，而 $\amlh$ 上的类型仅有一个
\textit{phenomenon}。

\input{chapters/AmLH.def.tex}

%
%
%\subsection{抽象机$\amlhF$的形式定义}
%
%对 $\aml$ 在 HOL 上的实现首先从细粒度也是低抽象层级的 $\amlhF$ 开始。
%
%$\aml$ 中的类型 phenomenon 由 HOL 中的类型实现，$\aml$ 中的表达式（term）由 HOL 
%中的表达式表达，也就意味着 $\amlh$ 是 HOL 逻辑的子形式系统。
%
%\[ \amlh \subseteq \HOL \]
%
%\begin{defin}[$\amlhF$的phenomenon类型在HOL上的实现]
%    \begin{equation}
%        \begin{split}
%            \mathrm{phenoval} \Coloneqq\ & \mathbf{PhenoVal}\ \natn\ \natn \\
%            \mathrm{history} \Coloneqq\ & \cdots \\
%            \mathrm{phenomenon} \Coloneqq\ & \mathbf{Phenomenon}\ \mathrm{phenoval}\ 
%                \mathrm{history}
%        \end{split}
%    \end{equation}
%\end{defin}
%
%history 设计对系统状态的建模，暂且搁置而在？？？节论述。
%$\natn$ 是自然数类型。$\mathrm{phenoval}$ 表示一切抽象机上的数值，
%$\mathbf{PhenoVal}\ x\ b$ 在 $x < 2^b$ 时表示$b$个二进制位且数值为$x$的值。
%
%\begin{defin}[phenoval 有效性]
%    \begin{equation}
%        \mathbf{VALID\_PHV}\ (\mathbf{PhenoVal}\ x\ b) \coloneqq x < 2^b
%    \end{equation}
%\end{defin}
%
%\begin{defin}[phenomenon 有效性]
%    \begin{equation}
%        \mathbf{VALID\_PHE}\ (\mathbf{Phenomenon}\ v\ h) \coloneqq \mathbf{VALID\_PHV}
%        \ v \land \mathbf{VALID\_HIS}\ h
%    \end{equation}
%    其中 $\mathbf{VALID\_HIS}$ 为history的有效性谓词，在？？？节详细论述。
%\end{defin}
%
%\begin{defin}[$\amlhF$ 上 $\mathbf{Const}$ 的定义]
%    \begin{equation}
%        \mathbf{Const}\ x\ b \coloneqq \mathbf{Phenomenon}\ (\mathbf{PhenoVal}\ x\ b)\ \mathbf{HGenerator}
%    \end{equation}
%    其中 $\mathbf{HGenerator}$ 在？？？节定义。
%\end{defin}
%
%定义 \ref{Def.aml} 中的常量公理即可由 $\mathbf{Const}$ 实现。
%
