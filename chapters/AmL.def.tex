\section{抽象机$\aml$的形式定义}

\begin{defin}[$\aml$] \label{Def.aml}
    基于定义\ref{Def.slam}，$\aml$是$\lamst$的应用。
\begin{enumerate}
  \item 设定类型变量集
  \[ U_{\mathrm{A}} = \{ \mathrm{phenomenon} \} \]
  即$\aml$的类型变量集只有一个类型变量 $\mathrm{phenomenon}$。
  因 $\mathrm{phenomenon}$ 过长在以下的论述中将其简写为 $\mathrm{ph}$。
  根据公式\ref{Pi}求得对应的
    \[\Pi_\mathrm{A} = \bnf{U_\mathrm{A} \mbar
        (\Pi_\mathrm{A} \rightarrow \Pi_\mathrm{A})}\]
\item 定义函数$\mathrm{Const}$以构造常量符号，字符串集合 $Const_\mathrm{V}$ 表示常量符号集。

\begin{gather} 
    \mathbf{Const}\ x\ b \coloneqq \underline{\mathrm{Const}\ x\ b} \\
    Const_\mathrm{V} = \{ \mathbf{Const}\ x\ b \mbar x, y \in \mathbb{N} \land x < 2^y \}
\end{gather}

  且 $Const_\mathrm{V}$ 不与 $V$ 重合，即 $Const_\mathrm{V} \cap V = \emptyset$。
  定义常量集$Const$ 为满足如下语法的字符串集合。
        \[ Const = \bnf{Const_\mathrm{V} : \mathrm{phenomenon}} \]
  字符串 $\mathbf{Const}\ x\ b : \mathrm{phenomenon}$ 表示以$b$个二进制位表示的数值 $x$。
\item 定义一个可自由设定的有限字符串集合 $P_\mathrm{V}$ 为基元指令的符号集，
    且 $P_\mathrm{V}$ 不与 $V$ 或$Const_\mathrm{V}$重合。
    定义 $P_\mathrm{V}$ 到 $\Pi$ 的函数 $\mathcal{T}$ 为各个基元指令的类型。
    定义基元指令集$P$。
    \begin{equation}
    P = \{x:\mathcal{T}(x) \mbar x \in P_\mathrm{V} \}
    \end{equation}
\item 定义$\aml$ 的符号集 $V_\mathrm{A}$
    \[ V_\mathrm{A} = V \cup P_\mathrm{V} \cup Const_\mathrm{V} \]
其中 $V$ 是 $\lamst$ 的符号集 $\{v_0, v_1, \cdots\}$
\item $\lambda$表达式 $\Lambda_\mathrm{A}$ 
    \[ \Lambda_\mathrm{A} = \bnf{
        V_\mathrm{A} \mbar V_\mathrm{A}\ V_\mathrm{A} \mbar \lambda V\ V_\mathrm{A}} \] 
    同样简写 $\lambda x_1\ \lambda x_2\ \cdots\ \lambda x_n\ y$ 为
    $\lambda x_1\ x_2\ \cdots\ x_n.\ y$
\item 上下文集合 $C_\mathrm{A} = \powerset \{x:\tau\ |\ x \in V,
    \tau \in \Pi_\mathrm{A}\}$ 定义不变，
    语言的定义 $L_\mathrm{A} ::= \Lambda_\mathrm{A} : \Pi_\mathrm{A}$ 也不变。
    并且有 $P \subseteq L_\mathrm{A}$，$Const \subseteq L_\mathrm{A}$
\item 最后定义 $C_\mathrm{A} \times L_\mathrm{A}$ 上的二元关系 $\vdash_\mathrm{A}$

\hfill

\begin{minipage}[b]{0.5\linewidth}
\begin{prooftree}
    \AxiomC{$\ $} \RightLabel{(参数公理)}
    \UnaryInfC{$\Gamma, x : \tau \vdash_\mathrm{A} x : \tau$}
\end{prooftree}
\end{minipage}%
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
\AxiomC{$\ $} \RightLabel{当 $p \in P$ \quad (基元公理）}
\UnaryInfC{$\Gamma \vdash_\mathrm{A} p$}
\end{prooftree}
\end{minipage}%

\begin{prooftree}
    \AxiomC{$\ $}\RightLabel{当 $x < 2^b$ \quad (常量公理）} 
    \UnaryInfC{$\Gamma \vdash_\mathrm{A} \mathbf{Const}\ x\ b : \mathrm{phenomenon}$}
\end{prooftree}

\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma, x : \sigma \vdash_\mathrm{A} M : \tau$}
\RightLabel{(抽象规则)}
\UnaryInfC{$\Gamma \vdash_\mathrm{A} \lambda x\ M : \sigma \leftarrow \tau$}
\end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.3\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash_\mathrm{A} M : \sigma \leftarrow \tau$}
\RightLabel{(组合规则)}
\AxiomC{$\Gamma \vdash_\mathrm{A} N : \sigma$}
\BinaryInfC{$\Gamma \vdash_\mathrm{A} M N : \tau$}
\end{prooftree}
\end{minipage}

抽象机 $\aml$就是三元组$(\Lambda_\mathrm{A},\Pi_\mathrm{A},\vdash_\mathrm{A})$。

\end{enumerate}
\end{defin}

此后 $\vdash_\mathrm{A}$ 直接写作 $\vdash$，读者可根据上下文所论述的形式系统确定具体指代的是哪个二元关系。

$\aml$ 可以用来构建程序，并模拟纯计算程序的运行。

\begin{example} 下面是一个 $\aml$上的程序示例，其中
$\mathbf{Add} : \phety \rightarrow \phety \rightarrow \phety \in P$ 是基元指令。

\[ \lambda x\ y.\ \mathbf{Add}\ x\ y : \phety \rightarrow \phety
  \rightarrow \phety\]

由如下推导过程而来。

\begin{prooftree}
%\AxiomC{$x : \phety, y : \phety \vdash x$}
\AxiomC{$\ $}
\RightLabel{(基元公理)}
\UnaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add} : \phety \rightarrow
  \phety \rightarrow \phety$}
\AxiomC{$\ $}
\RightLabel{(参数公理)}
\UnaryInfC{$x : \phety, y : \phety \vdash x : \phety$}
\RightLabel{(组合规则)}
\BinaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add}\ x : \phety \rightarrow \phety$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\cdots$}
\UnaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add}\ x : \phety \rightarrow \phety$}
\AxiomC{$\ $}
\RightLabel{(参数公理)}
\UnaryInfC{$x : \phety, y : \phety \vdash y : \phety$}
\RightLabel{(组合规则)}
\BinaryInfC{$x : \phety, y : \phety \vdash \mathbf{Add}\ x\ y : \phety$}
\RightLabel{(抽象规则)}
\UnaryInfC{$x : \phety \vdash \lambda y\ \mathbf{Add}\ x\ y  : \phety \rightarrow \phety$}
\RightLabel{(抽象规则)}
\UnaryInfC{$\vdash \lambda x\ y.\ \mathbf{Add}\ x\ y  : \phety \rightarrow \phety
  \rightarrow \phety$}
\end{prooftree}

\end{example}

$\aml$ 揭示了 \ref{Sec.Overview} 节中叙述的抽象机的大概轮廓与基元指令集的具体方式。

一个关键思想是，$\aml$ 上的一切计算都是对 phenomenon 这一个类型的操作，
% All calculation on $aml$ are operations to the \mathit{phenomenon}.
$\aml$ 上计算的客体是 phenomenon 类型。
% The object of calculation on $\aml$ is \mathit{phenomenon}.
phenomenon 意为“现象”，是哲学上的术语，与其对应的是本质（essence）。
所谓

\begin{center}
    透过现象看本质。
\end{center}

计算机上，计算的客体只是一种东西，数字。
计算机一定是对数字进行计算的设备，计算机中的一切的存在形式也都是数字，无论其被用户或
程序编写者赋予意义是某个学生的分数还是某个字符的编号，其表现都是简单的数字。

但计算机上的运算是人为构造的，是以特定的意义而设计实现的，
数值计算根本上是为了背后的意义而对数字的计算只是为了在机器上得以将设计意义实现
而不得已构造的表象。
重要的是数值计算背后承载的意义，而失去了意义，纯粹的计算毫无意义。
在这点上，计算机世界的本体论是彻底的二元的，计算客体是现象，计算对应的意义是本质。
故而以 phenomenon 命名 $\aml$ 的计算客体是恰当的。

对于计算机，计算客体是数字。但对于$\aml$，计算客体 phenomenon 可以
不是数字。虽然phenomenon主要是基于数字类型，但这里有抽象的空间。
在？？？节的实现中可以看到，抽象级别的不同可以导致计算客体的不同，
进而可以适当地设定 phenomenon 类型的具体结构以影响整个 $\aml$。
在最低级别的抽象中，计算客体是数字故而phenomenon 类型就是数字；
在细粒度也是低抽象级别的$\amlhF$中，计算客体是确定大小的数字，是一组一组
确定数目的二进制位，phenomenon 是数字与其二进制位数的二元组；
在粗粒度也是高抽象级别的$\amlhC$中，计算客体是数字与数字之间届由引用联接构成的复杂数据结构
，phenomenon 类型所表达的是确定数目的二进制位组加上这些位组间届由指针相连成的结构，
这样就非常有效地解决了指针的问题并允许复杂数据结构的有效处理。

现象与本质间的对应关系，被叫做\textbf{超越关系}，基于此 $\amlh$ 构建起一套
非常梦幻的类型系统。

\subsection{$\amlh$的形式定义}

$\aml$ 只是纯粹基于字符串的形式系统。仅有的字符串理论实在太过单薄，更多巧妙的设计无以构建。

接下来本文论述 $\amlh$，它也是一种形式系统，是 HOL 逻辑的扩广，即有

\[ \mathrm{HOL} \subseteq \amlh \]

这种扩广以对于 HOL 逻辑合法的方式进行，HOL 逻辑上的证明工具依旧可以用于 $\amlh$ 上并对
$\amlh$ 上的表达进行证明；而这种扩广又允许类似$\aml$地构造程序以允许其上的软件开发。

需要注意的是 $\amlh$ 是一种形式系统的框架，一些设定是未具体定义而允许定制的，可以
构造不同版本的 $\amlh$ 实现。本文将研究两种$\amlh$的实现，高抽象层级粗粒度的
$\amlhC$ 与地抽象层级细粒度的 $\amlhF$

\begin{defin}[现象类型] 类型 phenomenon 表示 $\aml$ 上的计算客体，根据不同的$\aml$实现可以
    以不同方式具体定义。
\end{defin}

\begin{defin}[到$\alpha$的解释] 类型 $\itp{\alpha}$ 是现象到
    具有类型 $\alpha$ 的本质的解释，包含可以构建现象与本质间联系的映射。
    \begin{equation} \begin{split}
        \itp{\alpha} \Coloneqq \mathbf{Interpretation}\ &(\alpha \rightarrow \phenomenon)
        \ (\phenomenon \rightarrow \alpha)\\
        &(\alpha\ \mathrm{set})\ (\phenomenon\ \mathrm{set})
    \end{split} \end{equation}
    \begin{align*}
        \mathbf{ITP\_LIGHT}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = l \\
        \mathbf{ITP\_TRANSCEND}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = tr \\
        \mathbf{ITP\_SET}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = s \\
        \mathbf{ITP\_PSET}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = s_p
    \end{align*}
\end{defin}

$\itp{\alpha}$ 表示一个将现象对应为某种 $\alpha$ 类型的本质的解释。
例如现象到布尔值间的超越映射就要届由到 bool 类型的解释来完成。
$\mathbf{Interpretation}\ l\ tr\ s\ s_p$ 构建了这样一个理解，$l$是投影函数，确定本质到
现象的映射；$tr$ 是超越函数，确定现象到本质的映射；$s$ 是本质集合，
有 $s \subseteq \mathrm{dom}\ l \land s \subseteq \mathrm{rng}\ tr$；
$s_p$ 是现象集合，有 $s_p \subseteq \mathrm{dom}\ tr \land s_p \subseteq \mathrm{rng}\ l$
，一个理解即是上述的四元组。

\begin{example}[到bool的解释的样例]
\[ \begin{split}
    \mathbb{B}_\mathrm{I} \coloneqq\ & \mathbf{Interpretation}\ (\lambda e.\ \mathbf{if}\ e\ 
    \mathbf{then}\ 1\ \mathbf{else}\ 0) \\
& (\lambda p.\ \mathbf{if}\ p=0\ \mathbf{then}\ \mathrm{F}\ \mathbf{else}\ \mathrm{T})\quad
   \{\mathrm{T},\ \mathrm{F}\}\quad \mathbb{N}
\end{split} \]
\end{example}

\begin{defin}[超越对应关系] 定义三元关系 $ p \widesim{i} e$ 表示现象与本质在某种理解
    下的的对应关系。
\begin{equation}
     p \widesim{i} e \coloneqq e \in \mathbf{ITP\_SET}\ i \land
        (\mathbf{ITP\_TRANSCEND}\ i = p)
\end{equation}
\end{defin}

某个成立的超越对应关系可以用 HOL 逻辑证明，或者以形式系统的角度去说，
可以用HOL逻辑的一系列规则得到某个成立的超越关系。

\begin{prooftree}
    \AxiomC{$\cdots$} 
    \RightLabel{对于某个成立的 $p \widesim{i} e$} \doubleLine
    \UnaryInfC{$\vdash p \widesims{ii}{\cdot\cdot} \widesim{i} e$}
\end{prooftree}


HOL 上的 $\aml$ 即 $\amlh$，在 HOL 的范畴下，包括自然数理论、
高阶逻辑理论等众多数学工具得以使用，允许构建非常巧妙而强大的类型系统。

此处的 HOL 是双关语，即表示高阶逻辑，又表示 HOL 定理证明器上的形式逻辑即 HOL 逻辑。
高阶逻辑与 HOL 定理证明器的逻辑是如此接近，而 $\amlh$ 对数理工具的应用并不严苛，
事实上对于 $\amlh$ 这两者都可行而不需要区分开来。


\begin{defin}[解释] 给定集合 $S$，$S$ 到  
\end{defin}

\begin{defin}[超越关系] 定义关系
\end{defin}



\subsection{抽象机$\amlhF$的形式定义}

对 $\aml$ 在 HOL 上的实现首先从细粒度也是低抽象层级的 $\amlhF$ 开始。

$\aml$ 中的类型 phenomenon 由 HOL 中的类型实现，$\aml$ 中的表达式（term）由 HOL 
中的表达式表达，也就意味着 $\amlh$ 是 HOL 逻辑的子形式系统。

\[ \amlh \subseteq \HOL \]

\begin{defin}[$\amlhF$的phenomenon类型在HOL上的实现]
    \begin{equation}
        \begin{split}
            \mathrm{phenoval} \Coloneqq\ & \mathbf{PhenoVal}\ \natn\ \natn \\
            \mathrm{history} \Coloneqq\ & \cdots \\
            \mathrm{phenomenon} \Coloneqq\ & \mathbf{Phenomenon}\ \mathrm{phenoval}\ 
                \mathrm{history}
        \end{split}
    \end{equation}
\end{defin}

history 设计对系统状态的建模，暂且搁置而在？？？节论述。
$\natn$ 是自然数类型。$\mathrm{phenoval}$ 表示一切抽象机上的数值，
$\mathbf{PhenoVal}\ x\ b$ 在 $x < 2^b$ 时表示$b$个二进制位且数值为$x$的值。

\begin{defin}[phenoval 有效性]
    \begin{equation}
        \mathbf{VALID\_PHV}\ (\mathbf{PhenoVal}\ x\ b) \coloneqq x < 2^b
    \end{equation}
\end{defin}

\begin{defin}[phenomenon 有效性]
    \begin{equation}
        \mathbf{VALID\_PHE}\ (\mathbf{Phenomenon}\ v\ h) \coloneqq \mathbf{VALID\_PHV}
        \ v \land \mathbf{VALID\_HIS}\ h
    \end{equation}
    其中 $\mathbf{VALID\_HIS}$ 为history的有效性谓词，在？？？节详细论述。
\end{defin}

\begin{defin}[$\amlhF$ 上 $\mathbf{Const}$ 的定义]
    \begin{equation}
        \mathbf{Const}\ x\ b \coloneqq \mathbf{Phenomenon}\ (\mathbf{PhenoVal}\ x\ b)\ \mathbf{HGenerator}
    \end{equation}
    其中 $\mathbf{HGenerator}$ 在？？？节定义。
\end{defin}

定义 \ref{Def.aml} 中的常量公理即可由 $\mathbf{Const}$ 实现。

