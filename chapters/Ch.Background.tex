\chapter{绪论} \label{Ch.intro}
\section{研究背景与意义}

区块链是一种新兴的去中心化分布式技术\cite{沈鑫2016,袁勇2016,zheng2017overview}，
建立在此技术上的智能合约平台允许分布式地运行一系列被叫做“智能合约”的程序
\cite{buterin2014next,贺海武2018,欧阳丽炜2019}。
基于区块链技术与智能合约技术的应用已产生了广泛的影响\cite{casino2019systematic,袁勇2016}。
其中以太坊 \cite{buterin2014next} 与 EOSIO \cite{eos.io} 均是
目前商业市场上活跃的平台，本文撰写时
以太坊市场总值为1500亿人民币左右，EOSIO 市场总值为280亿人民币左右
\cite{coinmarket.cap}。

许多智能合约应用于金融领域\cite{林晓轩2016}，智能合约的
%程序实现上的
缺陷将直接影响其业务，并可能造成严重的经济损失，
且已实际发生多起经济损失事件\cite{vitalik2016think, atzei2016survey}，
包括 DAO 事件\cite{DAOattack} 造成1.5亿美元的损失，
HackerGold 事件\cite{HackerGold} 造成 40万美元的损失，
Rubixi 事件\cite{vitalik2016think} 造成 2万美元的损失，
Governmental 事件\cite{vitalik2016think} 造成 1万美元的损失，
Parity Multisig 事件\cite{ParityMultisig} 造成3千万美元的损失。

由于区块链技术本身的特点，一旦智能合约被部署就难以被修改，
而任何部署后发现的缺陷都难以被修复。DAO 事件中，缺陷实际在数月前就被发现，
但因缺乏有效的补救措施而未能及时修复，事件发生后以太坊不得不通过
硬分叉来挽回攻击造成的损失，但仍造成其市值大幅下跌 \cite{EebhftrDf}。

因此对智能合约的安全分析非常重要，特别是在智能合约被实际部署应用之前。
已有大量文献利用形式化方法对智能合约进行安全研究，
Krupp 开发了程序 \textsc{teEther} 能自动发现以太坊智能合约漏洞，并进行自动渗透
\cite{krupp2018teether}；
Hildenbrandt 在 $\mathbb{K}$ Framework \cite{rosu2010overview} 上构建了
以太坊虚拟机 EVM (Ethereum Virtual Machine)，
以允许使用 $\mathbb{K}$ Framework 对
以太坊智能合约进行包括形式化验证在内的安全分析 \cite{hildenbrandt2018kevm}。

大量的工作对智能合约进行形式化验证已证明其对给定性质的正确性，
这些验证工作可以分为基于 Model check 的与基于演绎证明（Deductive Verification）的
。基于 Model check 的工作包括，
Luu 开发了符号执行工具 \textsc{Oyente} 寻找以太坊智能合约的潜在缺陷
\cite{luu2016making}，尽管这一工具被批评为既不可靠（sound）又不完备（complete）
\cite{grishchenko2018foundations,kalra2018zeus}；
Zhou 提供工具 \textsc{Sasc} 扩展了 \textsc{Oyente} 的功能，包括增加了额外的特征样式与
可视化 Solidity 代码的拓扑图中已探测到的风险 \cite{zhou2018security}；
\textsc{Maian} 也扩展了 \textsc{Oyente} 的功能，额外地考虑单个智能合约中的多次调用情形，
进而发现不正常的，贪婪或者自杀的智能合约 \cite{nikolic2018finding}。
\textsc{Oyente} 相关工作的主要缺陷在可靠性，只能发现一些潜在的漏洞而无法证明
对任何性质的满足。
Kalra 开发了程序 \textsc{ZEUS} 通过抽象解释与符号模型检查分析去证明一个以太坊
智能合约的正确性并验证它的公平性，它将智能合约翻译到 LLVM 平台，并使用 LLVM 
上已有的形式化验证工具进行分析与证明 \cite{kalra2018zeus}；
Tsankov 类似地提供工具 \textsc{Securify} 分析并证明智能合约的性质
\cite{tsankov2018securify}。
其他类似的基于 Model check 的验证或分析工具包括 MythX\cite{mythril}，Manticore
\cite{Manticore}，solgraph\cite{solgraph}，SmartCheck\cite{SmartCheck}。

基于演绎证明的工作包括，Bhargavan 将以太坊智能合约翻译到具有依赖类型系统的
编程语言 \Fsharp \cite{Fstart.lang} 上，使用依赖类型系统对智能合约进行演绎证明 \cite{bhargavan2016short}；
Hirai 将以太坊虚拟机 EVM (Ethereum Virtual Machine)
形式地定义在 Isabelle/HOL\cite{isabelle.itp} 上并使用 Isabelle/HOL 对 EVM 上智能合约的字节码进行
证明 \cite{hirai2017defining}；Amani 改进了 Hirai 的工作，使用来自原始编程语言
的基础构造块信息有效地优化了证明的速度 \cite{amani2018towards}；
Pettersson 设计并实现了依赖类型语言 Idris 到 EVM 的编译后端，以允许由被依赖类型
系统验证的 Idris 程序编译到 EVM \cite{pettersson2016safer}。
此外还有一些相关的工作，Sergey 设计了中间级别的编程语言 Scilla 用于
对智能合约的形式化证明，特别考虑了智能合约在链上的通讯 \cite{sergey2019scilla}。

综合来看，
目前对智能合约的形式化验证工作还有很多欠缺。Model check 类的工作受到 Model check
本身能力的制约，只能证明一阶逻辑（First Order Logic）内的性质，进而
只能削除限定种类的智能合约缺陷，例如算术溢出、栈调用溢出等一些特定种类的缺陷。
对于智能合约中更抽象的逻辑错误往往是无能为力的，例如难以证明一段程序输出的值
始终是质数。
%工具 \textsc{ZEUS} 使用受限霍恩子句（constrained horn clauses）进行证明，
%而受限霍恩子句只能处理一阶逻辑的问题。
演绎验证类的工作则在实际实践中颇为困难，多数工作是难以实施的，即便是对
一些短小的智能合约，也需要消耗大量的时间与人力。


在形式化验证的更广泛的应用场景同样存在这样的问题，Model check 仅能自动地解决
限定种类的问题，进而排除确定种类的某些缺陷，但别的潜在缺陷依旧可能存在。
%而演绎式的验证在实践中是困难的。%Model check 的问题是，永远只能证明程序的部分性质
Model check 无法证明程序实现对于形式化描述的相等，
进而排除程序实现中所有的缺陷。

演绎证明虽然理论上有能力证明程序实现对于描述的相等，进而完整证明程序实现的
正确性并削除实现中所有的缺陷，但实际实践起来有诸多问题。
演绎证明具体分两种方法。

第一种将某种编程语言上的程序翻译到另一个有足够表达能力的证明系统，
并将形式化描述也翻译进同一证明系统，在此证明系统上证明程序与描述的相等性
，以完成程序实现的证明。
这有诸多困难，首先程序到证明系统的翻译必须正确，翻译正确性本身同样需要
证明。
其次将某种形式语言上的程序翻译到另一个证明系统内，势必会导致程序的表述
更加复杂，于是证明更加困难。
特别是当此编程语言一开始就未考虑性质的证明而仅考虑程序的执行时，
会给这种方式的证明带来根本上的困难。
著名的 seL4 内核的形式化验证是这种思路的代表，
仅8700行的C语言与600行的汇编语言的程序被翻译到Isabelle/HOL 证明系统上
去形式化验证，最后生成了200,000行 Isabelle 代码并消耗
20人年才得以完成\cite{klein2009sel4}。

直接对低级程序指令进行分析是困难的，而对高级语言表示的源代码的分析是相对容易的，
因为高级语言的表示中蕴含了更多的逻辑信息。但即便如此，编程语言的表达依旧丢失了
很多来自用户的逻辑信息。

第二种方法使用依赖类型系统（dependent typed system）
\cite{pierce2005advancedC2} 完成验证。
基于 Curry-Howard 同构\cite{howard1980formulae,sorensen2006lectures}
与构造演算（Calculus of Constructions）\cite{coquand1986calculus}
，依赖类型系统本身同构与一个完备的数学逻辑，
于是类型系统本身能够承载几乎全部的用户逻辑信息，开发者能够将程序的设计、以及
所期望的性质表达在类型中，并通过类型检查，验证程序确实满足了开发者的期望。

%
%足以表达程序的所有性质，可以形式地描述程序的设计；
%再由 Curry-Howard 同构，将程序同构于此数学逻辑的证明，于是程序的编写
%本身就是对作为类型的定理的证明，用户在编写程序的同时也是编写对程序性质
%的证明。依赖类型系统的语言是可以完整证明程序实现的正确性的。

但依赖类型系统的问题在于工程实现的性能。程序必须既是对定理的证明又承载
具体的工程实现，既要考虑定理证明的数学问题又要考虑执行性能等工程问题
。它的类型必须既作为一个易于分析的数学命题，又能描述程序所有现实事务的
性质，于是类型必须既足够的抽象并具有巧妙的数学灵性，又足够地贴近现实事务
以完整地描述程序的设计。其程序与类型，需要同时扮演两个相悖的角色。
最终的结果是，在依赖类型系统的语言作为一门函数式语言具有相对过程式语言较差的
执行性能的基础上，实现的性能往往必须被进一步牺牲。
第 \ref{Ch.conclusion} 章将讨论，一些过程式语言上常见的设计例如
比特位标记，在依赖类型系统上是难以实现的。
此外尽管有一些诸如 MCMQ\cite{ioannidis2019extracting}，
\Fsharp \cite{Fstart.lang} 等将程序编译到较高性能的执行平台上的方案，
但性能问题根本的原因，相悖的两个角色，源自设计的根本而无法被解决。

在这样的背景下，本文尝试寻找一种既继承了依赖类型系统优点又解决了其缺陷的程序构建方法
。它同样允许开发者完整地表达逻辑信息与意图，允许由此逻辑信息有效地简化并最终
完成对程序的验证，同时将具体的工程实现与抽象分析分离，令程序不需要考虑证明。
结果是，程序可以专注于工程实现并能细致地考量执行性能，
进而这种方法既能保留依赖类型系统易于形式分析的优点，又能
生产具有良好执行性能的高质量工程实现。
本文从智能合约领域开始具体的探索与实践。


%%进行有效且充分的形式化验证。
%
%已有大量文献研究智能合约的安全性
%\cite{dhawan2017analyzing, krupp2018teether, luu2016making, 
%suiche2017porosity, kalra2018zeus, nikolic2018finding}。
%已有大量文献利用形式化方法对智能合约进行安全研究
%\cite{hildenbrandt2018kevm, bhargavan2016formal, hirai2017defining,
%amani2018towards, pettersson2016safer, sergey2018scilla, grishchenko2018foundations}。
%
%而测试与静态分析难以覆盖所有潜藏的缺陷。目前的智能合约都很短小，
%对其进行形式化验证相对而言并不困难，而因其特性智能合约上一切缺陷的代价
%都十分昂贵，因此值得对智能合约进行尽可能全面的形式化验证。
%如上述，若能彻底形式化地证明智能合约实现的正确性，则可自信地宣称
%此合约的实现已尽其所能的正确而不存在任何潜在的缺陷。
%
%软件的正确性由其设计的正确性与其程序实现的正确性组成。
%软件设计的正确与否也许是难以评判的。
%而程序实现的正确性是可以被形式化验证的。
%通过将设计表达为某种形式语言上的形式化描述（Formal Specification）
%\cite{DinesSE1}，
%再证明程序实现对此描述的严格相等，就能证明程序实现的正确性。
%
%程序实现的正确性证明有实际需求，特别是在安全严苛
%（Safety critical）\cite{DinesSE1,safety-crtical-formal-method} 的场景。
%基于区块链平台的智能合约就是这样的场景。




%
%
%本工作最后的实现所聚焦的基于区块链技术的各种智能合约平台是一种
%安全严苛（Safety critical）\cite{DinesSE1,safety-crtical-formal-method} 场景。
%因为区块链技术与平台的特殊性，被叫做智能合约的程序一旦被部署往往就无法修改，
%进而无法更新以修复任何部署前未被发现的缺陷 \cite{swan2015blockchain}。
%而目前区块链技术与智能合约平台大量应用于金融领域，如 Bitcoin 等诸多的
%加密货币\cite{narayanan2016bitcoin}，与加密金融这一新领域\cite{came2019}。
%短短的数年以来智能合约领域已有大量的缺陷案例\cite{atzei2016survey}。
%这些缺陷往往会导致严重的经济损失。
%这些案例中，软件的设计往往是正确的而因为程序错误的实现而造成了损失。
%这凸显了验证程序实现的重要性。
%
%
%本工作着重以智能合约应用为场景，针对 EOSIO 平台设计。
%
%
%但很多形式化验证方法的能力是有限的。这根本上是因为
%不存在一个万能的算法证明任何一阶逻辑之外的，高阶逻辑上的命题。
%于是不存在一个全自动的算法，验证一个程序的各种性质。
%
%对于此，计算理论界与软件工业界走向了两个方向。计算理论界给出了交互式定理
%证明器，通过来自用户的决断与策略半自动地进行形式化证明。
%软件工业界给出了 Model check，将问题的规模缩小，并非验证程序的所有性质
%而仅是限定的某个模型内的部分性质，进而将待证命题弱化入一阶逻辑，进而
%能找到一个全自动的算法完成全自动的证明。
%
%
%
%
%
%
%%Curry–Howard 同构\cite{curry1934functionality,howard1980formulae,curry1958combinatory,sorensen2006lectures} 揭示了程序与证明的内在关联，而后的
%%构造演算（Calculus of Constructions, CoC）\cite{coquand1986calculus}
%%可以同时作为数学的基础与程序的基础，于是可以同时用于构建程序与定理证明，
%%其类型系统等价于完整的数学逻辑（具体而言，经典逻辑或者直觉主义逻辑），
%%几乎可以表达所有性质，进而可以彻底证明程序的正确性。
%%事实上，依赖类型系统本身已经接近定理证明工具。
%%Coq\cite{coq.itp}、Agda\cite{norell2008dependently}、Idris
%%\cite{brady2013idris}
%%是其中的代表，而 Coq 就是一种定理证明工具。
%%依赖类型系统本身作为一个数学理论是完美的，但其中的程序不得不同时扮演作为工程
%%实现的角色与定理的证明过程，程序开发者需要写下一份文本而同时有两个相悖的角色，
%%有良好的工程实现的性能又具有巧妙的数学灵性，以易于证明而完成证明。
%%这是非常困难并在一些场合上不可能的。
%%%，在舞台上一人分饰两角都称得上精彩的戏剧了。
%%最后一章结论部分本文细致地分析。
%%此外，即便一个优秀的程序员成功让作为数学证明的程序兼顾了工程实现的性能，
%%但高度抽象的类型系统自身将影响程序的性能。
%%依赖类型的编程语言首先一定是函数式的，而近百年尝试的结果是函数式编程语言，
%%因为性能包括空间性能与时间性能，然后是易用性等种种原因，
%%让现实的软件工业界最终选择了过程式编程语言。
%%各种现代的函数式语言尽力优化，但仍无法企及各种过程式语言。
%%而依赖类型系统的语言更难以应用所有这些优化。
%%尽管有一些诸如 MCMQ\cite{ioannidis2019extracting}，\Fsharp \cite{Fstart.lang}
%%等将程序编译到高性能的平台上的方案，
%%MCMQ 将 Coq 代码翻译到C++语言而 \Fsharp  编译到公共语言运行时（Common Language Runtime, CLR），
%%但前面说过了，依赖类型系统让程序具有相悖的双重角色是问题的根本来源，
%%在最后一章将详细论述并与本文的工作进行对比。而作为结论，我个人认为依赖类型系统很优秀，
%%但不适合用于描述形式化验证所需的那些全部的性质。而作为证明，软件工业界的形式化验证
%%还没有被依赖类型统治，还是有很多现实的项目拒绝了依赖类型系统。
%%
%
%
%
%%
%%软件开发的主要挑战是在有限而可控的时间与经费预算下开发高质量的软件
%%\cite{DinesSE1, brooks1995mythical}。
%%大量的方法提出以提升软件工程的效率与产品的质量
%%\cite{DinesSE1, SoftwareQuality}。
%%形式化方法（formal method）也可有效地应用于此，
%%以提升软件质量，并辅助软件的开发以提升开发效率\cite{formal_method_view1} 。
%%实际上大量的形式化方法已经发挥实际作用\cite{pierce2002types, jackson2012software}。
%%
%%其中重要的一点是程序实现的验证，即一个实现是否正确实现了设计的全部功能，
%%且不具有违背设计的包括漏洞在内的任何缺陷。
%%传统的单元测试难以发掘程序的全部潜在缺陷，
%%相比而言形式化验证可以更有效地验证程序实现而发现更多的缺陷
%%\cite{formal_method_view1}。
%%但问题在于，倘若某种可行的形式化验证仅仅是更有效而并非是彻底，
%%即被验证后的程序实现依旧可能存在种种缺陷，
%%那这种形式化验证只能称之为比传统测试更好，
%%但问题仍未被彻底解决，仍然不能说一个实现是对设计正确的满足而无任何缺陷。
%%
%%软件的正确性包括其设计的正确性与程序实现的正确性。
%%软件的设计可能有缺陷，也许难以预见而难以检验，
%%但是否有可能一个程序的实现是彻底正确而无缺陷地满足了其设计？
%%进而能否验证一个程序是否被正确实现？
%%再而能否构造正确实现的而无任何缺陷的程序，
%%即所谓被验证的程序（verified software）\cite{verified_soft_grand}？
%%
%%这一点具有实际的意义。
%%特别是在安全严苛（Safety critical）\cite{DinesSE1}的场景上尤其紧要。
%%有太多的计算机硬件与软件系统直接与生命安全、重要的民生事务相关。
%
%
%%程序实现是否是可以彻底正确而无任何缺陷的？大规模的程序实现是否可以
%%彻底正确？能否有效地开发彻底正确的程序实现？
%%
%%%我们
%%不能因为过往与眼前经受的种种困难就放弃，而轻易地留下一句
%%“这始终是一门发展的学科，程序亦始终在发展而不存在完美的一刻”，
%%以对一切草草了事。
%%一个程序实现是否可以是彻底正确的，这一问题事关计算机科学作为科学的严谨
%%性。
%%%若一门科学，连其主要研究对象的正确性都无法自信地断言，这就动摇了
%%%其作为科学的基础。需要一个认真的回答，而如果无法回答，那就是计算机科学
%%%研究领域重要的空缺。将程序开发视作一个发展的过程而因此忽视程序实现正确性
%%%的证明，这是自我开脱。
%%
%%对正确而无缺陷的程序实现及这种开发方法的追求并非是痴人说梦。
%%1967年 Floyd 的论文就清晰地旨在寻找一种严格的对程序证明
%%包括正确性证明与停机性证明的方案\cite{floyd1967}。
%%2009 年 SeL4 系统内核被成功地形式化验证，
%%完整地证明了其程序实现的正确性。
%
%%以 Hoare 与 Milner 的话说，
%%这是计算科学界的“伟大挑战”（Grand challenge in computing research）
%%\cite{hoare2004grand, hoare2006ideal}。
%%众多的支持文章从不同角度涌现：“具有验证功能的编译器”（verifying compiler）
%%\cite{verifying_compiler}，“被验证的软件”（verified software）
%%\cite{verified_soft_grand}，“可依赖的系统演化”（Dependable Systems Evolution）
%%\cite{Dependable_Systems_Evolution_grand}。
%%
%%然而相比数理逻辑的简洁，现实的需求是如此复杂，系统具有如此多的细节，
%%形式化模型难以描述这些，而对其进行分析就更加困难，
%%就意味着更加巨大的资源投入与消耗\cite{jackson2012software}。
%
%
%%本文追求这一点，一种能严谨证明程序实现的正确性的，切实工业界可行的
%%形式化方法。
%
%%\subsection{工业实践中彻底证明程序实现正确性的困难} \label{Sec.formal_method}
%%
%%现代编程语言基本都是形式语言，编程语言上的程序是这一形式语言上的表达，
%%而类型系统是编程语言上的形式系统，类型系统本身就是一种形式化方法，
%%它对程序的分析与推断构成了对程序的形式化验证。
%%
%%类型系统属于形式化方法中的 model checker。model checker 全自动地
%%分析检查程序是否满足声明的性质。
%%但类型系统与各种 model checker 的通病是，其形式语言的表达能力往往是
%%有限的，只能表达有限的性质进而只能推导与证明这些有限的，就
%%只能削除有限种类的缺陷，大量别的缺陷依旧可能存在，
%%程序实现的正确性无法被彻底证明。
%%%这就是为什么这个世界的形式化方法这一领域还依旧活跃
%%%并存在如此多的问题尚未解决。
%%
%%对此，学界有多个思路。第一种思路力图保留 Model checker 简单易用
%%的良好特性而有限地加强 model checker 的功能，例如采用覆盖面更广表达能力
%%更强的模型，refinement type 是这样的例子。
%%这种思路依旧是无法彻底证明程序实现正确性的，故在本文的目标下一笔带过。
%%
%%第二种思路尝试将编程语言上的程序装入另一个表达能力更强的证明系统，
%%即将程序翻译进另一个证明系统以此完成原本类型系统无法触及的，
%%对程序实现正确性的证明。
%%这有诸多困难，首先程序到证明系统的翻译必须正确，既然是形式化证明
%%而非主观臆测的断言这翻译就必须被证明，这并不容易。其次
%%在一种形式语言上的程序翻译到另一个证明系统内，其表达一定会更加复杂。
%%根本上，程序验证的困难来自于编程语言一开始就未考虑证明而
%%仅针对程序的执行，将程序翻译到证明系统中除了增加复杂并不能使
%%程序更易于证明，因为根本的问题并未得到解决。
%%
%%著名的 seL4 内核的形式化验证是这种思路的代表，
%%仅8700行的C语言与600行的汇编语言的程序被翻译到Isabelle/HOL 证明系统上
%%去形式化验证，最后生成了200,000行 Isabelle 代码并消耗
%%20人年才得以完成\cite{klein2009sel4}。
%%
%%化简程序形式化验证的困难一定要从编程语言着手，一开始就未考虑到证明
%%难度的编程语言上的程序一定是难以证明的。
%%
%%第三种思路围绕依赖类型（dependent typed system）\cite{pierce2005advancedC2}踩在了点上。
%%Curry–Howard 同构\cite{curry1934functionality,howard1980formulae,curry1958combinatory,sorensen2006lectures} 揭示了程序与证明的内在关联，而后的
%%构造演算（Calculus of Constructions, CoC）\cite{coquand1986calculus}
%%可以同时作为数学的基础与程序的基础，于是可以同时用于构建程序与定理证明，
%%其类型系统等价于完整的数学逻辑（具体而言，经典逻辑或者直觉主义逻辑），
%%几乎可以表达所有性质，进而可以彻底证明程序的正确性。
%%事实上，依赖类型系统本身已经接近定理证明工具。
%%Coq\cite{coq.itp}、Agda\cite{norell2008dependently}、Idris
%%\cite{brady2013idris}
%%是其中的代表，而 Coq 就是一种定理证明工具。
%%依赖类型系统本身作为一个数学理论是完美的，但其中的程序不得不同时扮演作为工程
%%实现的角色与定理的证明过程，程序开发者需要写下一份文本而同时有两个相悖的角色，
%%有良好的工程实现的性能又具有巧妙的数学灵性，以易于证明而完成证明。
%%这是非常困难并在一些场合上不可能的。
%%%，在舞台上一人分饰两角都称得上精彩的戏剧了。
%%最后一章结论部分本文细致地分析。
%%此外，即便一个优秀的程序员成功让作为数学证明的程序兼顾了工程实现的性能，
%%但高度抽象的类型系统自身将影响程序的性能。
%%依赖类型的编程语言首先一定是函数式的，而近百年尝试的结果是函数式编程语言，
%%因为性能包括空间性能与时间性能，然后是易用性等种种原因，
%%让现实的软件工业界最终选择了过程式编程语言。
%%各种现代的函数式语言尽力优化，但仍无法企及各种过程式语言。
%%而依赖类型系统的语言更难以应用所有这些优化。
%%尽管有一些诸如 MCMQ\cite{ioannidis2019extracting}，\Fsharp \cite{Fstart.lang}
%%等将程序编译到高性能的平台上的方案，
%%MCMQ 将 Coq 代码翻译到C++语言而 \Fsharp  编译到公共语言运行时（Common Language Runtime, CLR），
%%但前面说过了，依赖类型系统让程序具有相悖的双重角色是问题的根本来源，
%%在最后一章将详细论述并与本文的工作进行对比。而作为结论，我个人认为依赖类型系统很优秀，
%%但不适合用于描述形式化验证所需的那些全部的性质。而作为证明，软件工业界的形式化验证
%%还没有被依赖类型统治，还是有很多现实的项目拒绝了依赖类型系统。
%%
%%现状是，作为总结，软件开发的商业与工业主流已牢牢地得益于各种形式化方法，
%%形式化方法已渗入软件开发的各个方面，在安全严苛场景已大量地应用，
%%但对软件普遍地形式化验证仍未到来。
%%形式化方法的确已经有效地帮助程序开发，形式化验证也已有效地发现并避免
%%了诸多软件缺陷，但缺陷与漏洞依旧存在。
%%在一些限定的范围，被验证的程序实现已经能够生产，却
%%在现实的工业生产的普遍范围内因为种种原因未被广泛应用。
%%现实软件工业的普遍现状是，缺陷与漏洞始终存在。
%%现实的商业生产尚未选择——因为尚未发现——一种折合成本与收益后更划算的方案，
%%生产完美无缺的程序实现，即任何已有手段的实施成本本身，相比缺陷本身的潜在危害都更加昂贵。
%%
%%无论是软件工程方面的现实经济意义，还是计算机科学角度的学术意义，
%%形式化方法都从未实现它的愿景。%，因此这“伟大挑战”也得以是一种挑战。
%%
%%本文尝试寻找并实现这样的形式化方法，它代价不高，不消耗大量的开发成本，
%%只需要不可规避的专业数学知识与机器证明技能，而本身施行起来不复杂不困难，
%%进而能被普遍地应用在现实的普通工业生产中；
%%但却能有效而彻底地证明程序实现的正确性。
%
%\subsection{智能合约}
%
%本工作最后的实现所聚焦的基于区块链技术的各种智能合约平台是一种
%安全严苛（Safety critical）\cite{DinesSE1,safety-crtical-formal-method} 场景。
%因为区块链技术与平台的特殊性，被叫做智能合约的程序一旦被部署往往就无法修改，
%进而无法更新以修复任何部署前未被发现的缺陷 \cite{swan2015blockchain}。
%而目前区块链技术与智能合约平台大量应用于金融领域，如 Bitcoin 等诸多的
%加密货币\cite{narayanan2016bitcoin}，与加密金融这一新领域\cite{came2019}。
%短短的数年以来智能合约领域已有大量的缺陷案例\cite{atzei2016survey}。
%这些缺陷往往会导致严重的经济损失。
%这些案例中，软件的设计往往是正确的而因为程序错误的实现而造成了损失。
%这凸显了验证程序实现的重要性。
%
%区块链是一种新兴的去中心化分布式技术\cite{swan2015blockchain}，
%建立在此技术上的智能合约平台允许分布式地运行一系列被叫做“智能合约”的程序
%\cite{buterin2014next}。
%基于区块链技术与智能合约技术的应用已产生了广泛的影响\cite{casino2019systematic}。
%其中以太坊 \cite{buterin2014next} 与 EOSIO \cite{eos.io} 均是
%目前商业市场上活跃的平台，本文章撰写时
%以太坊市场总值为1500亿人民币左右，EOSIO 市场总值为280亿人民币左右
%\cite{coinmarket.cap}。
%
%智能合约直接与商业业务关联，智能合约的程序实现
%上的缺陷将直接影响其业务，并可能造成严重的经济损失。
%已有大量文献研究智能合约的安全性
%\cite{dhawan2017analyzing, krupp2018teether, luu2016making, 
%suiche2017porosity, kalra2018zeus, nikolic2018finding}。
%已有诸多智能合约实现的缺陷造成了财产损失\cite{vitalik2016think, atzei2016survey}，
%包括 DAO 事件\cite{DAOattack} 造成1.5亿美元的损失，
%HackerGold 事件\cite{HackerGold} 造成 40万美元的损失，
%Rubixi 事件\cite{vitalik2016think} 造成 2万美元的损失，
%Governmental 事件\cite{vitalik2016think} 造成 1万美元的损失，
%Parity Multisig 事件\cite{ParityMultisig} 造成3千万美元的损失。
%
%且由于区块链技术本身的特点，一旦智能合约被部署就难以被修改，
%而任何部署后发现的缺陷都难以被修复。DAO 事件中，缺陷实际在数月前就被发现，
%但因缺乏有效的补救措施而未能及时修复，事件发生后以太坊不得不通过
%硬分叉来挽回攻击造成的损失，但仍造成其市值大幅下跌 \cite{EebhftrDf}。
%
%对智能合约进行形式化分析以尽可能在发布前提早发现缺陷有重要意义。
%已有大量文献利用形式化方法对智能合约进行安全研究
%Krupp 开发了程序 TEETHER 能自动发现以太坊智能合约漏洞，并进行自动渗透
%\cite{krupp2018teether}。
%Kalra 开发了程序 ZEUS 通过抽象解释与符号模型检查分析去证明一个以太坊
%智能合约的正确性并验证它的公平性 \cite{kalra2018zeus}。
%\cite{, luu2016making, 
%suiche2017porosity, kalra2018zeus, nikolic2018finding}。
%\cite{hildenbrandt2018kevm, bhargavan2016formal, hirai2017defining,
%amani2018towards, pettersson2016safer, sergey2018scilla, grishchenko2018foundations}。
%
%而测试与静态分析难以覆盖所有潜藏的缺陷。目前的智能合约都很短小，
%对其进行形式化验证相对而言并不困难，而因其特性智能合约上一切缺陷的代价
%都十分昂贵，因此值得对智能合约进行尽可能全面的形式化验证。
%如上述，若能彻底形式化地证明智能合约实现的正确性，则可自信地宣称
%此合约的实现已尽其所能的正确而不存在任何潜在的缺陷。
%
%本工作着重以智能合约应用为场景，针对 EOSIO 平台设计。
%
