\section{系统状态}

至今的论述一直未曾讨论系统状态的处理。纯粹的λ演算固然美好，但并不适于处理系统状态与副作用
（side affect），这也是为何目前学界普遍使用状态机以有效地处理指针、文件资源等系统状态。

对此 $\amlh$ 有两种方法解决。

\subsection{状态与计算分离}

第一种方案是状态与计算分离的模型，是使用请求-响应模型（Request-Response），
将程序分割成下层平台与上层计算过程两个部分，令生存期管理（Life time manage）、
数据持久化（Data persistence）由下层的平台管理，
而计算过程只负责计算响应与对状态的修改指令，在计算中无法修改系统状态，
仅是将状态修改指令输出，而后由下层平台执行再发生实际的状态改变。

\begin{figure}[!h]
\centering
\begin{tikzpicture}
    \draw [ultra thick] (1,1) rectangle (3,2);
    \draw [->, thick] (0,3) -- (1.8,2.2);
    \draw [->, thick] (1.8,0.8) -- (0,0);
    \node at (2,1.5) {平台}; \node at (1.4,3) {请求};
    \node at (1.4,0.2) {响应};
    \draw [ultra thick] (5,1.5) ellipse (1 and 0.5);
    \node at (5,1.5) {计算过程};
    \draw [->, thick] (2,2.2) to [out=45,in=125] (5,2.1);
    \draw [<-, thick] (2,0.8) to [out=-45,in=-125] (5,0.9);
    \node [right] at (5.5, 2.5) {请求与当前状态};
    \node [right] at (5.5, 0.5) {响应与状态转移指令};
    \node at (-0.5, 1.5) {执行状态转移};
    \node at (9, 1.5) {仅计算响应与状态转移指令};
\end{tikzpicture}
\caption{状态与计算分离}
\end{figure}

这其实还是构建了状态机，但将状态机中不涉及实际的状态转移的，而仅是对状态如何转移的计算，
这部分分离出来。是将状态转移抽象成一种指令，而计算部分是纯粹地对这些指令计算，计算出
根据用户逻辑当下该进行如何的状态转移并将这些转移以指令的方式输出，交给下层的平台，
再由平台实际地执行状态转移。于是对于计算过程，状态转移就退化成彻底的数值计算。

具体来说，即计算过程的输入中增加一个表示状态的只读参数，输出中增加一个状态修改指令的列表。
现在我们形式地描述这一机制。

\begin{defin}[系统状态] 逻辑类型 status 表示所有的系统状态，由具体实现具体定义。
\end{defin}

同样本节描述的{\it 状态与计算分离}也是一种框架，
根据具体应用场景可以给出不同的 status 的具体定义。
不同的 status 定义不影响{\it 状态与计算分离}理论。

\begin{defin}[状态转移] 逻辑类型 transition\_operation 表示所有系统状态转移指令，
即是各种对系统状态的修改指令。同样也是可以定制的，而后具体实现时再给出的。
唯一的要求是
\[ \abs{\mathrm{transition\_operation}} \leq \abs{\mathrm{phenomenon}} \]
这是为了之后虚构 transition\_operation 的理解。
\end{defin}

\begin{defin}[状态的理解] 
\[ (\mathbf{SI} : \mathrm{status} \rightarrow \itp{\mathrm{status}}) \coloneqq
    \mathbf{I1} \]

其中 $\mathbf{I1}$ 是样例\ref{exam.I1}中描述的单元素理解。在样例\ref{exam.I1}中
论述了，$\mathbf{I1}$ 只有一个本质元素而不会在编译结果中实质地出现。
这样以 $\mathbf{SI}$ 为理解的状态参数实质是一种伪参数，并不会在编译结果中实质地出现。

同样有如下简写记号
    \[ \mathbf{SI}\ s \coloneqq \mathbf{SI}_s \]
\end{defin}

状态的相关读取操作可以按如下框架引入。

假设 $f : \mathrm{status} \rightarrow \mathrm{some\_resource}$ 表示所期望构建的
某个状态读取操作的本质对应，亦即$f$是一个逻辑函数，将逻辑表示的状态即$status$类型表示的
逻辑结构映射到逻辑表示的某种资源，且$R$是预先构建的此资源类型的理解，
$cond : \mathrm{status} \rightarrow \mathrm{bool}$ 是某种条件且满足
    \[ \forall s.\ cond\ s \Rightarrow f\ s \in \mathbf{Se}_R \]
那么可以由虚构基元律引入满足如下性质的基元操作 $op$ 
    \[ \forall s.\ op \proctr{\mathbf{SI}_s|R}{cond} f\]

\begin{defin}[状态转移的理解] 由虚构引入 transition\_operation 的理解 $\mathbf{TI}$，
    并虚构地引入相应的构造函数。
    \[ \mathbf{V}_\mathbf{TI} \]
并利用样例\ref{exam.LI}中定义的列表理解$\mathbf{LI}$，状态转移列表的理解即是
$\mathbf{LI}\ \mathbf{TI}$，由公式 \ref{V.LI} 得到 $\mathbf{V}_\mathbf{LI\ TI}$
\end{defin}

\begin{example}[区块链环境下的示例] 假设 transition\_operation1 被如下定义。
\[ \mathrm{transition\_operation1} \Coloneqq \mathbf{WriteChain}\ \mathrm{number}\ 
    \mathrm{number}\]
且同样地假设 $\abs{\mathrm{phenomenon}} = \aleph_1$，
显然亦有 $\abs{\mathrm{transition\_operation1}} = \aleph_1$
    \[ \abs{\mathrm{transition\_operation1}} \leq \abs{\mathrm{phenomenon}} \] 
于是可以虚构定义 transition\_operation1 的理解，记为 $\mathbf{TI1}$
    \[ \mathbf{V}_\mathbf{TI1}\ \land\ (\mathbf{Se}_\mathbf{TI1} = 
    \mathrm{transition\_operation1}) \]
且虚构定义基元操作 $\mathbf{OpWriteChain}$
    \[ \mathbf{OpWriteChain} \proctr{\mathcal{N}|\mathcal{N}|\mathbf{TI1}}{\K (\K \T)}
    \mathbf{WriteChain} \]
\end{example}

\begin{defin}[响应] $\amlh$ 中的过程可以接受多个参数却只能返回一个结果，故而引入响应理解
$\mathbf{Rsp} : \itp{\alpha} \rightarrow \itp{(\alpha,\ \mathrm{transition\_operation\ list})}$
将数值结果与状态转移指令联合起来。
    \[ \mathbf{Rsp}\ i \coloneqq i \cdot (\mathbf{LI\ TI})\]
$\mathbf{Rsp}$ 并不是什么新鲜事物，仅仅是将定义\ref{Def.I*}中的理解合并包装了起来。
\end{defin}

\begin{defin}[满足状态与计算分离模型的过程] 一个过程$f_p$ 满足计算与状态分离模型当且仅当
    其具有如下形式的超越对应关系。
    \[ f_p \proctr{\cdots|\mathbf{SI}|\mathbf{Rsp}_l}{cond} f_e \]
其中 $f_e$ 的类型具有形式 $\cdots \rightarrow \mathrm{status} \rightarrow 
    (\alpha,\ \mathrm{transition\_operation\ list})$，
于是 $f_e$ 清晰地揭示出过程$f_p$ 如何对系统状态造成改变以及系统状态转移的抽象意义。
更进一步，$f_e$ 可被用于任意地对$f_p$的系统状态转移的分析与研究，且非常好用，
因为$f_e$是非常抽象的逻辑行数，自然非常适于逻辑分析。
\end{defin}

系统状态问题就被有效解决。
