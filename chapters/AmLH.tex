\chapter{Noesis 系统上的程序开发技术} \label{Ch.AmLH}

\section{Noesis 系统上程序开发原理概览} \label{Sec.Overview}

\begin{figure}[b]
  \input{./chapters/figures/amlh_rela.tex}
  \caption{朴素 Noesis 系统，\noesishol，\amlh，\amlh 上的程序，4者间
  的关系。}
  \label{fig:noe-sys-relas}
  \vspace{2mm}
\parbox{.8\linewidth}{\small\centering
\noesishol 是构建在 HOL 逻辑上的 Noesis 系统；抽象机器
  \amlh 是 \noesishol 上设定基元指令集与常量集后构成的抽象机器；
  \amlh 上的程序是基元指令与常量的组合。}
\end{figure}

\ref{Sec.noesishol} 节详细地论述了 HOL 逻辑上的 Noesis 系统 \noesishol，
这一章的讨论均在 \noesishol 上进行。

\ref{Sec.works.theoritical} 节已经简单地讨论过 Noesis 系统上的程序是常量与基元指令的复合，
这些常量与基元指令实际构成了一台抽象机器的指令集，而 \noesishol 上的程序是这台
抽象机器的程序。
一些常用的组合可以被保存，作为函数库的形式供之后的用户使用。
这台抽象机器被叫做 \amlh，图 \ref{fig:noe-sys-relas} 比较了朴素 Noesis 系统、
\noesishol、\amlh 以及 \amlh 上的程序，这四者之间的关系。

通过最底层的 HOL 定理证明器可以对 \amlh 上的程序进行各种等价变化，
这些等价变换可以是对抽象机器的符号运算——就能符号地计算 \amlh 上程序的结果；
也可以是按定义地展开——得到一段程序的常量与基元指令表达，这种表达可以作为编译过程的
中间表达（Intermediate Representation, IR）输出，交由外部的编译后端最终生成目标执行环境
上的程序。即一段程序到中间表达的编译过程，是定理证明器上的等价变换，于是到 IR 的编译
过程就是被验证的，是有保障的。

这些基元函数被巧妙的设定，利于数学分析的同时，尽可能接近目标编译平台的指令集，
那么中间表达就足够接近目标执行环境的指令集，甚至可以作为目标执行环境的一种汇编语言，
那么没有保障的编译后端的编译过程就可以非常简单，几乎是指令对指令的翻译，出错的可能性
就非常小。且编译后端的编译过程是固定的，未来可以对编译后端进行形式化验证以将
编译过程的形式化保障扩展。

这些基元指令与常量可以有两种定义方式，具体在 \ref{Sec.op-const-noesis.def} 节讨论。




%那么$\amlh$上的抽象程序到中间表达的编译过程
%实质就是将抽象程序完全展开到基元函数的表达。
%这种展开是在证明系统上进行的等价变换，
%于是编译本身是被验证的，正确性是保障到中间表达级别的。
%中间表达与目标平台的指令集是如此接近，使编译后端的功能尽可能地简单
%，以至于潜在的缺陷尽可能的少。
%且编译后端的翻译过程是固定的，
%未来可以对此进行额外的验证，就可以将保障的范围延伸。

这些基元指令虽然基础但足以构造一门编程语言与一系列的理论工具辅助，再
在定理证明器上实现这一系列辅助包括各种半自动的证明策略与分析工具，
最后在外部构建一个完整的壳层，即附录~\ref{Ch.ES}~将论述的编辑壳层\ES
，它将一切工具与接口统一起来，以此提供有效的程序开发支持。
这么做是可行的，因为传统软件工程就是这样一层层的抽象与辅助，将
用户以编程语言为格式以源代码为载体所承载的抽象思维与执行逻辑一步步翻译转换，
并最终生成目标平台上机器编码的可执行程序。
即本质上，模仿传统软件工程的体系而在数理的范畴内再实现一遍。

%这种方法的主要挑战有两点。
%首先，现实的计算机中有大量的系统状态，很多操作具有状态上的副作用。
%通用的方案是使用状态机模型而不是直接用$\lambda$演算，
%但本工作是从头基于抽象数理设计软件开发故而可以有新的思路。
%第二点是线程，状态机模型上线程可以有清晰的概念，而中则并没有。
%事实上数理思维中并没有“执行”的概念，就更没有由一系列“执行”按时间线索先后联系在一起构成的
%线程。这两点通向相同的解决道路。
%
%数理思维中没有线程，本工作认为，这是数理的一种优势。
%$\amlh$不显示地区分线程或是要求用户显示地编写线程与线程操作，相反，既然
%现在大量的软件工程实践揭示了并行编程的价值，就在一开始将$\amlh$构造成一个内在并行的系统。
%即，$\amlh$上的操作如同数学操作是自然地并行的，串行仅当数值计算上或是逻辑上的依赖时
%才会发生。如果操作$A$数值上依赖另一个操作$B$，即$A$的执行需要$B$的结果，
%则由$B$到$A$的执行是串行的；
%如果操作$A$逻辑上需要等待操作$B$完成后在进行，则需要用户显示地编写状态依赖后可以串行执行；
%如果操作$A$和$B$间既没有计算依赖又没有状态依赖，则$A$与$B$是并行执行的。
%依赖关系的存否决定并行还是串行，依赖关系的偏序方向决定串行的执行次序。
%两个线程是否可以合法地并行，又取决于各自对系统资源的访问。
%
%本工作抽象一切状态为系统资源。
%在无状态即没有系统资源的情况下，只有数值依赖；
%对于系统资源的访问，可以是数值依赖也可以是状态依赖。
%$\amlh$ 是一种并行读取互斥写入（Concurrent Read Exclusive Write, CREW）模型，
%即允许多个线程对同一个资源的同时读取却只允许同一时刻一个线程写入资源。
%这里的写入与读取不需要是真正的写入或读取，理解为可并行的操作与互斥操作也许更好。
%两个线程的并行是否合法即是对资源的访问是否满足CREW。
%系统资源与依赖，这两个问题很相关，将在\ref{Sec.hisFlow}节的历史流模型中详细论述。
%
%另外值得注意的，至今为止所说的并行并不要求编译结果也严格地遵守并行。
%串行的程序很难并行执行而并行的程序是很容易串行执行的。
%$\amlh$上的软件开发从设计到编写再到最后编译出中间表达是始终保持并行的，
%但对中间表达最后到目标平台的编译可以根据具体实现自由地选择串行或者部分并行。


%有助于读者直观地感受，尽管其中一些无法绕过的概念与引理尚未给出。
%这些主要是系统状态相关的历史流理论，会在下一节给出论述，而现在将暂时搁置。

\input{./chapters/noesis/machine.tex}
\input{./chapters/AmLH/example.tex}
\input{./chapters/AmLH/AmLH.status.tex}


