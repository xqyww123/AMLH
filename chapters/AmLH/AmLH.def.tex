\section{$\amlh$的形式定义}

接下来本文一步步给出$\amlh$的形式定义。
首先是基于$\lamst$的且无状态纯粹数值计算的抽象机$\aml$，
然后将$\aml$实现在HOL定理证明器的HOL逻辑上，
$\aml$在HOL上的实现根据抽象级别的高低有两个版本，
粗粒度抽象机$\amlhC$与细粒度抽象机$\amlhF$，最后几节将分别论述其实现。

\input{./chapters/AmLH/AmL.def.tex}
\subsection{$\amlh$}

$\aml$ 只是纯粹基于字符串的形式系统。仅有的字符串理论实在太过单薄，更多巧妙的设计无以构建。

接下来本文论述 $\amlh$，它也是一种形式系统，是 HOL 逻辑的扩广，即有

\[ \mathrm{HOL} \subseteq \amlh \]

这种扩广以对于 HOL 逻辑合法的方式进行，HOL 逻辑上的证明工具依旧可以用于 $\amlh$ 上并对
$\amlh$ 上的表达进行证明；而这种扩广又允许类似$\aml$地构造程序以允许其上的软件开发。

需要注意的是 $\amlh$ 是一种形式系统的框架，一些设定是未具体定义而允许定制的，可以
构造不同版本的 $\amlh$ 实现。本文将研究两种$\amlh$的实现，高抽象层级粗粒度的
$\amlhC$ 与地抽象层级细粒度的 $\amlhF$

\begin{defin}[现象类型] 类型 phenomenon 表示 $\aml$ 上的计算客体，根据不同的$\aml$实现可以
    以不同方式具体定义，不同的具体定义不影响本节理论。

唯独特别的，phenomenon 类型中需要包含一个特别的零元素$\mathrm{p}_0$，表示
计算客体中不需要被任何实在的现象表示而自然地于背景中存在的，
例如0个二进制位或者C语言的void类型。
\end{defin}

\subsection{理解与超越对应}

\begin{defin}[到$\alpha$的理解] \label{Def.itp} 类型 $\itp{\alpha}$ 是现象到
    具有类型 $\alpha$ 的本质的理解，包含可以构建现象与本质间联系的映射。
    \begin{equation} \begin{split}
        \itp{\alpha} \Coloneqq \mathbf{Interpretation}\ &(\alpha \rightarrow \phenomenon)
        \ (\phenomenon \rightarrow \alpha)\\
        &(\alpha\ \mathrm{set})\ (\phenomenon\ \mathrm{set})
    \end{split} \end{equation}
    \begin{align*}
        \mathbf{ITP\_LIGHT}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = l \\
        \mathbf{ITP\_TRANSCEND}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = tr \\
        \mathbf{ITP\_SET}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = s \\
        \mathbf{ITP\_PSET}\ (\mathbf{Interpretation}\ l\ tr\ s\ s_p) & = s_p
    \end{align*}
\end{defin}

$\itp{\alpha}$ 表示一个将现象对应为某种 $\alpha$ 类型的本质的理解。
例如现象到布尔值间的超越映射就要届由到 bool 类型的理解来完成。
$\mathbf{Interpretation}\ l\ tr\ s\ s_p$ 构建了这样一个理解，$l$是投影函数，确定本质到
现象的映射；$tr$ 是超越函数，确定现象到本质的映射；$s$ 是本质集合，
有 $s \subseteq \mathrm{dom}\ l \land s \subseteq \mathrm{rng}\ tr$；
$s_p$ 是现象集合，有 $s_p \subseteq \mathrm{dom}\ tr \land s_p \subseteq \mathrm{rng}\ l$
，一个理解即是上述的四元组。


\begin{notation}[理解的相关属性的简写记号]
\begin{align*}
    \mathbf{Li}_i\ & \coloneqq \mathbf{ITP\_LIGHT}\ i
    & \mathbf{Tr}_i\ & \coloneqq \mathbf{ITP\_TRANSCEND}\ i \\
    \mathbf{Se}_i\ & \coloneqq \mathbf{ITP\_SET}\ i
    & \mathbf{Sp}_i\ & \coloneqq \mathbf{ITP\_PSET}\ i
\end{align*}
\end{notation}

\begin{defin}[到$\alpha$的有效理解] \label{Def.Vi}
\[ \begin{split}
    \mathbf{VALID\_ITP}\ i \coloneqq\ &
    (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e)) \\
    & \land\ (\forall p.\ p \in \mathbf{Sp}_i \Rightarrow \mathbf{Tr}_i\ p \in 
    \mathbf{Se}_i)
\end{split} \]
\end{defin}

\begin{notation}[有效理解的简写]
    \[ \mathbf{V}_i \coloneqq \mathbf{VALID\_ITP}\ i \]
\end{notation}

即 $\mathbf{V}_i$ 意味着 $\mathbf{Li}_i$ 是 $\mathbf{Se}_i$ 到 $\mathbf{Sp}_i$ 的单射，
$\mathbf{Tr}_i$ 是 $\mathbf{Sp}_i$ 到 $\mathbf{Se}_i$ 的满射，
$\mathbf{Tr}_i$ 是 $\mathbf{Li}_i$ 的逆函数。

\begin{example}[到bool的有效理解的样例]
\[ \begin{split}
    \mathbb{B}_\mathrm{I} \coloneqq\ & \mathbf{Interpretation}\ (\lambda e.\ \mathbf{if}\ e\ 
    \mathbf{then}\ 1\ \mathbf{else}\ 0) \\
& (\lambda p.\ \mathbf{if}\ p=0\ \mathbf{then}\ \mathrm{F}\ \mathbf{else}\ \mathrm{T})\quad
   \{\mathrm{T},\ \mathrm{F}\}\quad \mathbb{N}
\end{split} \]
\end{example}

\begin{defin}[超越对应关系] \label{Def.TR}
定义三元关系 $ p \widesim{i} e$ 表示现象与本质在某种理解下的的对应关系。
\begin{equation}
    p \widesim{i} e \coloneqq \mathbf{V}_i \land p \in \mathbf{Sp}_i \land
    (\mathbf{Tr}_i\ p = e)
\end{equation}
\end{defin}

某个成立的超越对应关系可以用 HOL 逻辑证明，或者以形式系统的角度去说，
可以用HOL逻辑的一系列规则得到某个成立的超越关系。

\begin{prooftree}
    \AxiomC{$\cdots$} 
    \RightLabel{对于某个成立的 $p \widesim{i} e$\quad\quad(超越对应的证明律)} \doubleLine
    \UnaryInfC{$\vdash p \widesim{i} e$}
\end{prooftree}

由此构建了程序的语义感知（Semantic Reasoning）的基础，即在理解方式$i$下可以将
计算客体$p$解释成$e$，而$e$即$p$在理解方式$i$下的语义。

一个现象对于一个理解只有确定的一个本质，但一个现象可以同时具有多种理解，
而现象上的一次计算可以同时带有多个含义。例如现象1可以在布尔理解下对应真，
也可以在自然数理解下对应自然数1，也可以是某种有序集的理解下的第一个元素。

%\begin{theo}[超越关系的一些性质]
%\begin{align*}
%  \forall p\ i\ e.\ p \widesim{i} e \Rightarrow
%    e \in \mathbf{Se}_i
%\end{align*}
%\end{theo}
%\begin{proof} 由定义 \ref{Def.Vi} 直接得到。
%\end{proof}

\begin{defin}[理解的合并] \label{Def.I*}
一个到 $\alpha$ 的理解$i_a$与到 $\beta$ 的理解$i_b$可以合并成
    到二元组$(\alpha,\beta)$的理解 $i_a \cdot i_b$
\[
    \forall l_a\ l_b\ a\ b.\ (l_a\ a = l_b\ b) \Rightarrow
    (\dot{\mathbf{l}}\ l_a\ l_b\ a\ b = l_a\ a )
\]
\begin{equation} \begin{split}
    (\mathbf{Interpretation}\ & l_a\ tr_a\ s_a\ sp_a)\ \cdot\ 
    (\mathbf{Interpretation}\ l_b\ tr_b\ s_b\ sp_b) \coloneqq \\
    & \mathbf{Interpretation}\ (\dot{\mathbf{l}}\ l_a\ l_b)\ 
        (\lambda p.\ (tr_a\ p,\ tr_b\ p))\ \\
    & \quad\quad\quad (s_a \times s_b \cap (\lambda (a,\ b).\ l_a\ a = l_b\ b))\ 
    (sp_a \cap sp_b)
\end{split} \end{equation}
\end{defin}

这样合并的意义在于，多个基于不同理解的超越关系，可以将这些不同的理解合并而表示为一个超越关系。

\begin{theo}[理解合并的有效性] \label{T.V.IMerge}
\begin{equation}
    \mathbf{V}_a \land \mathbf{V}_b \Rightarrow \mathbf{V}_{a\cdot b}
\end{equation}
\end{theo}
\begin{proof}
\begin{align*}
    \mathbf{V}_{a\cdot b} =\ & (\forall e_a\ e_b.\ e_a \in \mathbf{Se}_a \ \ \land \ \ 
    e_b \in \mathbf{Se}_b \ \ \land \ \ 
    (\mathbf{Li}_a\ e_a = \mathbf{Li}_b\ e_b) \ \ \Rightarrow \\
    & \quad\quad\quad \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \cap \mathbf{Sp}_b \ \ \land
    \ \ (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a) \ \ \land \ \ 
    (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_a \ \ \land \ \ p \in \mathbf{Sp}_b
    \Rightarrow \mathbf{Tr}_a\ p \in \mathbf{Se}_a \ \ \land \ \ \mathbf{Tr}_b\ p \in 
      \mathbf{Se}_b ) \\
    \mathbf{V}_a =\ & (\forall e_a.\ e_a \in \mathbf{Se}_a \Rightarrow
      \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \ \ \land \ \ 
      (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_a \Rightarrow \mathbf{Tr}_a\ p \in 
      \mathbf{Se}_a) \\
\mathbf{V}_b =\ & (\forall e_b.\ e_b \in \mathbf{Se}_b \Rightarrow
      \mathbf{Li}_b\ e_b \in \mathbf{Sp}_b \ \ \land \ \ 
      (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_b \Rightarrow \mathbf{Tr}_b\ p \in
      \mathbf{Se}_b) \\
\mathbf{V}_a,\ & \mathbf{V}_b,\ e_a \in \mathbf{Se}_a,\ e_b \in \mathbf{Se}_b,\ 
    \mathbf{Li}_a\ e_a = \mathbf{Li}_b\ e_b \ \vdash \ 
    \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \cap \mathbf{Sp}_b \\
    & \quad\quad\quad\quad \land (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a) \land
    (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b) \\
\mathbf{V}_a,\ & \mathbf{V}_b,\ p \in \mathbf{Sp}_a,\ p \in \mathbf{Sp}_b\ \vdash\ 
    \mathbf{Tr}_a\ p \in \mathbf{Se}_a\ \ \land \ \ \mathbf{Tr}_b\ p \in \mathbf{Se}_b \\
\mathbf{V}_a,\ &\mathbf{V}_b \vdash \mathbf{V}_{a \cdot b}
\end{align*}
\end{proof}

\begin{theo}[理解合并对于超越对应的同构]
\begin{equation}
    \forall i_a\ i_b\ p\ e_a\ e_b.\ p \widesim{i_a} e_a \land p \widesim{i_b} e_b = 
    p \widesim[2]{i_a \cdot i_b} (e_a,\ e_b) 
\end{equation}
\end{theo}

\begin{proof}
\[ p \widesim[2]{ia \cdot ib} (e_a,\ e_b) =\ \mathbf{V}_{ia\cdot ib} \land p \in 
    (\mathbf{Sp}_{ia} \cap \mathbf{Sp}_{ib}) \land 
    (\mathbf{Tr}_{ia}\ p = e_a) \land (\mathbf{Tr}_{ib}\ p = e_b) \]
结合定义\ref{Def.TR}以及理解合并的有效性定理\ref{T.V.IMerge}
\[p \widesim[2]{ia \cdot ib} (e_a,\ e_b) = p \widesim{i_a} e_a \land p \widesim{i_b} e_b \]
\end{proof}

由合并的理解的超越对应关系就可以提取出其中各个理解的超越对应。

\begin{gather*}
    p \widesim{i_1 \cdot i_2} (e_1,\ e_2) \Rightarrow p \widesim{i_1} e_1 \\
    p \widesim{i_1 \cdot i_2} (e_1,\ e_2) \Rightarrow p \widesim{i_2} e_2
\end{gather*}

\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
    \RightLabel{(合并分解律1)}
\UnaryInfC{$\Gamma \vdash p \widesim{i_1} e_1$}
\end{prooftree}
\end{minipage}%
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
    \RightLabel{(合并分解律2)}
\UnaryInfC{$\Gamma \vdash p \widesim{i_2} e_2$}
\end{prooftree}
\end{minipage}

\begin{prooftree}
\AxiomC{$\Gamma_1 \vdash p \widesim{i_1} e_1$}
\AxiomC{$\Gamma_2 \vdash p \widesim{i_2} e_2$}
    \RightLabel{(合并律)}
\BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
\end{prooftree}

\begin{theo}[理解合并在超越对应上的交换律同构与结合律同构]
\begin{gather}
    \forall e_a\ e_b\ i_a\ i_b\ p.\ p \widesim[2]{i_a \cdot i_b} (e_a,\ e_b) =
        p \widesim[2]{i_b \cdot i_a} (e_b,\ e_a) \\
    \forall e_a\ e_b\ e_c\ i_a\ i_b\ i_c\ p.\ p \widesim[4]{(i_a \cdot i_b) \cdot i_c}
    ((e_a,\ e_b),\ e_c) = p \widesim[4]{i_a \cdot (i_b \cdot i_c)} (e_a,(e_b,\ e_c))
\end{gather}
\end{theo}

\begin{proof} 显然，略
\end{proof}


\begin{defin}[过程的超越对应关系] \label{def.proctr}
定义4元符号 $f_p \proctr{i}{cond} f_e$ 表示有条件的值的超越对应。
定义5元符号 $f_p \proctr{i|j}{cond} f_e$ 表示1个参数的且以
$cond$为条件的过程的超越对应，$n+3$ 元符号
$f_p \proctr{i_1 | \cdots | i_n}{cond} f_e$ 表示 $n$ 个参数的过程的且条件为
$cond$的超越对应。

\begin{equation} \begin{split}
    p \proctr{i}{cond} e \coloneqq &\ (cond \Rightarrow p \widesim{i} e) \\
    (f_p:\mathrm{phenomenon}\rightarrow\mathrm{phenomenon})\ & \proctr{i|j}{cond}
    (f_e:\alpha \rightarrow \beta) \coloneqq \\
    (\forall a_p\ a_e.\quad & a_p \widesim{i} a_e \Rightarrow cond\ a_e \Rightarrow
    f_p\ a_p \widesim{j} f_e\ a_e) \\
    (f_p:\mathrm{phenomenon}\rightarrow \cdots \rightarrow \mathrm{phenomenon})\ & 
    \proctr{i | \cdots | l}{cond}
    (f_e:\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow \delta) \coloneqq \\
    (\forall a_p\ a_e \cdots c_p\ c_e.\quad a_p \widesim{i} a_e \Rightarrow &
    \ b_p \widesim{j} b_e \Rightarrow \cdots \Rightarrow cond\ a_e\ \cdots\ c_e 
    \Rightarrow  \\
    & f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e)
\end{split} \end{equation}

    $cond$ 表示过程执行前的条件。

    对于$\proctr{i | \cdots | k | l}{cond}$ 若理解
    $i, \cdots, k$ 的类型分别为 $\itp{\alpha},\ \cdots,\ \itp{\gamma}$，
    那么 $cond$ 的类型为 $\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow 
    \mathrm{bool}$，即 $cond$ 是在本质层面上描述执行条件。

    过程的超越对应构成了一种契约，在输入参数可以被约定的理解$i,\cdots,k$解释，
    且解释后的意义也即本质$a_e,\cdots,c_e$满足给定的条件，
    那么此过程可以正确执行并返回以约定的理解$l$的解释下对应本质$f\ a_e\ \cdots\ c_e$ 的输出

\end{defin}

上述定义具有如下的递归形式。

\begin{equation} \label{f.proctr_rec} \begin{split}
    f_p \proctr{i|j|\cdots|l}{cond} f_e = (\forall a_p\ a_e.\quad
      a_p \widesim{i} a_e \Rightarrow f_p\ a_p \proctr{j|\cdots|l}{cond\ a_e} f_e\ a_e)
\end{split} \end{equation}

\begin{theo}[$\amlh$上的组合律与抽象律]
类似$\lamst$ 的组合律与抽象律，$\amlh$ 上也有如下推导律。

\begin{prooftree}
    \AxiomC{$\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e$}
    \AxiomC{$\Gamma_2 \vdash a_p \widesim{i} a_e$}
    \RightLabel{(组合律)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash f_p\ a_p \proctr{j|\cdots|l}{cond\ a_e}
      f_e\ a_e$}
\end{prooftree} 

\begin{prooftree}
    \AxiomC{$\Gamma_1,\ a_p \widesim{i} a_e \vdash b_p \proctr{j|\cdots|l}{cond} b_e$}
    \RightLabel{(抽象律)}
    \UnaryInfC{$\Gamma_1 \vdash (\lambda a_p.\ b_p)
      \proctr{i|j|\cdots|l}{\lambda a_e.\ cond\ a_e} (\lambda a_e.\ b_e)$}
\end{prooftree}

\begin{minipage}[b]{0.4\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma, cond \vdash p \widesim{i} e$}
    \RightLabel{(条件律)}
    \UnaryInfC{$\Gamma \vdash p \proctr{i}{cond} e$}
\end{prooftree}\end{minipage}%
\begin{minipage}[b]{0.4\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma_1 \vdash p \proctr{i}{cond} e$}
    \AxiomC{$\Gamma_2 \vdash cond$}
    \RightLabel{(条件消去律)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash p \widesim{i} e$}
\end{prooftree}\end{minipage}
\end{theo}

\begin{proof} 由定义 \ref{def.proctr}，递归公式 \ref{f.proctr_rec}，应用
    \ref{Sec.HOL} 节中介绍的HOL逻辑上的 MATCH\_MP 律、DISCH 律、GEN 律直接得到。
\end{proof}

类似 $\lamst$，组合律与条件消去律允许过程的调用，抽象律与条件律允许过程的创建。

上文的类型证明律、合并率、组合律、抽象律已经充分地揭示理解及超越对应
如何为 $\amlh$ 实现了类型系统的功能，但理解与超越对应绝对\textbf{不是}一种类型系统。
最主要的问题，类型归属关系一定是个二元关系，但超越对应是三元的。尽管可以把理解与本质合并
为二元组而将超越对应退化为二元关系，但如此一来，这所谓的类型就仅有一个实例，这就破坏了
上述的组合律与抽象律，进而破坏了类型演算。三元的超越对应是自然的。

又也许理解可以尝试地作为这样一种类型，但问题在于，任何一个现象都可以被应用于大量的理解
——只要现象在理解的现象集内就行，若尝试将理解作为类型，就意味着每一个现象都可以属于大量的类型，
这显然是荒谬的。

本文对所有将超越对应描述成某种类型系统的尝试都失败了。根本在于，类型是一种对值的分类，
以良好地提取维护值的部分性质；
但本文的思路，超越对应根本不尝试对值分类，而是尝试显示地确定理解方式而找到值对应的以某种
数理结构表示的意义，进而提取出值在该理解下的全部性质。
这与与指称语义（Denotational semantics）非常相似。

指称语义尝试建立起程序与数学函数的对应关系，跟超越对应非常相似。
但$\amlh$的优势在于程序的抽象，基于$\lamst$使得程序本身亦是抽象的结构。
这导致一些重要的区别，指称语义在递归定义的函数与数据结构上遇到的困难带领指称语义
走向了域理论，而对于$\amlh$，不使用域理论而
是在？？？节将看到递归与归纳（Induction）间的内在联系。
指称语义与超越对应尝试实现类似的目标，但解决思路与方式完全不同。

超越对应与 Curry-Howard 同构似乎也有密切的联系，超越对应关系同时是一种定理又可以被理解一种
近似的类型从属关系，这与 Curry-Howard 同构中的类型从属与定理间的对应关系非常相似。
但问题在于，超越对应不是类型关系，超越对应的机制不是类型系统，就难以将Curry-Howard 同构的任何理论联系于此。直觉上超越对应与 Curry-Howard 同构一定有着某种联系，但本文未能成功发掘。

最后看到，超越对应实际完成了$\amlh$上类型系统的功能，又不是一种类型系统，
所以严格来说超越对应是$\amlh$上对类型系统的替代。而严格来讲$\amlh$上现象只有一种类型，
phenomenon，而$\amlh$的围绕编程的类型系统（特别注意不是证明系统的类型系统）就是只有
一种 phenomenon 类型的简单类型$\lambda$演算$\lamst$。

\subsection{基元指令（Primitive Operations）} \label{Sec.Op}

基元指令有两种引入方法。第一种是基于现象的定义，编写现象上的函数，具体地给出定义，
再证明此函数满足某个或者某一些超越对应，一个确定的现象函数可以具有多个意义继而
拥有多个超越对应关系。
第二种是根据预先确定的超越对应关系，不给出明确的函数体，而是
证明对于确定的超越关系存在一个现象函数满足此对应关系，进而由此引入。
事实上可以证明，对于任意的超越对应关系，只要满足一些很容易的条件，
就一定存在一个现象函数满足此对应关系。
进而基元指令实际根本不用具体地描述计算过程，可以根据其意义直接引入。
而基元指令也根本不需要确定具体的计算为何，输出的现象具体如何表达，只要得到了超越对应定理，
就可以直接由组合律去使用。

\begin{theo}(基元虚构定理)
给定所期望的本质$f_e$，参数的理解$i\ \cdots\ k$，返回值的理解$l$，过程执行的条件$cond$，
只要 $l$ 有效，且 $cond$ 足以限定返回值的本质$f_e\ a_e\ \cdots\ c_e$到其理解$l$的本质集
$\mathbf{Se}_l$内，则必定存在一个现象上的过程 $f_p$，且满足期望的超越对应关系。

\[ \begin{split} \forall f_e\ i\ \cdots\ k\ l\ cond.\ 
 \mathbf{V}_l\ \land\ &\\
    (\forall a_e\ \cdots\ c_e.\ \mathbf{V}_i\ & \land a_e \in \mathbf{Se}_i \land \cdots
\land \mathbf{V}_k \land c_e \in \mathbf{Se}_k \land cond\ a_e\ \cdots\ c_e\ \Rightarrow\\
    & f\ a_e\ \cdots\ c_e \in \mathbf{Se}_l) \Rightarrow\\
    & \exists f_p.\ f_p \proctr{i|\cdots|k|l}{cond} f_e
\end{split} \]
\end{theo}

在证明前首先引入它在没有参数时的特例，即常量虚构定理

\begin{theo}[常量虚构定理] \label{T.Vconst}
\[ \forall i\ e.\ \mathbf{V}_i \Rightarrow e \in \mathbf{Se}_i \Rightarrow
  \exists p.\ p \widesim{i} e \]
\end{theo}
\begin{proof} \begin{gather*}
p \widesim{i} e = \mathbf{V}_i \land p \in \mathbf{Sp}_i \land (\mathbf{Tr}_i\ e = p) \\
\mathbf{V}_i \Rightarrow (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e)) \\
\mathbf{V}_i \Rightarrow (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \widesim{i} e)
\end{gather*}

即，命题得证，存在 $p = \mathbf{Li}_i\ e$

\end{proof}

\begin{proof}[(基元虚构定理)]

令 $x_p = f_p\ a_p\ \cdots\ c_p\ ;\ x_e = f_e\ a_e\ \cdots\ c_e$

$P_{cond} = (\forall a_e\ \cdots\ c_e.\ \mathbf{V}_i\ \land a_e \in 
\mathbf{Se}_i \land \cdots
\land \mathbf{V}_k \land c_e \in \mathbf{Se}_k \land cond\ a_e\ \cdots\ c_e\ \Rightarrow
    f\ a_e\ \cdots\ c_e \in \mathbf{Se}_l)$

$\Gamma_\sim = \{a_p \widesim{i} a_e,\ \cdots\ ,\ c_p \widesim{k} c_e,\ cond\ x_e,\ 
\mathbf{V}_l,\ P_{cond} \}$

\begin{prooftree}
\AxiomC{$\Gamma_\sim \vdash P_{cond}$}
\AxiomC{$a_p \widesim{i} a_e \vdash \mathbf{V}_i \land a_e \in \mathbf{Se}_i$}
\AxiomC{$\cdots$}
\AxiomC{$c_p \widesim{i} c_e \vdash \mathbf{V}_i \land c_e \in \mathbf{Se}_i$}
\QuaternaryInfC{$\Gamma_\sim \vdash x_e \in \mathbf{Se}_l \land \mathbf{V}_l$}
\RightLabel{(常量虚构定理)}
\UnaryInfC{$\Gamma_\sim \vdash \exists p.\ p \widesim{i} x_e$}
\UnaryInfC{$\Gamma_\sim \vdash \exists f_p.\ f_p\ a_p\ \cdots\ c_p \widesim{i} f_e\ a_e\ \cdots c_e$}
\UnaryInfC{$\mathbf{V}_l,\ P_{cond} \vdash \exists f_p.\ 
    f_p \proctr{i|\cdots|k|l}{cond} f_e$}
\UnaryInfC{$\forall f_e\ i\ \cdots\ k\ l\ cond.\ 
\mathbf{V}_l\ \land\ P_{cond} \Rightarrow 
    \exists f_p.\ f_p \proctr{i|\cdots|k|l}{cond} f_e$}
\end{prooftree}
\end{proof}

由基元虚构定理，可以任意的引入具有期望意义的基元指令。而基元指令也根本不需要考虑
具体如何对现象计算，因为编译只需要给出程序以基元指令组合而成的表达，基元指令的具体
计算过程是根本不需要的。这一点意味着 $\amlh$ 极为强大的适应能力，可以任意自由地定义指令集，
进而构造出各种各样的抽象机器，用于各种各样的场合。

第一种，构造现象函数然后证明其超越对应的方法表述为基元证明律；第二种利用基元虚构定理
引入具有特定超越对应的基元函数的方法表述为基元虚构律。

\begin{minipage}[b]{0.4\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma_1 \vdash \mathbf{V}_i$}
    \AxiomC{$\Gamma_2 \vdash e \in \mathbf{Se}_i$}
    \RightLabel{常量虚构律}
    \BinaryInfC{$\Gamma_1,\ \Gamma_2 \vdash \exists p.\ p \widesim{i} e$}
\end{prooftree}\end{minipage}%
\begin{minipage}[b]{0.4\linewidth} \begin{prooftree}
    \AxiomC{$\cdots$}
    \RightLabel{基元证明律}
    \UnaryInfC{$\vdash f_p \proctr{i|\cdots|k|l}{cond} f_e$}
\end{prooftree}\end{minipage}

{\center \begin{prooftree}
    \AxiomC{$\vdash \mathbf{V}_l$}
    \AxiomC{$\vdash \forall a_e\ \cdots\ c_e.\ cond\ a_e\ \cdots\ c_e \Rightarrow
      \mathbf{Se}_l\ (f\ a_e\ \cdots\ c_e)$}
    \RightLabel{基元虚构律}
    \BinaryInfC{$\vdash \exists f_p.\ f_p \proctr{i|\cdots|k|l}{cond} f_e$}
\end{prooftree}}

而虚构基元的两个条件，结果的理解的有效性与条件足够约束结果的本质落入结果理解的本质集中，
都非常容易，且一般都成立。

\begin{theo}[过程的超越对应的条件的充分性]  \label{T.ptr.enough}
\[ \begin{split}
\forall f_p\ i\ &\cdots\ k\ l\ cond\ f_e.\ f_p \proctr{i|\cdots|k|l}{cond} f_e 
\Rightarrow\\ & \forall a_e\cdots c_e.\ \mathbf{V}_i \land a_e \in \mathbf{Se}_i
    \land \cdots \land \mathbf{V}_k \land c_e \in \mathbf{Se}_k \land
    cond\ a_e\ \cdots\ c_e \Rightarrow \\
    & \quad\quad\quad\quad f_e\ a_e\ \cdots\ c_e \in \mathbf{Se}_l
\end{split} \]
\end{theo}
\begin{proof}
\[\begin{split} f_p \proctr{i|\cdots|k|l}{cond} f_e = (\forall &a_e\ a_p\ \cdots c_e\ c_p.\
    a_p \widesim{i} a_e \ \Rightarrow \cdots \Rightarrow c_p \widesim{i} c_e \Rightarrow\\
    & cond\ a_e\cdots\ c_e \Rightarrow f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ 
c_e) \end{split} \tag{1} \]
令 $a_p = \mathbf{Li}_i\ a_e,\ \cdots,\ c_p = \mathbf{Li}_k\ c_e$，
由定义\ref{Def.TR}在前提 $\mathbf{V}_i \land a_e \in \mathbf{Se}_i
    \land \cdots \land \mathbf{V}_k \land c_e \in \mathbf{Se}_k$ 下有
    \[ a_p \widesim{i} a_e \land \cdots \land c_p \widesim{k} c_e \]
带入(1)并结合前提$cond\ a_e\cdots\ c_e$ 得到
    \[ f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e \]
由定义\ref{Def.TR}
    \[ f_e\ a_e\ \cdots\ c_e \in \mathbf{Se}_l \]
\end{proof}

\subsection{虚构理解}

基元虚构定理带来了非常好的启发，理解也可以被类似地虚构地引入，而完全不给出任何具体的细节。
这一点是通过同构实现的。

\begin{defin}[单射的定义] \label{Def.INJ}
\[
    \mathbf{INJ}\ f\ S\ T \coloneqq (\forall s.\ s \in S \Rightarrow f\ s \in T) \land
    (\forall s_1\ s_2.\ s_1 \in S \land s_2 \in S \land (f\ s_1 = f\ s_2) \Rightarrow
    s_1 = s_2)
\]
\end{defin}
\begin{lemma}[单射存在逆函数] \label{L.inji}
\[ \forall f\ S\ T.\ \mathbf{INJ}\ f\ S\ T \Rightarrow \exists g.\ (\forall t.\ t \in T
    \Rightarrow g\ t \in S) \ \land\ (\forall s.\ s \in S \Rightarrow
    g(f(s)) = s) \]
\end{lemma}
\begin{defin}[势的偏序关系的定义] \label{Def.Card}
    \[ \abs{A} \leq \abs{B} \coloneqq (\exists f.\ \mathbf{INJ}\ f\ A\ B) \]
\end{defin}

\begin{theo}[理解虚构定理]
\[ \forall S_e. \abs{S_e} \leq \abs{\mathrm{phenomenon}} \Rightarrow
    \exists i.\ \mathbf{V}_i\ \land\ (\mathbf{Se}_i = S_e) \]
\end{theo}
\begin{proof}
在假设 $\abs{S_e} \leq \abs{\mathrm{phenomenon}} $ 下，由定义 \ref{Def.Card} 得到
由$S_e$到现象的单射$f$，再由引理$\ref{L.inji}$得到逆函数$g$，记单射$f$的值域为
$S_p = \Im f$，有：
\[ \forall e.\ e \in S_e \Rightarrow f\ e \in S_p \land g(f\ e) = e  \tag{1} \]
\[ \forall p.\ p \in S_p \Rightarrow g\ e \in S_e \tag{2} \]
令 $i = \mathbf{Interpretation}\ f\ g\ S_e\ S_p$ 现只需证明 $\mathbf{V}_i$ 即可。
\[ \mathbf{V}_i = (\forall e.\ e \in S_e \Rightarrow f\ e \in S_p \land
    f(g(e)) = e)\ \land\ (\forall p.\ p \in S_p \Rightarrow g\ p \in S_e) \]
由(1)，(2) 这是显然的。
\end{proof}

一般而言$\amlh$的实现中现象集是同构于自然数集的一阶无穷，这就给$S_e$的选择带来很大的空间。
事实上任何计算机实际可触及的意义，或者说计算机上可表示的概念，一定是有限的，因为计算机的
内存是有限的，于是$S_e$是有限的；而即便抛开内存的限制，需要去表示的概念也往往是一阶无穷。
这些一阶无穷集包括一阶无穷集上的列表、树结构、映射表等多种数据结构。

借助理解虚构定理，可以直接引入到期望本质集上的理解。尽管不给出理解的具体映射方式意味着
不可能直接证明某个现象在该理解下的超越对应，但依旧可以用\ref{Sec.Op}节论述的虚构基元指令
与虚构常量的方式引入关于此虚构理解的基元指令。

即，而可以为虚构的理解引入一系列虚构常量与虚构基元指令，以允许照常如旧地应用 $\amlh$

下一节给出对列表的虚构理解作为样例。

