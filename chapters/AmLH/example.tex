\section{案例分析}
\subsection{列表的理解}

这一节给出虚一个构理解与虚构基元的具体案例，列表的理解，具有实际意义。

\begin{lemma}[单射与子集] \label{L.inj_subset}
    \[ \forall f\ S\ T_1\ T_2.\ T_1 \subseteq T_2 \Rightarrow \mathbf{INJ}\ f\ S\ T_1
    \Rightarrow \mathbf{INJ}\ f\ S\ T_2\]
\end{lemma}
\begin{proof} 基础的数学定理，略。
\end{proof}
\begin{lemma}[有效理解的投影是单射] \label{L.i.inj}
\[ \mathbf{V}_i \Rightarrow \mathbf{INJ}\ \mathbf{L}_i\ \mathbf{Se}_i\ \mathbf{Sp}_i \]
\end{lemma}
\begin{proof} 

\begin{align*}
& \text{由定义} \ref{Def.Vi} && \mathbf{V}_i \Rightarrow \ 
    (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e)) & (1) \\
& \text{只需证明} && \mathbf{V}_i,\ e_1 \in \mathbf{Se}_i,\ e_2 \in \mathbf{Se}_i,\ 
    \mathbf{Li}_i\ e_1 = \mathbf{Li}_i\ e_2\ \vdash\ e_1 = e_2 & \\
& \text{显然有} && \mathbf{V}_i,\ e_1 \in \mathbf{Se}_i,\ e_2 \in \mathbf{Se}_i,\ 
    \mathbf{Li}_i\ e_1 = \mathbf{Li}_i\ e_2\ \vdash
    \mathbf{Tr}_i(\mathbf{Li}_i\ e_1) = \mathbf{Tr}_i(\mathbf{Li}_i\ e_2) & \\
& \text{由 (1)} && \mathbf{V}_i,\ e_1 \in \mathbf{Se}_i,\ e_2 \in \mathbf{Se}_i,\ 
    \mathbf{Li}_i\ e_1 = \mathbf{Li}_i\ e_2\ \vdash e_1 = e_2 &
\end{align*} \end{proof}
\begin{theo}[理解的 phenomenon 可数性]\label{TI.countable}
    \[ \forall i.\ \mathbf{V}_i \Rightarrow \abs{\mathbf{Se}_i} \leq
    \abs{\mathrm{phenomenon}} \]
\end{theo}
\begin{proof} 
\begin{align*}
& \text{由定义 \ref{Def.Card} 只需证明} && \mathbf{V}_i \vdash
  \exists f.\ \ \mathbf{INJ} \ \ f\ \ \mathbf{Se}_i\ \ \mathrm{phenomenon}& \\
& \text{由引理 \ref{L.i.inj}} && \mathbf{V}_i \vdash \mathbf{INJ}\ \mathbf{L}_i\ 
    \mathbf{Se}_i\ \mathbf{Sp}_i & (1) \\
& \text{显然有} && \vdash \mathbf{Sp}_i \subseteq \mathrm{phenomenon} & (2) \\
& \text{由引理 \ref{L.inj_subset}，(1)，(2)} && \mathbf{V}_i \vdash \mathbf{INJ}\ 
    \mathbf{L}_i\ \mathbf{Se}_i\ \mathrm{phenomenon}&
\end{align*}
\end{proof}

\begin{example}[以虚构方式引入列表理解] \label{exam.LI}
现在假设 $\abs{\mathrm{phenomenon}} = \aleph_1$，
即现象集同构于自然数集。先如下递归定义集合$S$上的列表$\mathbf{List}_S$集
\[ \begin{split} \mathbf{List}_S\ [\ ]\ & = T \\
\mathbf{List}_S\ [x_1,x_2,\cdots,x_n]\ & = x_1 \in S \land \mathbf{List}_S\ [x_2,\cdots,x_n] \end{split} \]
通过列表的可数性可以证明如下定理
    \[ \abs{S} \leq \aleph_1 \Rightarrow \abs{\mathbf{List}_S} \leq \aleph_1 \]
令 $i$ 是以 $S$ 为本质集的有效解释
    \[ \mathbf{Se}_i = S \ \land\ \mathbf{V}_i \]
由定理 \ref{TI.countable}，得到 $\mathbf{V}_i \Rightarrow \abs{S} \leq \aleph_1$ 进而
$\abs{\mathbf{List}_S} \leq \aleph_1$
\[ \forall i.\ \mathbf{V}_i \Rightarrow \abs{\mathbf{List}(\mathbf{Se}_i)} \leq \aleph_1 \]
于是可以应用理解虚构
\[ \forall i.\ \mathbf{V}_i \Rightarrow \exists j.\ \mathbf{V}_j \ \land\ 
    (\mathbf{Se}_j = \mathbf{List}(\mathbf{Se}_i))\]
据此定义列表理解 $\mathbf{LI} : \itp{\alpha} \rightarrow \itp{\alpha\ \mathrm{list}}$
\begin{equation} \label{V.LI}
    \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)} \ \land\ 
    (\mathbf{Se}_{\mathbf{LI}(i)} = \mathbf{List}(\mathbf{Se}_i))
\end{equation}
然后由常量虚构律引入空列表常量
{\center \begin{prooftree}
    \AxiomC{$\vdash \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)}$}
    \AxiomC{$\vdash [\ ] \in \mathbf{List}(\mathbf{Se}_i)$}
\BinaryInfC{$\vdash \exists \mathrm{EMPTY}.\ \mathrm{EMPTY} \widesim[3]{\mathbf{LI}\ i} [\ ]$}
\end{prooftree}}

接下来是基元虚构律引入各种需要的功能，记号 $l_k$ 表示列表 $l$ 中的第$k$个元素，

$h::l$ 表示 $[h,l_1,\cdots,l_n]$

{\center \begin{prooftree}
    \AxiomC{$\vdash \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)}$}
    \AxiomC{$h \in \mathbf{Se}_i,\ l \in \mathbf{Se}(\mathbf{LI}\ i)
    \vdash (h::l) \in \mathbf{Se}_{\mathbf{LI}\ i} $}
\BinaryInfC{$\vdash \exists \mathrm{APPEND}.\ \mathrm{APPEND}
    \proctr{i|\mathbf{LI}(i)|\mathbf{LI}(i)}{\lambda h\ l.\ \mathrm{T}}
    (\lambda h\ l.\ h::l)$}
\end{prooftree}}

令 $\mathcal{N}$ 为一自然数集的理解。
{\center \begin{prooftree}
    \AxiomC{$\vdash \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)}$}
\AxiomC{$k \in \mathbf{Se}_{\mathcal{N}},\ l \in \mathbf{Se}(\mathbf{LI}\ i),\ 
  k < \mathrm{len}\ l \vdash l_k \in \mathbf{Se}_{\mathbf{LI}\ i} $}
\BinaryInfC{$\vdash \exists \mathrm{GET}.\ \mathrm{GET}
    \proctr{\mathbf{LI}(i)|\mathcal{N}|\mathbf{LI}(i)}{\lambda l\ k.\ k < \mathrm{len}\ l}
    (\lambda l\ k.\ l_k)$}
\end{prooftree}}

以上，$\mathbf{LI}$，APPEND，GET 均是虚构的，不需要涉及具体的实现，就可以使用这些进行
列表功能的编程。

\end{example}

\subsection{单元素本质集的理解}
\begin{example}[单元素本质集的理解]
    \[ \mathbf{I1}\ e = \mathbf{Interpretation}\ (\K \mathrm{p}_0)\ (\K e)\ 
    \{e\}\ \{\mathrm{p}_0\} \]
最主要的特点是，$\mathbf{I1}\ e$ 不需要实际地表达，因为本质集中只有一个元素，
于是表示这一个元素不需要使用任何实质的计算客体除了独特的零现象$\mathrm{p}_0$，
不占用任何二进制位，而在最后编译出的
目标程序中不需要也不会被表达，一如C语言的void。但却是一种合理合法的理解，可以参与
整个 $\amlh$ 的方方面面。

类似很多其他编程语言中的常量概念，$\mathbf{I1}\ e$ 也可以作为某个过程的参数，而 $e$ 
可以在那过程中被全称量化（universal quantification），
下面是如此应用的一个例子。
\end{example}

\begin{example} \label{exam.I1}
\[ \forall (e:\mathrm{num}).\ \mathrm{AddN}
\proctr{\mathcal{N}|\mathbf{I1}_e|\mathcal{N}}{cond} 
    (\lambda x\ e.\ x + e) \]

AddN 实际成为一种模板函数，任意给定常量$e$生成加法$e$的函数，
而编译结果中实际不会出现参数$e$，在 AddN 内部参数$e$被作为常量优化。
\end{example}

\begin{notation}
    \[ \mathbf{I1}_e \coloneqq \mathbf{I1}\ e \]
    \[ \mathbf{I1}^{\alpha} \coloneqq (\mathbf{I1}: \alpha \rightarrow \itp{\alpha})
    \quad\quad \alpha\text{\ 表示类型变量}\]
\end{notation}
\begin{theo}[$\mathbf{I1}$ 有效性]
    \[ \forall e.\ \mathbf{VALID\_ITP}\ \mathbf{I1}_e \]
\end{theo}
\begin{proof} 略
\end{proof}

\subsection{有限个本质的理解}

同样可以引入对一个有限序列（Finite Sequence）的理解，
现象记录编号而其本质即是序列中编号上的元素。

至今尚未明确限制现象的定义而是留作了可定制的框架性参数，令 $\rho(i)$ 表示用以表示数字i
的现象，此外有简写$\rho_i = \rho(i)$

\begin{defin}[有限本质序列的理解]
    \[ \mathbf{SI} (l:\mathrm{\alpha\ list}) \coloneqq \mathbf{Interpretation}\ 
    (\lambda e.\ \rho(\mathbf{Index}_l\ e))\ (\lambda \rho_i.\ l_i)\ 
    (\mathbf{Set}\ l)\ \{\rho_1,\cdots,\rho(\mathbf{Len}_l)\}\]
其中 $\mathbf{Index}_l$ 表示序列 $l$ 的索引函数，$\mathbf{Len}_l$ 表示序列 $l$ 的长度。
\end{defin}

同样有简写 $\mathbf{SI}^{\alpha} \coloneqq (\mathbf{SI} : \mathrm{\alpha\ list}
\rightarrow \itp{\mathrm{\alpha}})$

\subsection{静态函数参数}

在许多经典编程语言的设计中都有函数参数的概念，它们或被叫做 lambda 函数或叫函数指针。
接下来的两节重点讨论函数参数在 $\amlh$ 上的实现。

函数参数分为两种，静态参数与动态参数。静态参数指在编译时可以确定函数参数所具体指代的过程，
于是更类似于模板的概念可以在编译时进行函数参数的带入；而动态参数相反，需要在运行时动态
调用函数指针。不同语言对此有不同的名称，另一种叫法是静态调用与动态调用。
本节先论述静态参数，而下一节论述动态参数。

而静态参数的理解，非常简单，就是 $\mathbf{I1}$。
更具体一点，一元过程的理解是 $\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \mathrm{phenomenon}}$
二元过程是 $\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \mathrm{phenomenon} \rightarrow \mathrm{phenomenon}}$，
更高元类似。

重点在于$\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \cdots \rightarrow \mathrm{phenomenon}}$
仅仅将现象超越对应到现象过程，即本质是现象过程，而很多时候期望对函数参数的本质约束更多，
诸如这种现象过程具有某些特定理解下的超越对应并对应到一个本质上的函数以利于本质上的运算。
例如一个过程可能期望一个具有本质 $f_e : num \rightarrow num$ 的函数参数，而
$\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \mathrm{phenomenon}}$ 给出的本质仅仅是
$f_p:\mathrm{phenomenon} \rightarrow \mathrm{phenomenon}$ 的。
其实此时我们期望对 $f_p$ 进行更多的约束，约束它具有某个到$f_e$的超越对应，即要求
$f_p$ 满足性质 $P$，而$P$中包含所期望的到$f_e$的超越对应。
于是解法就非常简单，在条件中加入约束$P$即可。
下面的例子有助于理解。

\begin{example}[Do2N] \label{Ex.Do2N}
$\mathrm{Do2N}$ 具有类似 $\lambda f\ x.\ f (x+x)$ 的功能，$\mathrm{Do2N}$ 
的超越对应关系应是
\[ \forall (f_p:\mathrm{ph}\rightarrow\mathrm{ph})\ (f_e:\mathrm{num} \rightarrow \mathrm{num}).\ 
\mathrm{Do2N} \proctr{\mathbf{I1}(f_p)|\mathcal{N}|\mathcal{N}}{\lambda f\ x.\ f
  \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e} (\lambda f\ x.\ f_e (x+x)) \]
其中 $f$ 均具有类型 $\mathrm{ph}\rightarrow\mathrm{ph}$
\end{example}

\begin{defin}[Call 基元] \label{Def.Call}
    $\mathbf{Call}_1$ 基元函数用于调用一元静态函数参数。
\[ \forall f_p\ i\ l\ cond\ f_e.\ \mathbf{Call}_1
\proctr{\mathbf{I1}(f_p)|i|l}{\lambda f_p\ x_e.\ f_p \proctr{i|l}{cond} f_e \land
  cond\ x_e} (\lambda f_p\ x.\ f_e\ x_e) \]
可以证明
\[ f_p^0 \widesim[3]{\mathbf{I1}(f_p^0)} f_p,\ x_p \widesim{i} x_e,\ 
    f_p \proctr{i|l}{cond} f_e,\ cond\ x_e \vdash \mathbf{V}_l \ \land\ 
    f_e\ x_e \in \mathbf{Se}_l \tag{1} \]
其中$f_p^0$ 表示$f_p$的伪现象，实际占用0个二进制位而实际不存在于编译结果中。
由过程的超越对应的充分性定理 \ref{T.ptr.enough}
\[ f_p \proctr{i|l}{cond} f_e \vdash \mathbf{V}_i \land x_e \in \mathbf{Se}_i \land
    cond\ x_e \Rightarrow \mathbf{V}_l\ \land\ f_e\ x_e \in \mathbf{Se}_l \tag{2} \]
此外由定义 \ref{Def.TR}
\[ x_p \widesim{i} x_e \vdash \mathbf{V}_i \land x_e \in \mathbf{Se}_i \tag{3} \]
结合(2)，(3)
\[ x_p \widesim{i} x_e,\ 
f_p \proctr{i|l}{cond} f_e,\ cond\ x_e \vdash \mathbf{V}_l \ \land\ 
    f_e\ x_e \in \mathbf{Se}_l \]
于是(1)被证明，而(1)意味着可以对$\mathbf{Call}_1$ 进行虚构基元律以定义。

用同样的手段，可以分别虚构基元引入多元版本的 $\mathbf{Call}_2\ \cdots\ \mathbf{Call}_n$
\end{defin}


而 $\mathrm{Do2N}$ 可以被如下构建

\begin{prooftree}
\Axiom$x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f,\ 
f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ \fCenter \vdash x_p \widesim{\mathcal{N}} x$
\UnaryInf$x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f,\ 
f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ \fCenter \vdash \mathbf{Add}\ x_p\ x_p
    \widesim{\mathcal{N}} x + x$
\UnaryInf$x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f,\ 
f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ \fCenter \vdash \mathbf{Call}_1\ f_p
\ (\mathbf{Add}\ x_p\ x_p) \widesim{\mathcal{N}} f_e(x+x)$
\UnaryInf$\quad\quad\quad\quad
x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f
\ \fCenter \vdash \mathbf{Call}_1\ f_p
\ (\mathbf{Add}\ x_p\ x_p) \proctr{\mathcal{N}}{\lambda f\ x.\ f
\proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e} f_e(x+x)$
\UnaryInf$\vdash \forall f_p\ f_e.\ \mathrm{Do2N}\ \fCenter
\proctr{\mathbf{I1}(f_p)|\mathcal{N}|\mathcal{N}}{\lambda f\ x.\ f
\proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e} (\lambda f\ x.\ f_e (x+x))$
\end{prooftree}

即简单来说，将$f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e$ 作为过程条件的一部分。

\subsection{动态函数参数（虚函数表）}

$\amlh$ 上的动态函数必须只能在确定的范围内的动态。与诸多其他编程语言类似，技术上 $\amlh$
不允许动态编译新的函数，于是动态函数可选的范围一定有限而固定的。
于是所谓的动态，其实是确定的虚函数表上的动态，是指动态地选择表中的不同函数。

类似于静态函数参数直接就是单元素解释，动态函数参数的理解是有限序列解释，一元的解释是
$\mathbf{SI}^{\mathrm{phenomenon}\rightarrow\mathrm{phenomenon}}$，二元是
$\mathbf{SI}^{\mathrm{phenomenon}\rightarrow\mathrm{phenomenon}\rightarrow\mathrm{phenomenon}}$，
更高元类推。
而$\mathbf{SI}$的现象所表达的序列中的序号实质是虚函数表的索引，在编译实现中将根据此索引查
虚函数表得到函数指针而动态地调用。

关键难点与静态函数参数时一样，
也是在于$\mathbf{SI}$的本质是现象过程而需要有对此现象过程的超越对应。
而解决方法也是与静态函数类似的，通过在条件中加入对现象过程的超越对应的约束。

同样先给出一个样例以利于读者理解。

\begin{example}[VDo2N] 
$\mathrm{VDo2N}$ 是样例\ref{Ex.Do2N} 中 $\mathrm{Do2N}$ 的动态虚函数版本。
    \[ \begin{split} \forall (l_p:(\mathrm{phenomenon}&\rightarrow\mathrm{phenomenon})\ 
    \mathrm{list})\ (f_e:(\mathrm{phenomenon}\rightarrow\mathrm{phenomenon}) \mapsto
    (\mathrm{num} \rightarrow \mathrm{num})).\ \\
& \mathrm{VDo2N} \proctr{\mathbf{SI}(l_p)|\mathcal{N}|\mathcal{N}}{\lambda f\ x.\ 
  l_f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ f}
    (\lambda f\ x.\ f_e\ f\ (x+x)) \end{split} \]
其中 $f$ 均具有类型 $\mathrm{ph}\rightarrow\mathrm{ph}$。此外类型
$\alpha \mapsto \beta$ 表示从 $\alpha$ 到 $\beta$ 的有限映射，有限映射与普通函数
$\alpha \rightarrow \beta$ 很像，除了有限映射的原象集是有限的。
有限映射与函数映射在普通数学中基本不做区分，只是在 HOL 逻辑中被不同地处理。
$f_e$ 具有类型 $(\mathrm{phenomenon}\rightarrow\mathrm{phenomenon}) \mapsto
(\mathrm{num} \rightarrow \mathrm{num})$ 且 $\Dom f_e = \mathrm{Set}\ l_f$ 表示对 
序列$l_f$ 上各个元素的超越对应。
\end{example}

\begin{defin}[虚调用VCall]
    \[ \forall l_f\ i\ l\ cond\ f_e.\ \mathbf{VCall}_1
    \proctr{\mathbf{SI}(l_f)|i|l}{\lambda f\ x_e.\ f 
    \proctr{i|l}{cond} f_e\ f\ \land\ cond\ x_e } (\lambda f\ x_e.\ f_e\ f\ x_e) \]
同样要证明满足基元虚构的条件
    \[ f_p \widesim[3]{\mathbf{SI}(l_f)} f,\ x_p \widesim{i} x_e,\ 
    f \proctr{i|l}{cond} f_e\ f,\ cond\ x_e \vdash \mathbf{V}_l \ \land\ 
    f_e\ f\ x_e \in \mathbf{Se}_l \tag{1}\]
证明是与定义 \ref{Def.Call} 中几乎一样的，同样由过程的超越对应的充分性定理 
    \ref{T.ptr.enough}
\[ f \proctr{i|l}{cond} f_e\ f \vdash \mathbf{V}_i \land x_e \in \mathbf{Se}_i \land
    cond\ x_e \Rightarrow \mathbf{V}_l\ \land\ f_e\ f\ x_e \in \mathbf{Se}_l \tag{2} \]
同样由定义 \ref{Def.TR}
\[ x_p \widesim{i} x_e \vdash \mathbf{V}_i \land x_e \in \mathbf{Se}_i \tag{3} \]
结合(2)，(3)
\[ x_p \widesim{i} x_e,\ 
f \proctr{i|l}{cond} f_e\ f,\ cond\ x_e \vdash \mathbf{V}_l \ \land\ 
    f_e\ f\ x_e \in \mathbf{Se}_l \]
于是(1)被证明，于是可以对$\mathbf{VCall}_1$ 进行虚构基元律以定义。

同样类似地定义多元版本的 $\mathbf{VCall}_2\ \cdots\ \mathbf{VCall}_n$
\end{defin}

\subsection{递归函数}

本节示例性地论述如何在 $\amlh$ 上定义递归函数，以及其上递归函数定义与归纳法（Induction）的
内在联系。
这种对递归函数的支持说明$\amlh$是图灵完备的。
$\amlh$ 提供两种编写递归函数的方法，第一种严谨而难以使用，困难在于递归良好性的证明（Well Formed），需要有经验的数学家巧妙地技巧；
第二种易于使用，可供普通用户使用，但无法证明停机性。

首先要引入结构化归纳。

\begin{defin}[结构化归纳（Structual Induction）]
对于由如下范式定义的类型 $t$
\[ \begin{split} t \Coloneqq\ & C_1\ a^1_1\ \cdots\ a^1_{o_1} \mbar \cdots \mbar C_m\ 
    a^m_1\ \cdots\ a^m_{o_m} \\
\mbar & C^R_{m+1}\ a^{m+1}_1\ \cdots\ a^{m+1}_{o_{m+1}} \mbar \cdots \mbar C^R_n\ 
    a^n_1\ \cdots\ a^n_{o_n}
\end{split} \]

\noindent 其中 $C_1,\ \cdots,\ C_m,\ C^R_{m+1},\ \cdots,\ C^R_n$ 为 $t$ 的构造函数，

\noindent $C_1,\ \cdots,\ C_m$ 为非递归构造函数，$C^R_{m+1},\ \cdots,\ C^R_n$ 为递归构造函数。

\noindent $a^1_1,\ \cdots,\ a^1_{o_1},\ \cdots,\ a^n_{o_n}$ 为构造函数们的参数类型。

\noindent 其中 $r^{i}_1,\ \cdots,\ r^i_{p_i} \in \{ a^i_1,\ \cdots,\ a^i_{o_i} \},\ i > m$ 有
$r^{i}_1 = \cdots = r^i_{p_i} = t$ 即它们是递归参数。

\noindent 那么类型 $t$ 的结构化归纳定理具有如下范式
    \[ \begin{split} \forall (P:t \rightarrow \mathrm{bool}).\ &(
(\forall a^1_1\ \cdots\ a^1_{o_1}.\ P\ (C_1\ a^1_1\ \cdots\ a^1_{o_1})) \land \cdots \land
\\ (\forall &a^m_1\ \cdots\ a^m_{o_n}.\ P\ (C_m\ a^m_1\ \cdots\ a^m_{o_m})) \land \\
(\forall a^{m+1}_1\ &\cdots\ a^{m+1}_{o_{m+1}}.\ P\ r^{m+1}_1 \land\ \cdots\ \land
P\ r^{m+1}_{p_{m+1}} \Rightarrow P\ (C_{m+1}\ a^{m+1}_1\ \cdots\ a^{m+1}_{o_n})) \land
\cdots \land \\
(\forall &a^{n}_1\ \cdots\ a^{n}_{o_{n}}.\ P\ r^{n}_1 \land\ \cdots\ \land
P\ r^{n}_{p_{n}} \Rightarrow P\ (C_{n}\ a^{n}_1\ \cdots\ a^{n}_{o_n}))) \\
&\quad\quad\quad\quad\quad\quad \Rightarrow \forall x.\ P\ x
\end{split} \]
\end{defin}

\begin{example}[皮亚诺数（Peano number）及其递归定理]
    皮亚诺对数字的定义是目前学界普遍采用的自然数的定义，是一种典型的递归定义。
    \[ \mathrm{number} \Coloneqq 0 \mbar \mathrm{Suc}\ number \]
其中类型$\mathrm{number}$ 有两个构造函数，第一个不接受任何参数，即为$0$，第二个构造函数
名为$\mathrm{Suc}$，接受一个$\mathrm{number}$类型的参数，表示此数的后继。

    以上定义下，自然数 $1$ 被表示为 $\Suc 0$，自然数$2$表示为$\Suc(\Suc 0)$

    皮亚诺数具有结构化归纳定理为
    \[ \forall (P:\mathrm{number}\rightarrow\mathrm{bool}).\ 
    (P\ 0)\land(\forall n.\ P\ n \Rightarrow P(\Suc n)) \Rightarrow 
    \forall n.\ P\ n\]
\end{example}

现在回到$\amlh$上递归函数的构建，讨论本质对应具有如下形式的现象过程的递归构建。
\[ \begin{split}
    f\ x^1_1\ \cdots\ x^1_{q_1}\ & = body\ without\ recursion \\
    & \cdots \\
    f\ x^r_1\ \cdots\ x^r_{q_r}\ & = body\ with\ recursion \\
    & \cdots
\end{split} \]
例如斐波那契函数
\[ \begin{split} \mathrm{fib}\ 0 = 1\quad\quad&\quad\quad\quad\mathrm{fib}\ (\Suc 0) = 1\\
\mathrm{fib}\ (\Suc(\Suc n)) &= \mathrm{fib}(\Suc n) + \mathrm{fib}(n)\end{split} \]
假设中引入递归函数参数$g$，逐个对应本质的递归式得到递归现象过程$F\ g$的超越对应
\[ \begin{split}
    p_1 \widesim{i_1} x^1_1,\ \cdots,\ p_{q_1} \widesim{i_{q_1}} x^1_{q_1}
    &\vdash F\ g\ p_1\ \cdots\ p_{q_1} \widesim{l} f\ x^1_1\ \cdots\ x^1_{q_1} \\
    \cdots & \\
    p_1 \widesim{i_1} x^r_1,\ \cdots,\ g\ v_1 \widesim{l} u_1,\ \cdots &\vdash
    F\ g\ p_1\ \cdots\ p_{q_r} \widesim{l} f\ x^r_1\ \cdots x^r_{q_r}\\
    (F\ g\ p_1\ \cdots\ p_{q_r} & \text{\ 包括\ } g\ v_1,\ \cdots) \\
    \cdots &
\end{split} \]
例如在斐波那契函数的例子中是
\begin{align*}
    F\ g \coloneqq \lambda p.\ \mathbf{If}\ (\mathbf{Less}\ p\ \mathbf{2})\ 
    \mathbf{0}\ (\mathbf{Add}\ (g\ &(\mathbf{Sub}\ p\ \mathbf{1}))\ (g\ (\mathbf{Sub}\ 
    p\ \mathbf{2}))) \label{fib0} \tag{式1} \\
    p \widesim{\mathcal{N}} 0 \vdash F\ g\ p \widesim{\mathcal{N}} \mathrm{fib}\ 0
\quad\quad\quad&\quad\quad\quad
    p \widesim{\mathcal{N}} 1 \vdash F\ g\ p \widesim{\mathcal{N}} \mathrm{fib}\ 1
    \label{fib1} \tag{式2}\\
    p \widesim{\mathcal{N}} (\Suc (\Suc n)),\ g\ (\mathbf{Sub}\ p\ \mathbf{1})
    \widesim{\mathcal{N}}\ &\mathrm{fib}\ (\Suc n),\ g\ (\mathbf{Sub}\ p\ \mathbf{2})
    \widesim{\mathcal{N}} \mathrm{fib}\ n \vdash\\
    F\ g\ p \widesim{\mathcal{N}}\ &\mathrm{fib} \ (\Suc (\Suc n)) \label{fib2} \tag{式3}
\end{align*}

以上构建了归纳法证明$F\ g$ 超越对应的基础。
前提是可以定义 $g = F\ g$，即递归定义的良好性，即需要证明
\[ \exists g.\ \forall s.\ s \in S \Rightarrow g\ s = F\ g\ s \tag{WF} \]
以上是部分函数的递归良好性（wellfound of partial recursive function），当
$S = \mathbb{U}$ 时变成全函数的递归良好性（wellfound of total recursive function）。

WF 命题是需要证明技巧的，在斐波那契函数的例子中可以构造数学归纳法以完成证明，
先证明一个更难的问题
\[ \forall n.\ \exists g.\ \forall s.\ s \in \{p\mbar p \widesim{\mathcal{N}} x,\ x \leq n\} \Rightarrow
 g\ s = F\ g\ s \]
对 $n$ 进行归纳法，目标命题变成
\begin{align}
    \text{1.\ }& \exists g.\ \forall p.\ p \widesim{\mathcal{N}} 0
    \Rightarrow (g\ p = F\ g\ p) \tag{目标1} \label{fibg1} \\
\begin{split}
    \text{2.\ }& \forall n.\ (\exists g.\ \forall s.\ s \in \{p\mbar p 
    \widesim{\mathcal{N}} x,\ x \leq n\}\ \Rightarrow (g\ s = F\ g\ s)) \Rightarrow \\
    &\quad\quad\quad\quad
    (\exists g.\ \forall s.\ s \in \{p\mbar p \widesim{\mathcal{N}} x,\ 
    x \leq (\Suc n)\} \Rightarrow (g\ s = F\ g\ s))
\end{split} \tag{目标2} \label{fibg2}
\end{align}

\ref{fibg1} 显然很容易，$g = \K \mathbf{0}$ 即可。
对于\ref{fibg2} 取 $g'$ 为满足存在性条件 $(\exists g.\ \forall s.\ s \in \{p\mbar p 
    \widesim{\mathcal{N}} x,\ x \leq n\}\ \Rightarrow (g\ s = F\ g\ s))$ 的值。
分类讨论\ref{fibg2}
\begin{align*}
    &\text{当 $n = 0$ 时，}\\
    &\quad\quad(\forall p.\ p \widesim{\mathcal{N}} 0
    \Rightarrow (g'\ p = F\ g'\ p)) \Rightarrow 
    (\exists g.\ \forall p.\ p \widesim{\mathcal{N}} 1
    \Rightarrow (g\ p = F\ g\ p)) \label{fibg3} \tag{目标3} \\
    \begin{split} &\text{当 $n > 0$ 时，即 $n = \Suc n'$} \\
    &\quad\quad \forall n'.\ (\forall s.\ s \in \{p\mbar p 
    \widesim{\mathcal{N}} x,\ x \leq \Suc n'\}\ \Rightarrow (g'\ s = F\ g'\ s))
\Rightarrow \\ &\quad\quad\quad\quad
    (\exists g.\ \forall s.\ s \in \{p\mbar p \widesim{\mathcal{N}} x,\ 
    x \leq (\Suc (\Suc n'))\} \Rightarrow (g\ s = F\ g\ s))
\end{split} \label{fibg4} \tag{目标4}
\end{align*}

\ref{fibg3} 也是显然的，同样是 $g = \K \mathbf{0}$；
\ref{fibg4} 也是成立的，令
\[ g = \lambda p.\ \mathrm{if}\ \ p = n + \mathbf{2}\ \ \mathrm{then}\ 
\ \mathbf{Add}\ (g\ (n + \mathbf{1}))\ (g\ n)\ \ \mathrm{else}\ \ g\ n \]
即可

于是斐波那契函数例子中的WF命题成立。
\[ \exists g.\ \forall p.\ p \in \mathbf{Sp}_\mathcal{N} \Rightarrow g\ p = F\ g\ p \]
替换回\ref{fib0}，\ref{fib1}，\ref{fib2}
\begin{align*}
    g \coloneqq \lambda p.\ \mathbf{If}\ (\mathbf{Less}\ p\ \mathbf{2})\ 
    \mathbf{0}\ (\mathbf{Add}\ (g\ &(\mathbf{Sub}\ p\ \mathbf{1}))\ (g\ (\mathbf{Sub}\ 
    p\ \mathbf{2}))) \\
    p \widesim{\mathcal{N}} 0 \vdash g\ p \widesim{\mathcal{N}} \mathrm{fib}\ 0
\quad\quad\quad&\quad\quad\quad
    p \widesim{\mathcal{N}} 1 \vdash g\ p \widesim{\mathcal{N}} \mathrm{fib}\ 1 \\
    p \widesim{\mathcal{N}} (\Suc (\Suc n)),\ g\ (\mathbf{Sub}\ p\ \mathbf{1})
    \widesim{\mathcal{N}}\ &\mathrm{fib}\ (\Suc n),\ g\ (\mathbf{Sub}\ p\ \mathbf{2})
    \widesim{\mathcal{N}} \mathrm{fib}\ n \vdash\\
    g\ p \widesim{\mathcal{N}}\ &\mathrm{fib} \ (\Suc (\Suc n))
\end{align*}

以上，就可以再次利用归纳法，证明如下性质
\[ g \proctr{\mathcal{N}|\mathcal{N}}{\K \T} \mathrm{fib} \]

