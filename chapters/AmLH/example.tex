\section{案例分析}
\subsection{列表的理解}

这一节给出虚一个构理解与虚构基元的具体案例，列表的理解，具有实际意义。

\begin{lemma}[单射与子集] \label{L.inj_subset}
    \[ \forall f\ S\ T_1\ T_2.\ T_1 \subseteq T_2 \Rightarrow \mathbf{INJ}\ f\ S\ T_1
    \Rightarrow \mathbf{INJ}\ f\ S\ T_2\]
\end{lemma}
\begin{proof} 基础的数学定理，略。
\end{proof}
\begin{lemma}[有效理解的投影是单射] \label{L.i.inj}
\[ \mathbf{V}_i \Rightarrow \mathbf{INJ}\ \mathbf{L}_i\ \mathbf{Se}_i\ \mathbf{Sp}_i \]
\end{lemma}
\begin{proof} 

\begin{align*}
& \text{由定义} \ref{Def.Vi} && \mathbf{V}_i \Rightarrow \ 
    (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e)) & (1) \\
& \text{只需证明} && \mathbf{V}_i,\ e_1 \in \mathbf{Se}_i,\ e_2 \in \mathbf{Se}_i,\ 
    \mathbf{Li}_i\ e_1 = \mathbf{Li}_i\ e_2\ \vdash\ e_1 = e_2 & \\
& \text{显然有} && \mathbf{V}_i,\ e_1 \in \mathbf{Se}_i,\ e_2 \in \mathbf{Se}_i,\ 
    \mathbf{Li}_i\ e_1 = \mathbf{Li}_i\ e_2\ \vdash
    \mathbf{Tr}_i(\mathbf{Li}_i\ e_1) = \mathbf{Tr}_i(\mathbf{Li}_i\ e_2) & \\
& \text{由 (1)} && \mathbf{V}_i,\ e_1 \in \mathbf{Se}_i,\ e_2 \in \mathbf{Se}_i,\ 
    \mathbf{Li}_i\ e_1 = \mathbf{Li}_i\ e_2\ \vdash e_1 = e_2 &
\end{align*} \end{proof}
\begin{theo}[理解的 phenomenon 可数性]\label{TI.countable}
    \[ \forall i.\ \mathbf{V}_i \Rightarrow \abs{\mathbf{Se}_i} \leq
    \abs{\mathrm{phenomenon}} \]
\end{theo}
\begin{proof} 
\begin{align*}
& \text{由定义 \ref{Def.Card} 只需证明} && \mathbf{V}_i \vdash
  \exists f.\ \ \mathbf{INJ} \ \ f\ \ \mathbf{Se}_i\ \ \mathrm{phenomenon}& \\
& \text{由引理 \ref{L.i.inj}} && \mathbf{V}_i \vdash \mathbf{INJ}\ \mathbf{L}_i\ 
    \mathbf{Se}_i\ \mathbf{Sp}_i & (1) \\
& \text{显然有} && \vdash \mathbf{Sp}_i \subseteq \mathrm{phenomenon} & (2) \\
& \text{由引理 \ref{L.inj_subset}，(1)，(2)} && \mathbf{V}_i \vdash \mathbf{INJ}\ 
    \mathbf{L}_i\ \mathbf{Se}_i\ \mathrm{phenomenon}&
\end{align*}
\end{proof}

\begin{example}[以虚构方式引入列表理解] \label{exam.LI}
现在假设 $\abs{\mathrm{phenomenon}} = \aleph_1$，
即现象集同构于自然数集。先如下递归定义集合$S$上的列表$\mathbf{List}_S$集
\[ \begin{split} \mathbf{List}_S\ [\ ]\ & = T \\
\mathbf{List}_S\ [x_1,x_2,\cdots,x_n]\ & = x_1 \in S \land \mathbf{List}_S\ [x_2,\cdots,x_n] \end{split} \]
通过列表的可数性可以证明如下定理
    \[ \abs{S} \leq \aleph_1 \Rightarrow \abs{\mathbf{List}_S} \leq \aleph_1 \]
令 $i$ 是以 $S$ 为本质集的有效解释
    \[ \mathbf{Se}_i = S \ \land\ \mathbf{V}_i \]
由定理 \ref{TI.countable}，得到 $\mathbf{V}_i \Rightarrow \abs{S} \leq \aleph_1$ 进而
$\abs{\mathbf{List}_S} \leq \aleph_1$
\[ \forall i.\ \mathbf{V}_i \Rightarrow \abs{\mathbf{List}(\mathbf{Se}_i)} \leq \aleph_1 \]
于是可以应用理解虚构
\[ \forall i.\ \mathbf{V}_i \Rightarrow \exists j.\ \mathbf{V}_j \ \land\ 
    (\mathbf{Se}_j = \mathbf{List}(\mathbf{Se}_i))\]
据此定义列表理解 $\mathbf{LI} : \itp{\alpha} \rightarrow \itp{\alpha\ \mathrm{list}}$
\begin{equation} \label{V.LI}
    \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)} \ \land\ 
    (\mathbf{Se}_{\mathbf{LI}(i)} = \mathbf{List}(\mathbf{Se}_i))
\end{equation}
然后由常量虚构律引入空列表常量
{\center \begin{prooftree}
    \AxiomC{$\vdash \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)}$}
    \AxiomC{$\vdash [\ ] \in \mathbf{List}(\mathbf{Se}_i)$}
\BinaryInfC{$\vdash \exists \mathrm{EMPTY}.\ \mathrm{EMPTY} \widesim[3]{\mathbf{LI}\ i} [\ ]$}
\end{prooftree}}

接下来是基元虚构律引入各种需要的功能，记号 $l_k$ 表示列表 $l$ 中的第$k$个元素，

$h::l$ 表示 $[h,l_1,\cdots,l_n]$

{\center \begin{prooftree}
    \AxiomC{$\vdash \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)}$}
    \AxiomC{$h \in \mathbf{Se}_i,\ l \in \mathbf{Se}(\mathbf{LI}\ i)
    \vdash (h::l) \in \mathbf{Se}_{\mathbf{LI}\ i} $}
\BinaryInfC{$\vdash \exists \mathrm{APPEND}.\ \mathrm{APPEND}
    \proctr{i|\mathbf{LI}(i)|\mathbf{LI}(i)}{\lambda h\ l.\ \mathrm{T}}
    (\lambda h\ l.\ h::l)$}
\end{prooftree}}

令 $\mathcal{N}$ 为一自然数集的理解。
{\center \begin{prooftree}
    \AxiomC{$\vdash \forall i.\ \mathbf{V}_i \Rightarrow \ \mathbf{V}_{\mathbf{LI}(i)}$}
\AxiomC{$k \in \mathbf{Se}_{\mathcal{N}},\ l \in \mathbf{Se}(\mathbf{LI}\ i),\ 
  k < \mathrm{len}\ l \vdash l_k \in \mathbf{Se}_{\mathbf{LI}\ i} $}
\BinaryInfC{$\vdash \exists \mathrm{GET}.\ \mathrm{GET}
    \proctr{\mathbf{LI}(i)|\mathcal{N}|\mathbf{LI}(i)}{\lambda l\ k.\ k < \mathrm{len}\ l}
    (\lambda l\ k.\ l_k)$}
\end{prooftree}}

以上，$\mathbf{LI}$，APPEND，GET 均是虚构的，不需要涉及具体的实现，就可以使用这些进行
列表功能的编程。

\end{example}

\subsection{单元素本质集的理解}
\begin{example}[单元素本质集的理解]
    \[ \mathbf{I1}\ e = \mathbf{Interpretation}\ (\K \mathrm{p}_0)\ (\K e)\ 
    \{e\}\ \{\mathrm{p}_0\} \]
最主要的特点是，$\mathbf{I1}\ e$ 不需要实际地表达，因为本质集中只有一个元素，
于是表示这一个元素不需要使用任何实质的计算客体除了独特的零现象$\mathrm{p}_0$，
不占用任何二进制位，而在最后编译出的
目标程序中不需要也不会被表达，一如C语言的void。但却是一种合理合法的理解，可以参与
整个 $\amlh$ 的方方面面。

类似很多其他编程语言中的常量概念，$\mathbf{I1}\ e$ 也可以作为某个过程的参数，而 $e$ 
可以在那过程中被全称量化（universal quantification），
下面是如此应用的一个例子。
\end{example}

\begin{example} \label{exam.I1}
\[ \forall (e:\mathrm{num}).\ \mathrm{AddN}
\proctr{\mathcal{N}|\mathbf{I1}_e|\mathcal{N}}{cond} 
    (\lambda x\ e.\ x + e) \]

AddN 实际成为一种模板函数，任意给定常量$e$生成加法$e$的函数，
而编译结果中实际不会出现参数$e$，在 AddN 内部参数$e$被作为常量优化。
\end{example}

\begin{notation}
    \[ \mathbf{I1}_e \coloneqq \mathbf{I1}\ e \]
    \[ \mathbf{I1}^{\alpha} \coloneqq (\mathbf{I1}: \alpha \rightarrow \itp{\alpha})
    \quad\quad \alpha\text{\ 表示类型变量}\]
\end{notation}
\begin{theo}[$\mathbf{I1}$ 有效性]
    \[ \forall e.\ \mathbf{VALID\_ITP}\ \mathbf{I1}_e \]
\end{theo}
\begin{proof} 略
\end{proof}

\subsection{静态函数参数}

在许多经典编程语言的设计中都有函数参数的概念，它们或被叫做 lambda 函数或叫函数指针。
接下来的两节重点讨论函数参数在 $\amlh$ 上的实现。

函数参数分为两种，静态参数与动态参数。静态参数指在编译时可以确定函数参数所具体指代的过程，
于是更类似于模板的概念可以在编译时进行函数参数的带入；而动态参数相反，需要在运行时动态
调用函数指针。不同语言对此有不同的名称，另一种叫法是静态调用与动态调用。
本节先论述静态参数，而下一节论述动态参数。

而静态参数的理解，非常简单，就是 $\mathbf{I1}$。
更具体一点，一元过程的理解是 $\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \mathrm{phenomenon}}$
二元过程是 $\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \mathrm{phenomenon} \rightarrow \mathrm{phenomenon}}$，
更高元类似。

重点在于$\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \cdots \rightarrow \mathrm{phenomenon}}$
仅仅将现象超越对应到现象过程，即本质是现象过程，而很多时候期望对函数参数的本质约束更多，
诸如这种现象过程具有某些特定理解下的超越对应并对应到一个本质上的函数以利于本质上的运算。
例如一个过程可能期望一个具有本质 $f_e : num \rightarrow num$ 的函数参数，而
$\mathbf{I1}^{\mathrm{phenomenon} \rightarrow \mathrm{phenomenon}}$ 给出的本质仅仅是
$f_p:\mathrm{phenomenon} \rightarrow \mathrm{phenomenon}$ 的。
其实此时我们期望对 $f_p$ 进行更多的约束，约束它具有某个到$f_e$的超越对应，即要求
$f_p$ 满足性质 $P$，而$P$中包含所期望的到$f_e$的超越对应。
于是解法就非常简单，在条件中加入约束$P$即可。
下面的例子有助于理解。

\begin{example}[Do2N]
$\mathrm{Do2N}$ 具有类似 $\lambda f\ x.\ f (x+x)$ 的功能，$\mathrm{Do2N}$ 
的超越对应关系应是
\[ \forall (f_p:\mathrm{ph}\rightarrow\mathrm{ph})\ (f_e:\mathrm{num} \rightarrow \mathrm{num}).\ 
\mathrm{Do2N} \proctr{\mathbf{I1}(f_p)|\mathcal{N}|\mathcal{N}}{\lambda f\ x.\ f
  \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e} (\lambda f\ x.\ f_e (x+x)) \]
其中 $f$ 均具有类型 $\mathrm{ph}\rightarrow\mathrm{ph}$
\end{example}

\begin{defin}[Call 基元] $\mathbf{Call}_1$ 基元函数用于调用一元静态函数参数。
\[ \forall f_p\ i\ l\ cond\ f_e.\ \mathbf{Call}_1
\proctr{\mathbf{I1}(f_p)|i|l}{\lambda f_p\ x_e.\ f_p \proctr{i|l}{cond} f_e \land
  cond\ x_e} (\lambda f_p\ x.\ f_e\ x_e) \]
可以证明
\[ f_p^0 \widesim[3]{\mathbf{I1}(f_p^0)} f_p,\ x_p \widesim{i} x_e,\ 
  f_p \proctr{i|l}{cond} f_e,\ cond\ x_e \vdash f_e\ x_e \in \mathbf{Se}_l \tag{1} \]
其中$f_p^0$ 表示$f_p$的伪现象，实际占用0个二进制位而实际不存在于编译结果中。
由过程的超越对应的充分性定理 \ref{T.ptr.enough}
\[ f_p \proctr{i|l}{cond} f_e \vdash \mathbf{V}_i \land x_e \in \mathbf{Se}_i \land
cond\ x_e \Rightarrow f_e\ x_e \in \mathbf{Se}_l \tag{2} \]
此外由定义 \ref{Def.TR}
\[ x_p \widesim{i} x_e \vdash \mathbf{V}_i \land x_e \in \mathbf{Se}_i \tag{3} \]
结合(2)，(3)
\[ x_p \widesim{i} x_e,\ 
f_p \proctr{i|l}{cond} f_e,\ cond\ x_e \vdash f_e\ x_e \in \mathbf{Se}_l \]
于是(1)被证明，而(1)意味着可以对$\mathbf{Call}_1$ 进行虚构基元律以定义。

用同样的手段，可以分别虚构基元引入多元版本的 $\mathbf{Call}_2\ \cdots\ \mathbf{Call}_n$
\end{defin}


而 $\mathrm{Do2N}$ 可以被如下构建

\begin{prooftree}
\Axiom$x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f,\ 
f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ \fCenter \vdash x_p \widesim{\mathcal{N}} x$
\UnaryInf$x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f,\ 
f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ \fCenter \vdash \mathbf{Add}\ x_p\ x_p
    \widesim{\mathcal{N}} x + x$
\UnaryInf$x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f,\ 
f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e\ \fCenter \vdash \mathbf{Call}_1\ f_p
\ (\mathbf{Add}\ x_p\ x_p) \widesim{\mathcal{N}} f_e(x+x)$
\UnaryInf$\quad\quad\quad\quad
x_p \widesim{\mathcal{N}} x_e,\ f_p \widesim[2]{\mathbf{I1}(f)} f
\ \fCenter \vdash \mathbf{Call}_1\ f_p
\ (\mathbf{Add}\ x_p\ x_p) \proctr{\mathcal{N}}{\lambda f\ x.\ f
\proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e} f_e(x+x)$
\UnaryInf$\vdash \forall f_p\ f_e.\ \mathrm{Do2N}\ \fCenter
\proctr{\mathbf{I1}(f_p)|\mathcal{N}|\mathcal{N}}{\lambda f\ x.\ f
\proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e} (\lambda f\ x.\ f_e (x+x))$
\end{prooftree}

即简单来说，将$f \proctr{\mathcal{N}|\mathcal{N}}{\K \T} f_e$ 作为过程条件的一部分。

