\chapter{Noesis 逻辑} \label{Ch.Noesis}

首先从本文的理论基础开始讨论，
这一章论述本文提出的 Noesis 逻辑，这是一种公理系统。
\ref{Sec.naive.noesis} 节先论述纯粹的也是最简单形式的 Noesis 逻辑，已经能
体现 Noesis 逻辑是如何连结起程序与抽象语义，并允许在演绎 Noesis 定理的同时
构造具有明确抽象语义的程序。
\ref{Sec.noesishol} 节论述 Noesis 逻辑在 HOL 逻辑上的实现，允许使用 HOL
定理证明器具体应用 Noesis 理论。为论述方便，HOL 逻辑上实现的 Noesis 逻辑
被叫做 \noesishol。

\section{朴素 Noesis 逻辑} \label{Sec.naive.noesis}

\begin{defin}[朴素 Noesis 逻辑]
朴素 Noesis 逻辑是一个形式系统，基于无类型 λ 演算。

无穷的字符串集合 $\hat{\mathcal{P}},\ \hat{\mathcal{E}} \subseteq 
\Words$ 分别表示{\phew}、抽象语义的字母集。
其上的 λ 表达式 $\mathcal{P},\ \mathcal{E}$ 分别为{\phew}集、抽象语义集。
  \[ \begin{array}{lcrcccccccl}
  \mathcal{P} &=& \bnf{&\hat{\mathcal{P}}&\mbar&
    (\mathcal{P}\ \mathcal{P})&
    \mbar&(\lambda\ \hat{\mathcal{P}}\ \mathcal{P})&\mbar&
    (\mathrm{Let}\ \hat{\mathcal{P}\ \mathcal{P}\ \mathcal{P}})&}\\
    \mathcal{E} &=& \bnf{&\hat{\mathcal{E}}&\mbar&
    (\mathcal{E}\ \mathcal{E})&
    \mbar&(\lambda\ \hat{\mathcal{E}}\ \mathcal{E})&\mbar&
    (\mathrm{Let}\ \hat{\mathcal{E}}\ \mathcal{E}\ \mathcal{E})&}
  \end{array} \]
朴素的 Noesis 逻辑不支持对理解的演算，理解是原子的，理解集 
$\mathcal{I} \subseteq \Words$ 是单词集。

\noindent Noesis 对应集 $N_1$
\[ N_1 = \bnf{\mathcal{P} \widesim{\mathcal{I}} \mathcal{E}} \]
Noesis 同构集 $N^*$
\[ N^* = \bnf{\mathcal{P} \proctr{\mathcal{I}|\cdots|\mathcal{I}}{}
\mathcal{E}} \]
Noesis 表达式是集合 $N = N_1 \cup N^*$。
上下文集合 $\Gamma_\mathrm{N} = \powerset(N_1)$。
Noesis 形式系统的形式语言 $L_\mathrm{N}$ 由语法 
\[ \Gamma_\mathrm{N} \vdash N \]
确定，其上的规则 $\vdash$ 如下

\vspace{5mm}

\hspace{-8mm}%
\begin{minipage}{0.25\linewidth} \begin{prooftree} \centering
    \AxiomC{\hfill}
    \RightLabel{(参数)}
    \UnaryInfC{$p \widesim{i} e \vdash p \widesim{i} e$}
\end{prooftree}\end{minipage}%
\begin{minipage}{0.4\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(一阶同构引入)}
    \UnaryInfC{$\Gamma \vdash p \proctr{i}{} e$}
\end{prooftree}\end{minipage}%
\begin{minipage}{0.3\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma \vdash p \proctr{i}{} e$}
    \RightLabel{(一阶同构削除)}
    \UnaryInfC{$\Gamma \vdash p \widesim{i} e$}
\end{prooftree}\end{minipage}%}

\vspace{3mm}

\begin{minipage}{0.45\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma_1 \vdash p \widesim{i} e$}
    \AxiomC{$\Gamma_2 \vdash f \proctr{i|j|\cdots|k}{} \phi$}
    \RightLabel{(应用)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash
    f\ p \proctr{j|\cdots|k}{} \phi\ e$}
\end{prooftree}\end{minipage}
\begin{minipage}{0.5\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma,\ p \widesim{i} e \vdash 
    f \proctr{j|\cdots|k}{} \phi$}
    \RightLabel{(抽象)}
    \UnaryInfC{$\Gamma \vdash \lambda p.\ f \proctr{i|j|\cdots|k}{}
    \lambda e.\ \phi$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(对应记号 $x$)}
  \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
  x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \widesim{i}  x_\mathrm{e}$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth} \begin{prooftree}
  \AxiomC{$\Gamma \vdash p \proctr{i|\cdots|k}{cond} e$}
    \RightLabel{(同构记号 $x$)}
  \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
  x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \proctr{i|\cdots|k}{cond}  x_\mathrm{e}$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
    \AxiomC{$\Gamma,\ x_\mathrm{p} = p,\ x_\mathrm{e} = e \vdash
     p' \widesim{i}  e'$}
    \RightLabel{(对应记号 $x$ 削除)}
    \UnaryInfC{$\Gamma \vdash \mathrm{Let}\ x_\mathrm{p}\ p\ p'
    \widesim{i} \mathrm{Let}\ x_\mathrm{e}\ e\ e'$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
  \AxiomC{$\Gamma,\ x_\mathrm{p} = p,\ x_\mathrm{e} = e \vdash
   p' \proctr{i|\cdots|k}{cond}  e'$}
  \RightLabel{(同构记号 $x$ 削除)}
  \UnaryInfC{$\Gamma \vdash \mathrm{Let}\ x_\mathrm{p}\ p\ p'
  \proctr{i|\cdots|k}{cond} \mathrm{Let}\ x_\mathrm{e}\ e\ e'$}
\end{prooftree}\end{minipage}

\vspace{6mm}

\noindent 
形式系统朴素 Noesis 就是形式语言 $L_\mathrm{N}$ 和规则 $\vdash$ 
构成的形式系统。
\end{defin}

单独的对应并没有任何意义，理解可以任意地构造以将任何程序对应到
任何抽象语义。
%单独的指称并没有任何意义，理解可以肆意捏造以将任意的现象对应到
%任何本体，例如一些诡异的理解可以将黑指代为白，而将鹿指代为马。
意义体现在同构(Homomorphism)，任意设定的{\it 理解} $i$，当其确定
，若能证明程序过程$p$ 输入理解$i$下对应到抽象语义$\epsilon$的值，
会输出在理解$j$下对应到抽象语义 $f(\epsilon)$ 的值，则此函数的抽象语义
就被理解 $i,\ j$ 确定，即 $f$。
例如某个定理表明名程序 Add 当输入理解 $\mathcal{N}$ 下
对应 $x$ 和 $y$ 的值时，其中$x, y$ 是自然数，
就能输出在解释 $\mathcal{N}$ 下对应 $x + y$ 的值，
程序 Add 满足了 Noesis 对应的同构，
该情形下对应着自然数加法。
%那么不需要讨论理解 $\mathcal{N}$ 的本质为
%何没有任何意义，不需要纠结它的本体论问题，只要某段程序过程
%满足某几个解释的 Noesis 对应的同构，就足够表明这段过程的抽象语义。
这种同构叫做 {\it Noesis 同构}，在朴素 Noesis 逻辑中使用记号 
$\proctr{i|j|\cdots|k}{}$ 表达，
例如$\mathrm{Add} \proctr{\mathcal{N}|\mathcal{N}|\mathcal{N}}{} (+)$。



%其中 $cond$ 表示过程 Add 执行的条件。
%
%
%部分简单形式能用记号 
%$\proctr{i|j|\cdots|k}{cond}$ 表达，
%例如$\mathrm{Add} \proctr{\mathcal{N}|\mathcal{N}|\mathcal{N}}{cond} (+)$，
%其中 $cond$ 表示过程 Add 执行的条件。更通用的
%\[ f \proctr{i|j|\cdots|k}{cond} \psi \]
%表示程序过程 $f$ 拥有参数的理解为 $i,j,\cdots$ 返回值的理解为 $k$ 
%的 Noesis 对应的同构并同构于抽象的 $\psi$ ，且执行条件为 $cond$。


\section{HOL 逻辑上的 Noesis 逻辑 \noesishol} \label{Sec.noesishol}

形式系统 \noesishol 构建在 HOL 逻辑的基础上，
是朴素 Noesis 形式系统在 HOL 逻辑上的实现。
该实现通过在 HOL 逻辑上定义表示理解的类型与表示 Noesis
对应及 Noesis 同构的谓词完成。\noesishol 允许理解的运算，这点是朴素
Noesis 逻辑的扩广，例如那些产生理解的 HOL 函数，
诸如理解的并、序列的理解等。

下面将逐步在 HOL 逻辑上定义{\phew}与理解，而抽象语义是
任意 HOL 逻辑上的数学对象，包括定义在 HOL 逻辑上的{\phew}与理解本身。

\begin{defin}[{\phew}类型] \label{Def.phenomenon}
HOL 逻辑上的类型 phenomenon 表示 \noesishol 的{\phew}，
根据不同的具体实现可以不同方式具体定义，不同的具体定义不影响本章理论。

特别的，phenomenon 类型中需要包含一个零元素$\mathrm{p}_0$，
表示计算客体中不需要被任何实在的{\phew}表示而自然地于背景中存在，
例如0个二进制位或者C语言的void类型。
\end{defin}

\begin{defin}[到$\alpha$的理解] \label{Def.itp} 
类型 $\itp{\alpha}$ 是{\phew}到类型为 $\alpha$ 的抽象语义的理解，
包含可以构建{\phew}与抽象语义间联系的映射。
    \[ \begin{split}
        \itp{\alpha} \Coloneqq \mathbf{Noesis}\ &(\alpha \rightarrow \phenomenon)
        \ (\phenomenon \rightarrow \alpha)\\
        &(\alpha\ \mathrm{set})\ (\phenomenon\ \mathrm{set})
    \end{split} \]
    \begin{align*}
        \mathbf{NOE\_LIGHT}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = l&
        \mathbf{NOE\_TRANSCEND}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = tr&\\
        \mathbf{NOE\_SET}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = s&
        \mathbf{NOE\_PSET}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = s_p&
    \end{align*}
\end{defin}

$\itp{\alpha}$ 表示一个将{\phew}对应为某种 $\alpha$ 类型的抽象语义的理解。
例如{\phew}到布尔值间的 Noesis 对应就要届由到 bool 类型的理解来完成。
$\mathbf{Noesis}\ l\ tr\ s\ s_p$ 构建了这样一个理解，$l$是投影函数，确定抽象语义到
{\phew}的映射；$tr$ 是超越函数，确定{\phew}到抽象语义的映射；$s$ 是抽象语义集合，
有 $s \subseteq \mathrm{dom}\ l \land s \subseteq \mathrm{rng}\ tr$；
$s_p$ 是{\phew}集合，有 $s_p \subseteq \mathrm{dom}\ tr \land s_p \subseteq \mathrm{rng}\ l$
，一个理解即是上述的四元组。


\begin{notation}[理解的相关属性的简写记号]
\begin{align*}
    \mathbf{Li}_i\ & \coloneqq \mathbf{NOE\_LIGHT}\ i
    & \mathbf{Tr}_i\ & \coloneqq \mathbf{NOE\_TRANSCEND}\ i \\
    \mathbf{Se}_i\ & \coloneqq \mathbf{NOE\_SET}\ i
    & \mathbf{Sp}_i\ & \coloneqq \mathbf{NOE\_PSET}\ i
\end{align*}
\end{notation}

\begin{defin}[到$\alpha$的有效理解] \label{Def.Vi}
\[ \begin{split}
    \mathbf{VALID\_NOE}\ i \coloneqq\ &
    (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e)) \\
    & \land\ (\forall p.\ p \in \mathbf{Sp}_i \Rightarrow \mathbf{Tr}_i\ p \in 
    \mathbf{Se}_i)
\end{split} \]
\end{defin}

\begin{notation}[有效理解的简写]
    \[ \mathbf{V}_i \coloneqq \mathbf{VALID\_NOE}\ i \]
\end{notation}

即 $\mathbf{V}_i$ 意味着 $\mathbf{Li}_i$ 是 $\mathbf{Se}_i$ 到 $\mathbf{Sp}_i$ 的单射，
$\mathbf{Tr}_i$ 是 $\mathbf{Sp}_i$ 到 $\mathbf{Se}_i$ 的满射，
$\mathbf{Tr}_i$ 是 $\mathbf{Li}_i$ 的逆函数。

\begin{example}[到bool的有效理解的样例]
\[ \begin{split}
    \mathbb{B}_\mathrm{I} \coloneqq\ & \mathbf{Noesis}\ (\lambda e.\ \mathbf{if}\ e\ 
    \mathbf{then}\ 1\ \mathbf{else}\ 0) \\
& (\lambda p.\ \mathbf{if}\ p=0\ \mathbf{then}\ \mathrm{F}\ \mathbf{else}\ \mathrm{T})\quad
   \{\mathrm{T},\ \mathrm{F}\}\quad \mathbb{N}
\end{split} \]
\end{example}

\begin{defin}[ Noesis 对应关系] \label{Def.TR}
定义三元关系 $ p \widesim{i} e$ 表示{\phew}与抽象语义在某种理解下的的对应关系。
\[ p \widesim{i} e \coloneqq \mathbf{V}_i \land p \in \mathbf{Sp}_i \land
    (\mathbf{Tr}_i\ p = e)\]
\end{defin}

某个成立的 Noesis 对应关系可以用 HOL 逻辑证明。

\begin{prooftree}
    \AxiomC{$\cdots$} 
    \RightLabel{对于某个成立的 $p \widesim{i} e$\quad\quad( Noesis 对应的证明律)} \doubleLine
    \UnaryInfC{$\vdash p \widesim{i} e$}
\end{prooftree}

由此构建了程序的语义感知（Semantic Reasoning）的基础，即在理解方式$i$下可以将
计算客体$p$解释成$e$，而$e$即$p$在理解方式$i$下的语义。

一个{\phew}对于一个理解只有确定的一个抽象语义，但一个{\phew}可以同时具有多种理解，
而{\phew}上的一次计算可以同时带有多个含义。例如{\phew}1可以在布尔理解下对应真，
也可以在自然数理解下对应自然数1，也可以是某种有序集的理解下的第一个元素。

%\begin{theo}[Noesis 对应的一些性质]
%\begin{align*}
%  \forall p\ i\ e.\ p \widesim{i} e \Rightarrow
%    e \in \mathbf{Se}_i
%\end{align*}
%\end{theo}
%\begin{proof} 由定义 \ref{Def.Vi} 直接得到。
%\end{proof}

\begin{defin}[理解的合并] \label{Def.I*}
一个到 $\alpha$ 的理解$i_a$与到 $\beta$ 的理解$i_b$可以合并成
    到二元组$(\alpha,\beta)$的理解 $i_a \cdot i_b$
\[
    \forall l_a\ l_b\ a\ b.\ (l_a\ a = l_b\ b) \Rightarrow
    (\dot{\mathbf{l}}\ l_a\ l_b\ a\ b = l_a\ a )
\]
\begin{equation} \begin{split}
    (\mathbf{Noesis}\ & l_a\ tr_a\ s_a\ sp_a)\ \cdot\ 
    (\mathbf{Noesis}\ l_b\ tr_b\ s_b\ sp_b) \coloneqq \\
    & \mathbf{Noesis}\ (\dot{\mathbf{l}}\ l_a\ l_b)\ 
        (\lambda p.\ (tr_a\ p,\ tr_b\ p))\ \\
    & \quad\quad\quad (s_a \times s_b \cap (\lambda (a,\ b).\ l_a\ a = l_b\ b))\ 
    (sp_a \cap sp_b)
\end{split} \end{equation}
\end{defin}

这样合并的意义在于，多个基于不同理解的Noesis 对应，可以将这些不同的理解合并而表示为一个Noesis 对应。

\begin{theo}[理解合并的有效性] \label{T.V.IMerge}
\begin{equation}
    \mathbf{V}_a \land \mathbf{V}_b \Rightarrow \mathbf{V}_{a\cdot b}
\end{equation}
\end{theo}
\begin{proof}
\begin{align*}
    \mathbf{V}_{a\cdot b} =\ & (\forall e_a\ e_b.\ e_a \in \mathbf{Se}_a \ \ \land \ \ 
    e_b \in \mathbf{Se}_b \ \ \land \ \ 
    (\mathbf{Li}_a\ e_a = \mathbf{Li}_b\ e_b) \ \ \Rightarrow \\
    & \quad\quad\quad \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \cap \mathbf{Sp}_b \ \ \land
    \ \ (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a) \ \ \land \ \ 
    (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_a \ \ \land \ \ p \in \mathbf{Sp}_b
    \Rightarrow \mathbf{Tr}_a\ p \in \mathbf{Se}_a \ \ \land \ \ \mathbf{Tr}_b\ p \in 
      \mathbf{Se}_b ) \\
    \mathbf{V}_a =\ & (\forall e_a.\ e_a \in \mathbf{Se}_a \Rightarrow
      \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \ \ \land \ \ 
      (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_a \Rightarrow \mathbf{Tr}_a\ p \in 
      \mathbf{Se}_a) \\
\mathbf{V}_b =\ & (\forall e_b.\ e_b \in \mathbf{Se}_b \Rightarrow
      \mathbf{Li}_b\ e_b \in \mathbf{Sp}_b \ \ \land \ \ 
      (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_b \Rightarrow \mathbf{Tr}_b\ p \in
      \mathbf{Se}_b) \\
\mathbf{V}_a,\ & \mathbf{V}_b,\ e_a \in \mathbf{Se}_a,\ e_b \in \mathbf{Se}_b,\ 
    \mathbf{Li}_a\ e_a = \mathbf{Li}_b\ e_b \ \vdash \ 
    \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \cap \mathbf{Sp}_b \\
    & \quad\quad\quad\quad \land (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a) \land
    (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b) \\
\mathbf{V}_a,\ & \mathbf{V}_b,\ p \in \mathbf{Sp}_a,\ p \in \mathbf{Sp}_b\ \vdash\ 
    \mathbf{Tr}_a\ p \in \mathbf{Se}_a\ \ \land \ \ \mathbf{Tr}_b\ p \in \mathbf{Se}_b \\
\mathbf{V}_a,\ &\mathbf{V}_b \vdash \mathbf{V}_{a \cdot b}
\end{align*}
\end{proof}

\begin{theo}[理解合并对于 Noesis 对应的同构]
\begin{equation}
    \forall i_a\ i_b\ p\ e_a\ e_b.\ p \widesim{i_a} e_a \land p \widesim{i_b} e_b = 
    p \widesim[2]{i_a \cdot i_b} (e_a,\ e_b) 
\end{equation}
\end{theo}

\begin{proof}
\[ p \widesim[2]{ia \cdot ib} (e_a,\ e_b) =\ \mathbf{V}_{ia\cdot ib} \land p \in 
    (\mathbf{Sp}_{ia} \cap \mathbf{Sp}_{ib}) \land 
    (\mathbf{Tr}_{ia}\ p = e_a) \land (\mathbf{Tr}_{ib}\ p = e_b) \]
结合定义\ref{Def.TR}以及理解合并的有效性定理\ref{T.V.IMerge}
\[p \widesim[2]{ia \cdot ib} (e_a,\ e_b) = p \widesim{i_a} e_a \land p \widesim{i_b} e_b \]
\end{proof}

由合并的理解的 Noesis 对应就可以提取出其中各个理解的 Noesis 对应。

\begin{gather*}
    p \widesim{i_1 \cdot i_2} (e_1,\ e_2) \Rightarrow p \widesim{i_1} e_1 \\
    p \widesim{i_1 \cdot i_2} (e_1,\ e_2) \Rightarrow p \widesim{i_2} e_2
\end{gather*}

\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
    \RightLabel{(合并分解律1)}
\UnaryInfC{$\Gamma \vdash p \widesim{i_1} e_1$}
\end{prooftree}
\end{minipage}%
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
    \RightLabel{(合并分解律2)}
\UnaryInfC{$\Gamma \vdash p \widesim{i_2} e_2$}
\end{prooftree}
\end{minipage}

\begin{prooftree}
\AxiomC{$\Gamma_1 \vdash p \widesim{i_1} e_1$}
\AxiomC{$\Gamma_2 \vdash p \widesim{i_2} e_2$}
    \RightLabel{(合并律)}
\BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
\end{prooftree}

\begin{theo}[理解合并在 Noesis 对应上的交换律同构与结合律同构]
\begin{gather*}
    \forall e_a\ e_b\ i_a\ i_b\ p.\ p \widesim[2]{i_a \cdot i_b} (e_a,\ e_b) =
        p \widesim[2]{i_b \cdot i_a} (e_b,\ e_a) \\
    \forall e_a\ e_b\ e_c\ i_a\ i_b\ i_c\ p.\ p \widesim[4]{(i_a \cdot i_b) \cdot i_c}
    ((e_a,\ e_b),\ e_c) = p \widesim[4]{i_a \cdot (i_b \cdot i_c)} (e_a,(e_b,\ e_c))
\end{gather*}
\end{theo}

\begin{proof} 显然，略
\end{proof}

下面论述 Noesis 同构，其描述函数映射的原像与像具有某种可能不同的 Noesis 对应
或与 Noesis 对应相关的性质。
\noesishol 上的 Noesis 同构相比朴素 Noesis 逻辑的
有所扩广，是一个宽泛的概念。如下是 Noesis 同构最简单的形式，
其中 $f_p$ 同构于 $f_e$，
\[ \forall p\ e.\ p \widesim{i} e \Rightarrow f_p\ p \widesim{j} f_e\ e \]
Noesis 同构还可以具有条件 $cond$，
\[ \forall p\ e.\ p \widesim{i} e \Rightarrow f_p\ p \Rightarrow cond\ e
\widesim{j} f_e\ e \]
可以是高阶形式，
\[ \forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow \forall y_p\ y_e.\ 
y_p \widesim{i} y_e \Rightarrow cond\ x_e\ y_e \Rightarrow f_p\ x_p\ y_p \widesim{j} 
f_e\ x_e\ y_e \]
以及一个更复杂的，
\[ \forall g_p\ g_e.\ (\forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow 
g_p\ x_p \widesim{j} g_e\ x_e) \Rightarrow cond\ g_e \Rightarrow
f_p\ g_p \widesim{k} f_e\ g_e \]
以上 $f_p$ 均同构于 $f_e$ 。

\begin{defin}[Noesis 同构] 这里给出 Noesis 同构的严谨定义。
  $f_p$ 是{\phew}的函数或者是{\phew}的函数的函数以及各种高阶函数的函数，即
  $f_p$ 可以具有类型 $\mathrm{phenomenon} \rightarrow \mathrm{\phenomenon}$
  或 $\mathrm{phenomenon} \rightarrow \mathrm{phenomenon} \rightarrow \mathrm{phenomenon}$
  或 $(\mathrm{phenomenon} \rightarrow \mathrm{phenomenon})
\rightarrow \mathrm{phenomenon}$ 等等。当 $f_p$ 与抽象语义 $f_e$ 间的二元关系 $H$
具有如下形式，则是一种 $f_p,f_e$ 间的 Noesis 同构。
  \[ \forall p\ e.\ p\ R\ e \Rightarrow f_p\ p\ H'\ f_e\ e\]
其中 $p$ 是{\phew}或者{\phew}的各种高阶函数，$e$ 是作为抽象语义的任意对象，$R$ 是任意某种二元关系，
多数情况下是某种理解 $i$ 的 Noesis 对应 $\widesim{i}$，$H'$ 是某种理解 $l$ 的 Noesis
对应 $\widesim{i}$ 或者另一个不等于 $H$ 的 Noesis 同构。
$f_p,f_e$ 间的所有的 Noesis 同构均是具有上述形式满足上述要求的二元关系。
Noesis 同构即被递归定义完成。
\end{defin}

\begin{notation}[过程的 Noesis 同构记号] \label{def.proctr}
记号 $f_p \proctr{i}{cond} f_e$ 表示有条件的 Noesis 对应。
记号 $f_p \proctr{a_e \sim i|j}{cond} f_e$ 表示一种只有1个参数的且以
$cond$为条件的过程的 Noesis 同构，记号
$f_p \proctr{e_1 \sim i_1 | \cdots | e_n \sim i_n|j}{cond} f_e$ 表示一种有 $n$ 个参数的
过程的且条件为 $cond$的 Noesis 同构。
\begin{gather*}
    p \proctr{i}{cond} e \coloneqq \ (cond \Rightarrow p \widesim{i} e) \\
    \begin{array}{lcrll}
      f_p\ &\proctr{a_e \sim i|j}{cond}&
      (f_e:\alpha \rightarrow \beta) &\coloneqq&
    (\forall a_p\ a_e.\quad  a_p \widesim{i} a_e \Rightarrow cond\ a_e \Rightarrow
    f_p\ a_p \widesim{j} f_e\ a_e) \\
      f_p\ &\proctr{a_e|j}{cond}&
      (f_e:\alpha \rightarrow \beta) &\coloneqq&
    (\forall a_p\ a_e.\quad  a_p \widesim{i} a_e \Rightarrow cond\ a_e \Rightarrow
    f_p\ a_p \widesim{j} f_e\ a_e)
    \end{array}  \\ \begin{split}
    f_p\  \proctr{a_e \sim i | \cdots | c_e \sim k | l}{cond} &
    (f_e:\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow \delta) \coloneqq \\
    (\forall a_p\ a_e.\ a_p \widesim{i} a_e \Rightarrow\ &\forall b_p\ c_p.
    \ b_p \widesim{j} b_e \Rightarrow \cdots \Rightarrow cond\ a_e\ \cdots\ c_e 
    \Rightarrow  \\
    & f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e)
    \end{split} \\ \begin{split}
    f_p\  \proctr{i | \cdots | k | l}{cond} &
    (f_e:\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow \delta) \coloneqq \\
    (\forall a_p\ a_e.\ a_p \widesim{i} a_e \Rightarrow\ &\forall b_p\ c_p.
    \ b_p \widesim{j} b_e \Rightarrow \cdots \Rightarrow cond\ a_e\ \cdots\ c_e 
    \Rightarrow  \\
    & f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e)
    \end{split}
\end{gather*} 
    $cond$ 表示过程正确执行的条件。
    对于$\proctr{a \sim i | \cdots | c \sim k | l}{cond}$ 若理解
    $i, \cdots, k$ 的类型分别为 \[\itp{\alpha},\ \cdots,\ \itp{\gamma}\]
    那么 $cond$ 的类型为 $\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow 
    \mathrm{bool}$，即 $cond$ 是在抽象语义层面上描述执行条件。

    此处的记号仅是 Noesis 同构的一种表达记号，仅用于易于理解与增加可读性，
    只能表达一部分 Noesis 同构，一些复杂的 Noesis 同构例如
\[ \forall g_p\ g_e.\ (\forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow 
g_p\ x_p \widesim{j} g_e\ x_e) \Rightarrow cond\ g_e \Rightarrow
f_p\ g_p \widesim{k} f_e\ g_e \]
无法用这种记号表达。
\end{notation}

    过程的 Noesis 对应同构构成了一种契约，
    当输入参数可以被约定的理解$i,\cdots,k$解释，
    且解释后的意义也即抽象语义$a_e,\cdots,c_e$满足给定的条件时，
那么此过程可以正确执行，并返回以约定的理解$l$的解释下对应抽象语义$f\ a_e\ \cdots\ c_e$ 的{\phew}。


上述记号具有如下的递归形式。
\begin{equation} \label{f.proctr_rec} \begin{split}
    f_p \proctr{a_e \sim i|b_e \sim j|\cdots|l}{cond} f_e = 
    (\forall a_p\ a_e.\quad a_p \widesim{i} a_e \Rightarrow f_p\ a_p 
    \proctr{b_e \sim j|\cdots|l}{cond\ a_e} f_e\ a_e)
\end{split} \end{equation}

Noesis 同构中的理解 $i \cdots k$ 与抽象语义 $a \cdots c$ 可以相互依赖。
首先抽象语义可以依赖于抽象语义。
其次理解可以依赖于理解，可以由一个理解计算得出。序列的增加是一个例子
\[ \mathbf{Append} \proctr{x \sim i | l \sim \ListI\ i | 
\ListI i}{\lambda x\ l.\ \T} (::) \]
将 Noesis 同构记号展开后
\[ \forall i\ x_p\ x.\ x_p \widesim{i} x \Rightarrow \forall l_p\ l.\ 
  l_p \widesim[2]{\ListI\ i} l \Rightarrow \mathbf{Append}\ x_p\ l_p
  \widesim[2]{\ListI\ i} x::l \]
是合法的 HOL 逻辑表达式。
第三，理解可以依赖于抽象语义，若 $\mathcal{N}^{\leq}_n$ 表示所有不超过 $n$ 的自然
数的抽象语义集的理解，自然数减法 $\mathbf{NSub}$ 的 Noesis 同构可以表达为
\[ \mathbf{NSub} \proctr{a \sim \mathcal{N}^{\leq}_n|b \sim
\mathcal{N}^{\leq}_a|\mathcal{N}^{\leq}_a}{\lambda a\ b.\ \T} (-) \]
记号展开后是
\[ \forall n\ a_p\ a.\ a_p \widesim[2]{\mathcal{N}^\leq_n} a
\Rightarrow \forall b_p\ b.\ b_p \widesim[2]{\mathcal{N}^\leq_a} b \Rightarrow
\mathbf{NSub}\ a_p\ b_p \widesim[2]{\mathcal{N}^\leq_a} a - b \]
也是合法的。最后抽象语义可以依赖于理解，
\[ f_p \proctr{a\sim \mathcal{N}^\leq_n|\mathcal{N}^\leq_n}
{\K \T} (\lambda a.\ n - a) f_e \]
展开后是
\[ \forall n\ a_p\ a.\ a_p \widesim[2]{\mathcal{N}^\leq_n} a
\Rightarrow f_p\ a_p \widesim[2]{\mathcal{N}^\leq_n} (\lambda a.\ 
n - a) \]

因为理解与抽象语义以及{\phew}均是 HOL 逻辑上普通的数理对象，所以可以
相互依赖。这一点揭示出类似依赖类型（Dependent Type）的性质。
而在实际使用中，一般很少会抽象语义依赖理解或理解依赖抽象语义
，一般只是理解依赖理解。在最后一章的结论中会指出，理解承载{\phew}的
共性，而抽象语义承载{\phew}的共性在内的全部特性，所以理解是不需要非常精细的，
并不像依赖类型系统的语言使用类型描述值的性质，Noesis 逻辑中是{\phew}由理解
对应到抽象语义而抽象语义体现{\phew}的性质，所以 Noesis 逻辑中不是特别需要理解与
抽象语义互相依赖，尽管这是可以做到的。一般在 Noesis 同构的记号中省略
抽象语义的部分，将 $\proctr{a \sim i|b \sim j|\cdots|k}{cond}$
简写为 $\proctr{i|j|k}{cond}$。而将一些必要的抽象语义限制放在 $cond$ 中，
上述的 $\mathbf{NSub}$ 更常用的 Noesis 同构是
\[ \mathbf{NSub} \proctr{\mathcal{N}^\leq_n|\mathcal{N}^\leq_n|
\mathcal{N}^\leq_n}{\lambda a\ b.\ a \geq b} (-) \]
展开后的表达是
\[ \forall n\ a_p\ a_e.\ a_p \widesim[2]{\mathcal{N}^\leq_n}
 a_e \Rightarrow \forall b_p\ b_e.\ b_p \widesim[2]{\mathcal{N}^\leq_n} b_e \Rightarrow
 a_e \geq b_e \Rightarrow
 \mathbf{NSub}\ a_p\ b_p \widesim[2]{\mathcal{N}^\leq_n} a_e - b_e\]
充分利用调用条件 $cond$ 就基本不需要抽象语义与理解互相依赖。

下面论述 \noesishol 上的调用律、抽象律、一阶同构引入律、一阶同构削除律、
记号律、记号削除律。这些演绎律可以易于理解地表达如下，尽管这些表达并不完整。
\footnotetext[1]{准确地说 \noesishol 上的调用律就是 HOL 逻辑的 MATCH\_MP
    律，此处的形式是 MATCH\_MP 的应用，更具有可读性，但并非所有的调用律的应用都具有
    这种形式。MATCH\_MP 律才是完整的 \noesishol 上的调用律。}
\footnotetext[2]{同样 \noesishol 上的抽象律是 HOL 逻辑的 DISCH 律，此处的形式也是为了
可读性。}

\begin{center}
    \AxiomC{$\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e$}
    \AxiomC{$\Gamma_2 \vdash a_p \widesim{i} a_e$}
    \RightLabel{(调用\footnotemark[1])}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash f_p\ a_p \proctr{j|\cdots|l}{cond\ a_e}
      f_e\ a_e$}
\DisplayProof

  \vspace{\baselineskip}
    \AxiomC{$\Gamma_1,\ a_p \widesim{i} a_e \vdash b_p \proctr{j|\cdots|l}{cond} b_e$}
    \RightLabel{(抽象\footnotemark[2])}
    \UnaryInfC{$\Gamma_1 \vdash (\lambda a_p.\ b_p)
      \proctr{i|j|\cdots|l}{\lambda a_e.\ cond\ a_e} (\lambda a_e.\ b_e)$}
\DisplayProof

\vspace{\baselineskip}
\begin{tabular}{c c}
    \AxiomC{$\Gamma, cond \vdash p \widesim{i} e$}
    \RightLabel{(一阶同构引入)}
    \UnaryInfC{$\Gamma \vdash p \proctr{i}{cond} e$} \DisplayProof &
    \AxiomC{$\Gamma_1 \vdash p \proctr{i}{cond} e$}
    \AxiomC{$\Gamma_2 \vdash cond$}
    \RightLabel{(一阶同构削除)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash p \widesim{i} e$} \DisplayProof
\end{tabular}

\vspace{\baselineskip}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(对应记号 $x$)}
    \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
    x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \widesim{i}  x_\mathrm{e}$} \DisplayProof

\vspace{\baselineskip}
  \AxiomC{$\Gamma \vdash p \proctr{i|\cdots|k}{cond} e$}
    \RightLabel{(同构记号 $x$)}
    \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
    x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \proctr{i|\cdots|k}{cond}  x_\mathrm{e}$} \DisplayProof

\vspace{\baselineskip}
  \AxiomC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (x_\mathrm{e} = e 
  ))\vdash p' \widesim{i}  e'$}
    \RightLabel{(对应记号 $x$ 削除)}
  \UnaryInfC{$\Gamma \vdash \mathrm{Let}\ p\ (\lambda x_\mathrm{p}.\ p')
    \widesim{i} \mathrm{Let}\ e\ (\lambda x_\mathrm{e}.\ e')$}\DisplayProof
\end{center}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
  \AxiomC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (x_\mathrm{e} = e))
  \vdash p' \proctr{i|\cdots|k}{cond}  e'$}
  \RightLabel{(同构记号 $x$ 削除)}
\UnaryInfC{$\Gamma \vdash \mathrm{Let}\ p\ (\lambda x_\mathrm{p}.\ p')
\proctr{i|\cdots|k}{cond} \mathrm{Let}\ e\ (\lambda x_\mathrm{e}.\ e')$}
\end{prooftree}\end{minipage}

\vspace{6mm}

\noindent 其中 Let 是 HOL 上定义的 Let。

这些演绎律全部是 HOL 逻辑中已有演绎律的复合，\noesishol 本身不引入
新的演绎律，所以 \noesishol 作为一个形式系统其实是 HOL 逻辑的一种应用。

下面将论述如何由已有的 HOL 逻辑的演绎律复合出上述 \noesishol 的规则。
\noesishol 调用律是 HOL 逻辑中的 MATCH\_MP 律，MATCH\_MP 的意味是自动匹配全称量化
的肯定前件（Modus Ponens with quantification matching）。
将 \[\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e \]
的同构记号展开，注意 $a_p',b_p'$ 上的撇号与接下来的 $a_p,b_p$ 区分
\[\begin{split} \Gamma_1 \vdash \forall a_p'\ a_e'.\ a_p' \widesim{i} a_e' &\Rightarrow
    \forall b_p\ b_e.\ b_p \widesim{j} b_e \Rightarrow
    \cdots \Rightarrow\\ &cond\ a_e'\ b_e\ \cdots \Rightarrow f_p\ a_p'\ b_p\ \cdots
\widesim{l} f_e\ a_e'\ b_e\ \cdots \end{split}\]
对 $\Gamma_2 \vdash a_p \widesim{i} a_e$ 进行 MATCH\_MP 律得到
\[\begin{split} \Gamma_1 \cup \Gamma_2 \vdash \forall b_p\ &b_e.\ b_p \widesim{j} 
  b_e \Rightarrow
    \cdots \Rightarrow\\ &cond\ a_e\ b_e\ \cdots \Rightarrow f_p\ a_p\ b_p\ \cdots
\widesim{l} f_e\ a_e\ b_e\ \cdots \end{split}\]
即同构记号下的
\[\Gamma_1 \cup \Gamma_2 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e \]
MATCH\_MP 是 \noesishol 上的调用律，却并不局限于这种形式，
\begin{sprooftree}
    \AxiomC{$\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e$}
    \AxiomC{$\Gamma_2 \vdash a_p \widesim{i} a_e$}
    \RightLabel{MATCH\_MP}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash f_p\ a_p \proctr{j|\cdots|l}{cond\ a_e}
      f_e\ a_e$}
\end{sprooftree}
对于更复杂的 Noesis 同构，例如
\[ \forall g_p\ g_e.\ (\forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow 
cong_g\ x_e \Rightarrow
g_p\ x_p \widesim{j} g_e\ x_e) \Rightarrow cond\ g_e \Rightarrow
f_p\ g_p \widesim{k} f_e\ g_e \]
由 MATCH\_MP 律实现的 \noesishol 的调用律以 $g_p' \proctr{i|j}{cond_g} g_e'$ 作为参数
调用可以得到
\[ f_p\ g_p \proctr{k}{cond_g\ g_e} f_e\ g_e \]
%非常有趣。如果非要用
必须用某个记号表达的话，$f_p,f_e$ 间的同构也许适合表达为
\[ f_p \proctr{\proctr{i|j}{cond_g}|k}{cond} f_e \]

\noesishol 上的抽象律就是 HOL 逻辑的 DISCH 律
\begin{sprooftree}
    \AxiomC{$\Gamma,\ a_p \widesim{i} a_e \vdash b_p \proctr{j|\cdots|k}{cond} b_e$}
    \RightLabel{DISCH\ $a_p \widesim{i} a_e$}
\UnaryInfC{$\Gamma \vdash a_p \widesim{i} a_e \Rightarrow b_p \proctr{j|\cdots|k}{cond} 
  b_e$}
  \RightLabel{即是}
    \UnaryInfC{$\Gamma \vdash \lambda a_p.\ b_p \proctr{i|j|\cdots|k}{\lambda a_e.\ cond} 
    \lambda a_e.\ b_e$}
\end{sprooftree}

最后一阶同构引入律也是 DISCH 律，一阶同构削除律是 MATCH\_MP 律。

记号律
\begin{sprooftree}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(对应记号 $x$)}
    \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
    x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \widesim{i}  x_\mathrm{e}$}
\end{sprooftree}
是由 ASSUME 律得到
\[ (x_p = p)\ \land\ (x_e = e)\vdash (x_p = p)\ \land\ (x_e = e) \]
再 CONJUNCT1 律与 CONJUNCT2 律分别得到
\begin{align*}
  (x_p = p)\ \land\ (x_e = e)&\vdash x_p = p&
  (x_p = p)\ \land\ (x_e = e)&\vdash x_e = e&
\end{align*}
而后依次 EQ\_MP 律即是。

记号削除律简单地就是
\[\begin{split}
  \mathrm{MATCH\_MP}\ (\ \vdash &(\forall p\ p'\ e\ e'\ R.\ ((p = p')\ \land\ 
  (e = e')) \Rightarrow p\ R\ e) \\&\Rightarrow
(\mathrm{let}\ p = p';\ e = e'\ \mathrm{in}\ p\ R\ e)) \end{split} \]

%又也许理解可以尝试地作为这样一种类型，但问题在于，任何一个{\phew}都可以被应用于大量的理解
%——只要{\phew}在理解的{\phew}集内就行，若尝试将理解作为类型，就意味着每一个{\phew}都可以属于大量的类型，
%这显然是荒谬的。

%本文对所有将 Noesis 对应描述成某种类型系统的尝试都失败了。根本在于，类型是一种对值的分类，
%以良好地提取维护值的部分性质；
%但本文的思路， Noesis 对应根本不尝试对值分类，而是尝试显式地确定理解方式而找到值对应的以某种
%数理对象表示的意义，进而提取出值在该理解下的全部性质。
%这与与指称语义（Denotational semantics）非常相似。

%指称语义尝试建立起程序与数学函数的对应关系，跟 Noesis 对应非常相似。
%但$\amlh$的优势在于程序的抽象，基于$\lamst$使得程序本身亦是抽象的结构。
%这导致一些重要的区别，指称语义在递归定义的函数与数据结构上遇到的困难带领指称语义
%走向了域理论，而对于$\amlh$，不使用域理论而
%是在？？？节将看到递归与归纳（Induction）间的内在联系。
%指称语义与 Noesis 对应尝试实现类似的目标，但解决思路与方式完全不同。

