%\section{Noesis 系统}
\section{朴素 Noesis 系统}

\begin{defin}[朴素 Noesis 系统]
朴素 Noesis 系统是一个形式系统，基于无类型 λ 演算。

无穷的字符串集合 $\hat{\mathcal{P}},\ \hat{\mathcal{E}} \subseteq 
\Words$ 分别表示现象、本体的字母集。
其上的 λ 表达式 $\mathcal{P},\ \mathcal{E}$ 分别为现象集、本体集。
  \[ \begin{array}{lcrcccccccl}
  \mathcal{P} &=& \bnf{&\hat{\mathcal{P}}&\mbar&
    (\mathcal{P}\ \mathcal{P})&
    \mbar&(\lambda\ \hat{\mathcal{P}}\ \mathcal{P})&\mbar&
    (\mathrm{Let}\ \hat{\mathcal{P}\ \mathcal{P}\ \mathcal{P}})&}\\
    \mathcal{E} &=& \bnf{&\hat{\mathcal{E}}&\mbar&
    (\mathcal{E}\ \mathcal{E})&
    \mbar&(\lambda\ \hat{\mathcal{E}}\ \mathcal{E})&\mbar&
    (\mathrm{Let}\ \hat{\mathcal{E}}\ \mathcal{E}\ \mathcal{E})&}
  \end{array} \]
朴素的 Noesis 系统不支持对理解的演算，理解是原子的，理解集 
$\mathcal{I} \subseteq \Words$ 是单词集。

\noindent Noesis 对应集 $N_1$
\[ N_1 = \bnf{\mathcal{P} \widesim{\mathcal{I}} \mathcal{E}} \]
Noesis 同构集 $N^*$
\[ N^* = \bnf{\mathcal{P} \proctr{\mathcal{I}|\cdots|\mathcal{I}}{}
\mathcal{E}} \]
Noesis 表达式是集合 $N = N_1 \cup N^*$。
上下文集合 $\Gamma_\mathrm{N} = \powerset(N_1)$。
Noesis 形式系统的形式语言 $L_\mathrm{N}$ 由语法 
\[ \Gamma_\mathrm{N} \vdash N \]
确定，其上的规则 $\vdash$ 如下

\vspace{5mm}

\hspace{-8mm}%
\begin{minipage}{0.25\linewidth} \begin{prooftree} \centering
    \AxiomC{\hfill}
    \RightLabel{(参数)}
    \UnaryInfC{$p \widesim{i} e \vdash p \widesim{i} e$}
\end{prooftree}\end{minipage}%
\begin{minipage}{0.4\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(一阶同构引入)}
    \UnaryInfC{$\Gamma \vdash p \proctr{i}{} e$}
\end{prooftree}\end{minipage}%
\begin{minipage}{0.3\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma \vdash p \proctr{i}{} e$}
    \RightLabel{(一阶同构削除)}
    \UnaryInfC{$\Gamma \vdash p \widesim{i} e$}
\end{prooftree}\end{minipage}%}

\vspace{3mm}

\begin{minipage}{0.45\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma_1 \vdash p \widesim{i} e$}
    \AxiomC{$\Gamma_2 \vdash f \proctr{i|j|\cdots|k}{} \phi$}
    \RightLabel{(应用)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash
    f\ p \proctr{j|\cdots|k}{} \phi\ e$}
\end{prooftree}\end{minipage}
\begin{minipage}{0.5\linewidth} \begin{prooftree}
    \AxiomC{$\Gamma,\ p \widesim{i} e \vdash 
    f \proctr{j|\cdots|k}{} \phi$}
    \RightLabel{(抽象)}
    \UnaryInfC{$\Gamma \vdash \lambda p.\ f \proctr{i|j|\cdots|k}{}
    \lambda e.\ \phi$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(对应记号 $x$)}
  \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
  x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \widesim{i}  x_\mathrm{e}$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth} \begin{prooftree}
  \AxiomC{$\Gamma \vdash p \proctr{i|\cdots|k}{cond} e$}
    \RightLabel{(同构记号 $x$)}
  \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
  x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \proctr{i|\cdots|k}{cond}  x_\mathrm{e}$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
    \AxiomC{$\Gamma,\ x_\mathrm{p} = p,\ x_\mathrm{e} = e \vdash
     p' \widesim{i}  e'$}
    \RightLabel{(对应记号 $x$ 削除)}
    \UnaryInfC{$\Gamma \vdash \mathrm{Let}\ x_\mathrm{p}\ p\ p'
    \widesim{i} \mathrm{Let}\ x_\mathrm{e}\ e\ e'$}
\end{prooftree}\end{minipage}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
  \AxiomC{$\Gamma,\ x_\mathrm{p} = p,\ x_\mathrm{e} = e \vdash
   p' \proctr{i|\cdots|k}{cond}  e'$}
  \RightLabel{(同构记号 $x$ 削除)}
  \UnaryInfC{$\Gamma \vdash \mathrm{Let}\ x_\mathrm{p}\ p\ p'
  \proctr{i|\cdots|k}{cond} \mathrm{Let}\ x_\mathrm{e}\ e\ e'$}
\end{prooftree}\end{minipage}

\vspace{6mm}

\noindent 
形式系统朴素 Noesis 就是形式语言 $L_\mathrm{N}$ 和规则 $\vdash$ 
构成的形式系统。
\end{defin}

\section{HOL 逻辑上的 Noesis 系统 \noesishol}

形式系统 \noesishol 构建在 HOL 逻辑的基础上，使用 HOL 形式语言作为
\noesishol 的形式语言，而构建兼容 HOL 逻辑的 Noesis 形式系统的规则。
或者说，形式系统 \noesishol 是朴素 Noesis 形式系统在 HOL 逻辑上的实现
与适当扩广。这种实现通过在 HOL 逻辑上定义表示理解的类型与表示 Noesis
对应及 Noesis 同构的谓词完成。于是可以允许理解的运算，作为对朴素
Noesis 系统的主要扩广，例如那些产生理解的 HOL 函数，
诸如理解的并、序列的理解等。

接下来将逐步在 HOL 逻辑上定义现象与理解，而本体是
任意 HOL 逻辑上的数学对象，甚至包括定义在 HOL 逻辑上的现象与理解本身。

\begin{defin}[现象类型] \label{Def.phenomenon}
HOL 逻辑上的类型 phenomenon 表示 \noesishol 的现象，
根据不同的具体实现可以不同方式具体定义，不同的具体定义不影响本章理论。

唯独特别的，phenomenon 类型中需要包含一个零元素$\mathrm{p}_0$，
表示计算客体中不需要被任何实在的现象表示而自然地于背景中存在，
例如0个二进制位或者C语言的void类型。
\end{defin}

\begin{defin}[到$\alpha$的理解] \label{Def.itp} 
类型 $\itp{\alpha}$ 是现象到类型为 $\alpha$ 的本体的理解，
包含可以构建现象与本体间联系的映射。
    \[ \begin{split}
        \itp{\alpha} \Coloneqq \mathbf{Noesis}\ &(\alpha \rightarrow \phenomenon)
        \ (\phenomenon \rightarrow \alpha)\\
        &(\alpha\ \mathrm{set})\ (\phenomenon\ \mathrm{set})
    \end{split} \]
    \begin{align*}
        \mathbf{NOE\_LIGHT}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = l&
        \mathbf{NOE\_TRANSCEND}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = tr&\\
        \mathbf{NOE\_SET}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = s&
        \mathbf{NOE\_PSET}\ (\mathbf{Noesis}\ l\ tr\ s\ s_p) & = s_p&
    \end{align*}
\end{defin}

$\itp{\alpha}$ 表示一个将现象对应为某种 $\alpha$ 类型的本体的理解。
例如现象到布尔值间的 Noesis 对应就要届由到 bool 类型的理解来完成。
$\mathbf{Noesis}\ l\ tr\ s\ s_p$ 构建了这样一个理解，$l$是投影函数，确定本体到
现象的映射；$tr$ 是超越函数，确定现象到本体的映射；$s$ 是本体集合，
有 $s \subseteq \mathrm{dom}\ l \land s \subseteq \mathrm{rng}\ tr$；
$s_p$ 是现象集合，有 $s_p \subseteq \mathrm{dom}\ tr \land s_p \subseteq \mathrm{rng}\ l$
，一个理解即是上述的四元组。


\begin{notation}[理解的相关属性的简写记号]
\begin{align*}
    \mathbf{Li}_i\ & \coloneqq \mathbf{NOE\_LIGHT}\ i
    & \mathbf{Tr}_i\ & \coloneqq \mathbf{NOE\_TRANSCEND}\ i \\
    \mathbf{Se}_i\ & \coloneqq \mathbf{NOE\_SET}\ i
    & \mathbf{Sp}_i\ & \coloneqq \mathbf{NOE\_PSET}\ i
\end{align*}
\end{notation}

\begin{defin}[到$\alpha$的有效理解] \label{Def.Vi}
\[ \begin{split}
    \mathbf{VALID\_NOE}\ i \coloneqq\ &
    (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e)) \\
    & \land\ (\forall p.\ p \in \mathbf{Sp}_i \Rightarrow \mathbf{Tr}_i\ p \in 
    \mathbf{Se}_i)
\end{split} \]
\end{defin}

\begin{notation}[有效理解的简写]
    \[ \mathbf{V}_i \coloneqq \mathbf{VALID\_NOE}\ i \]
\end{notation}

即 $\mathbf{V}_i$ 意味着 $\mathbf{Li}_i$ 是 $\mathbf{Se}_i$ 到 $\mathbf{Sp}_i$ 的单射，
$\mathbf{Tr}_i$ 是 $\mathbf{Sp}_i$ 到 $\mathbf{Se}_i$ 的满射，
$\mathbf{Tr}_i$ 是 $\mathbf{Li}_i$ 的逆函数。

\begin{example}[到bool的有效理解的样例]
\[ \begin{split}
    \mathbb{B}_\mathrm{I} \coloneqq\ & \mathbf{Noesis}\ (\lambda e.\ \mathbf{if}\ e\ 
    \mathbf{then}\ 1\ \mathbf{else}\ 0) \\
& (\lambda p.\ \mathbf{if}\ p=0\ \mathbf{then}\ \mathrm{F}\ \mathbf{else}\ \mathrm{T})\quad
   \{\mathrm{T},\ \mathrm{F}\}\quad \mathbb{N}
\end{split} \]
\end{example}

\begin{defin}[ Noesis 对应关系] \label{Def.TR}
定义三元关系 $ p \widesim{i} e$ 表示现象与本体在某种理解下的的对应关系。
\[ p \widesim{i} e \coloneqq \mathbf{V}_i \land p \in \mathbf{Sp}_i \land
    (\mathbf{Tr}_i\ p = e)\]
\end{defin}

某个成立的 Noesis 对应关系可以用 HOL 逻辑证明，或者以形式系统的角度去说，
可以用HOL逻辑的一系列规则得到某个成立的Noesis 对应。

\begin{prooftree}
    \AxiomC{$\cdots$} 
    \RightLabel{对于某个成立的 $p \widesim{i} e$\quad\quad( Noesis 对应的证明律)} \doubleLine
    \UnaryInfC{$\vdash p \widesim{i} e$}
\end{prooftree}

由此构建了程序的语义感知（Semantic Reasoning）的基础，即在理解方式$i$下可以将
计算客体$p$解释成$e$，而$e$即$p$在理解方式$i$下的语义。

一个现象对于一个理解只有确定的一个本体，但一个现象可以同时具有多种理解，
而现象上的一次计算可以同时带有多个含义。例如现象1可以在布尔理解下对应真，
也可以在自然数理解下对应自然数1，也可以是某种有序集的理解下的第一个元素。

%\begin{theo}[Noesis 对应的一些性质]
%\begin{align*}
%  \forall p\ i\ e.\ p \widesim{i} e \Rightarrow
%    e \in \mathbf{Se}_i
%\end{align*}
%\end{theo}
%\begin{proof} 由定义 \ref{Def.Vi} 直接得到。
%\end{proof}

\begin{defin}[理解的合并] \label{Def.I*}
一个到 $\alpha$ 的理解$i_a$与到 $\beta$ 的理解$i_b$可以合并成
    到二元组$(\alpha,\beta)$的理解 $i_a \cdot i_b$
\[
    \forall l_a\ l_b\ a\ b.\ (l_a\ a = l_b\ b) \Rightarrow
    (\dot{\mathbf{l}}\ l_a\ l_b\ a\ b = l_a\ a )
\]
\begin{equation} \begin{split}
    (\mathbf{Noesis}\ & l_a\ tr_a\ s_a\ sp_a)\ \cdot\ 
    (\mathbf{Noesis}\ l_b\ tr_b\ s_b\ sp_b) \coloneqq \\
    & \mathbf{Noesis}\ (\dot{\mathbf{l}}\ l_a\ l_b)\ 
        (\lambda p.\ (tr_a\ p,\ tr_b\ p))\ \\
    & \quad\quad\quad (s_a \times s_b \cap (\lambda (a,\ b).\ l_a\ a = l_b\ b))\ 
    (sp_a \cap sp_b)
\end{split} \end{equation}
\end{defin}

这样合并的意义在于，多个基于不同理解的Noesis 对应，可以将这些不同的理解合并而表示为一个Noesis 对应。

\begin{theo}[理解合并的有效性] \label{T.V.IMerge}
\begin{equation}
    \mathbf{V}_a \land \mathbf{V}_b \Rightarrow \mathbf{V}_{a\cdot b}
\end{equation}
\end{theo}
\begin{proof}
\begin{align*}
    \mathbf{V}_{a\cdot b} =\ & (\forall e_a\ e_b.\ e_a \in \mathbf{Se}_a \ \ \land \ \ 
    e_b \in \mathbf{Se}_b \ \ \land \ \ 
    (\mathbf{Li}_a\ e_a = \mathbf{Li}_b\ e_b) \ \ \Rightarrow \\
    & \quad\quad\quad \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \cap \mathbf{Sp}_b \ \ \land
    \ \ (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a) \ \ \land \ \ 
    (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_a \ \ \land \ \ p \in \mathbf{Sp}_b
    \Rightarrow \mathbf{Tr}_a\ p \in \mathbf{Se}_a \ \ \land \ \ \mathbf{Tr}_b\ p \in 
      \mathbf{Se}_b ) \\
    \mathbf{V}_a =\ & (\forall e_a.\ e_a \in \mathbf{Se}_a \Rightarrow
      \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \ \ \land \ \ 
      (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_a \Rightarrow \mathbf{Tr}_a\ p \in 
      \mathbf{Se}_a) \\
\mathbf{V}_b =\ & (\forall e_b.\ e_b \in \mathbf{Se}_b \Rightarrow
      \mathbf{Li}_b\ e_b \in \mathbf{Sp}_b \ \ \land \ \ 
      (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b)) \\
    & \land\ \ (\forall p.\ p \in \mathbf{Sp}_b \Rightarrow \mathbf{Tr}_b\ p \in
      \mathbf{Se}_b) \\
\mathbf{V}_a,\ & \mathbf{V}_b,\ e_a \in \mathbf{Se}_a,\ e_b \in \mathbf{Se}_b,\ 
    \mathbf{Li}_a\ e_a = \mathbf{Li}_b\ e_b \ \vdash \ 
    \mathbf{Li}_a\ e_a \in \mathbf{Sp}_a \cap \mathbf{Sp}_b \\
    & \quad\quad\quad\quad \land (\mathbf{Tr}_a(\mathbf{Li}_a\ e_a) = e_a) \land
    (\mathbf{Tr}_b(\mathbf{Li}_b\ e_b) = e_b) \\
\mathbf{V}_a,\ & \mathbf{V}_b,\ p \in \mathbf{Sp}_a,\ p \in \mathbf{Sp}_b\ \vdash\ 
    \mathbf{Tr}_a\ p \in \mathbf{Se}_a\ \ \land \ \ \mathbf{Tr}_b\ p \in \mathbf{Se}_b \\
\mathbf{V}_a,\ &\mathbf{V}_b \vdash \mathbf{V}_{a \cdot b}
\end{align*}
\end{proof}

\begin{theo}[理解合并对于 Noesis 对应的同构]
\begin{equation}
    \forall i_a\ i_b\ p\ e_a\ e_b.\ p \widesim{i_a} e_a \land p \widesim{i_b} e_b = 
    p \widesim[2]{i_a \cdot i_b} (e_a,\ e_b) 
\end{equation}
\end{theo}

\begin{proof}
\[ p \widesim[2]{ia \cdot ib} (e_a,\ e_b) =\ \mathbf{V}_{ia\cdot ib} \land p \in 
    (\mathbf{Sp}_{ia} \cap \mathbf{Sp}_{ib}) \land 
    (\mathbf{Tr}_{ia}\ p = e_a) \land (\mathbf{Tr}_{ib}\ p = e_b) \]
结合定义\ref{Def.TR}以及理解合并的有效性定理\ref{T.V.IMerge}
\[p \widesim[2]{ia \cdot ib} (e_a,\ e_b) = p \widesim{i_a} e_a \land p \widesim{i_b} e_b \]
\end{proof}

由合并的理解的 Noesis 对应就可以提取出其中各个理解的 Noesis 对应。

\begin{gather*}
    p \widesim{i_1 \cdot i_2} (e_1,\ e_2) \Rightarrow p \widesim{i_1} e_1 \\
    p \widesim{i_1 \cdot i_2} (e_1,\ e_2) \Rightarrow p \widesim{i_2} e_2
\end{gather*}

\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
    \RightLabel{(合并分解律1)}
\UnaryInfC{$\Gamma \vdash p \widesim{i_1} e_1$}
\end{prooftree}
\end{minipage}%
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
    \RightLabel{(合并分解律2)}
\UnaryInfC{$\Gamma \vdash p \widesim{i_2} e_2$}
\end{prooftree}
\end{minipage}

\begin{prooftree}
\AxiomC{$\Gamma_1 \vdash p \widesim{i_1} e_1$}
\AxiomC{$\Gamma_2 \vdash p \widesim{i_2} e_2$}
    \RightLabel{(合并律)}
\BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash p \widesim{i_1 \cdot i_2} (e_1,\ e_2)$}
\end{prooftree}

\begin{theo}[理解合并在 Noesis 对应上的交换律同构与结合律同构]
\begin{gather*}
    \forall e_a\ e_b\ i_a\ i_b\ p.\ p \widesim[2]{i_a \cdot i_b} (e_a,\ e_b) =
        p \widesim[2]{i_b \cdot i_a} (e_b,\ e_a) \\
    \forall e_a\ e_b\ e_c\ i_a\ i_b\ i_c\ p.\ p \widesim[4]{(i_a \cdot i_b) \cdot i_c}
    ((e_a,\ e_b),\ e_c) = p \widesim[4]{i_a \cdot (i_b \cdot i_c)} (e_a,(e_b,\ e_c))
\end{gather*}
\end{theo}

\begin{proof} 显然，略
\end{proof}

接下来论述 Noesis 同构，Noesis 同构描述函数映射的原像与像具有某种可能不同的 Noesis 对应
或与 Noesis 对应相关的性质。注意 Noesis 同构是一个宽泛的概念。对于
\[ \forall p\ e.\ p \widesim{i} e \Rightarrow f_p\ p \widesim{j} f_e\ e \]
$f_p$ 是 Noesis 同构于 $f_e$，
\[ \forall p\ e.\ p \widesim{i} e \Rightarrow f_p\ p \Rightarrow cond\ e
\widesim{j} f_e\ e \]
还可以具有条件 $cond$，也是 Noesis 同构，
\[ \forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow \forall y_p\ y_e.\ 
y_p \widesim{i} y_e \Rightarrow cond\ x_e\ y_e \Rightarrow f_p\ x_p\ y_p \widesim{j} 
f_e\ x_e\ y_e \]
高阶函数也可以有 Noesis 同构。而更宽泛地
\[ \forall g_p\ g_e.\ (\forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow 
g_p\ x_p \widesim{j} g_e\ x_e) \Rightarrow cond\ g_e \Rightarrow
f_p\ g_p \widesim{k} f_e\ g_e \]
$f_p,f_e$ 间也具有 Noesis 同构。

\begin{defin}[Noesis 同构] 这里给出 Noesis 同构的严谨定义。
  $f_p$ 是现象的函数或者是现象的函数的函数以及各种高阶函数的函数，即
  $f_p$ 可以具有类型 $\mathrm{phenomenon} \rightarrow \mathrm{\phenomenon}$
  或 $\mathrm{phenomenon} \rightarrow \mathrm{phenomenon} \rightarrow \mathrm{phenomenon}$
  或 $(\mathrm{phenomenon} \rightarrow \mathrm{phenomenon})
\rightarrow \mathrm{phenomenon}$ 等等。当 $f_p$ 与本体 $f_e$ 间的二元关系 $H$
具有如下形式，则是一种 $f_p,f_e$ 间的 Noesis 同构。
  \[ \forall p\ e.\ p\ R\ e \Rightarrow f_p\ p\ H'\ f_e\ e\]
其中 $p$ 是现象或者现象的各种高阶函数，$e$ 是作为本体的任意对象，$R$ 是任意某种二元关系，
多数情况下是某种理解 $i$ 的 Noesis 对应 $\widesim{i}$，$H'$ 是某种理解 $l$ 的 Noesis
对应 $\widesim{i}$ 或者另一个不等于 $H$ 的 Noesis 同构。
$f_p,f_e$ 间的所有的 Noesis 同构均是具有上述形式满足上述要求的二元关系。
Noesis 同构即被递归定义完成。
\end{defin}

\begin{notation}[过程的 Noesis 同构记号] \label{def.proctr}
记号 $f_p \proctr{i}{cond} f_e$ 表示有条件的 Noesis 对应。
记号 $f_p \proctr{a_e \sim i|j}{cond} f_e$ 表示一种只有1个参数的且以
$cond$为条件的过程的 Noesis 同构，记号
$f_p \proctr{e_1 \sim i_1 | \cdots | e_n \sim i_n|j}{cond} f_e$ 表示一种有 $n$ 个参数的
过程的且条件为 $cond$的 Noesis 同构。
\begin{gather*}
    p \proctr{i}{cond} e \coloneqq \ (cond \Rightarrow p \widesim{i} e) \\
    \begin{array}{lcrll}
      f_p\ &\proctr{a_e \sim i|j}{cond}&
      (f_e:\alpha \rightarrow \beta) &\coloneqq&
    (\forall a_p\ a_e.\quad  a_p \widesim{i} a_e \Rightarrow cond\ a_e \Rightarrow
    f_p\ a_p \widesim{j} f_e\ a_e) \\
      f_p\ &\proctr{a_e|j}{cond}&
      (f_e:\alpha \rightarrow \beta) &\coloneqq&
    (\forall a_p\ a_e.\quad  a_p \widesim{i} a_e \Rightarrow cond\ a_e \Rightarrow
    f_p\ a_p \widesim{j} f_e\ a_e)
    \end{array}  \\ \begin{split}
    f_p\  \proctr{a_e \sim i | \cdots | c_e \sim k | l}{cond} &
    (f_e:\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow \delta) \coloneqq \\
    (\forall a_p\ a_e.\ a_p \widesim{i} a_e \Rightarrow\ &\forall b_p\ c_p.
    \ b_p \widesim{j} b_e \Rightarrow \cdots \Rightarrow cond\ a_e\ \cdots\ c_e 
    \Rightarrow  \\
    & f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e)
    \end{split} \\ \begin{split}
    f_p\  \proctr{i | \cdots | k | l}{cond} &
    (f_e:\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow \delta) \coloneqq \\
    (\forall a_p\ a_e.\ a_p \widesim{i} a_e \Rightarrow\ &\forall b_p\ c_p.
    \ b_p \widesim{j} b_e \Rightarrow \cdots \Rightarrow cond\ a_e\ \cdots\ c_e 
    \Rightarrow  \\
    & f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e)
    \end{split}
\end{gather*} 
    $cond$ 表示过程正确执行的条件。
    对于$\proctr{a \sim i | \cdots | c \sim k | l}{cond}$ 若理解
    $i, \cdots, k$ 的类型分别为 \[\itp{\alpha},\ \cdots,\ \itp{\gamma}\]
    那么 $cond$ 的类型为 $\alpha \rightarrow \cdots \rightarrow \gamma \rightarrow 
    \mathrm{bool}$，即 $cond$ 是在本体层面上描述执行条件。

    此处的记号仅是 Noesis 同构的一种表达记号，仅用于易于理解与增加可读性，
    只能表达一部分 Noesis 同构，一些复杂的 Noesis 同构例如
\[ \forall g_p\ g_e.\ (\forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow 
g_p\ x_p \widesim{j} g_e\ x_e) \Rightarrow cond\ g_e \Rightarrow
f_p\ g_p \widesim{k} f_e\ g_e \]
无法用这种记号表达。
\end{notation}

    过程的 Noesis 对应同构构成了一种契约，
    当输入参数可以被约定的理解$i,\cdots,k$解释，
    且解释后的意义也即本体$a_e,\cdots,c_e$满足给定的条件时，
那么此过程可以正确执行，并返回以约定的理解$l$的解释下对应本体$f\ a_e\ \cdots\ c_e$ 的现象。


上述记号具有如下的递归形式。
\begin{equation} \label{f.proctr_rec} \begin{split}
    f_p \proctr{a_e \sim i|b_e \sim j|\cdots|l}{cond} f_e = 
    (\forall a_p\ a_e.\quad a_p \widesim{i} a_e \Rightarrow f_p\ a_p 
    \proctr{b_e \sim j|\cdots|l}{cond\ a_e} f_e\ a_e)
\end{split} \end{equation}

Noesis 同构中的理解 $i \cdots k$ 与本体 $a \cdots c$ 可以相互依赖。
首先本体可以依赖于本体，这是显然的。
其次理解可以依赖于理解，可以由一个理解计算得出。序列的增加是一个例子
\[ \mathbf{Append} \proctr{x \sim i | l \sim \ListI\ i | 
\ListI i}{\lambda x\ l.\ \T} (::) \]
将 Noesis 同构记号展开后
\[ \forall i\ x_p\ x.\ x_p \widesim{i} x \Rightarrow \forall l_p\ l.\ 
  l_p \widesim[2]{\ListI\ i} l \Rightarrow \mathbf{Append}\ x_p\ l_p
  \widesim[2]{\ListI\ i} x::l \]
是合理合法的 HOL 逻辑表达式。
第三，理解可以依赖于本体，若 $\mathcal{N}^{\leq}_n$ 表示所有不超过 $n$ 的自然
数的本体集的理解，自然数减法 $\mathbf{NSub}$ 的 Noesis 同构可以表达为
\[ \mathbf{NSub} \proctr{a \sim \mathcal{N}^{\leq}_n|b \sim
\mathcal{N}^{\leq}_a|\mathcal{N}^{\leq}_a}{\lambda a\ b.\ \T} (-) \]
记号展开后是
\[ \forall n\ a_p\ a.\ a_p \widesim[2]{\mathcal{N}^\leq_n} a
\Rightarrow \forall b_p\ b.\ b_p \widesim[2]{\mathcal{N}^\leq_a} b \Rightarrow
\mathbf{NSub}\ a_p\ b_p \widesim[2]{\mathcal{N}^\leq_a} a - b \]
也是合法的。最后本体可以依赖于理解，
\[ f_p \proctr{a\sim \mathcal{N}^\leq_n|\mathcal{N}^\leq_n}
{\K \T} (\lambda a.\ n - a) f_e \]
展开后是
\[ \forall n\ a_p\ a.\ a_p \widesim[2]{\mathcal{N}^\leq_n} a
\Rightarrow f_p\ a_p \widesim[2]{\mathcal{N}^\leq_n} (\lambda a.\ 
n - a) \]

因为理解与本体以及现象均是 HOL 逻辑上普通的数理对象，所以自然可以
相互依赖。这一点揭示出类似依赖类型（Dependent Type）的性质，但一切都
更加自然与理所应当。而在实际使用中，一般很少会本体依赖理解或理解依赖本体
，一般都只是理解依赖理解。在最后一章的结论中会指出，理解承载现象的
共性，而本体承载现象的共性在内的全部特性，所以理解是不需要非常精细的，
并不像依赖类型系统的语言使用类型描述值的性质，Noesis 系统中是现象由理解
对应到本体而本体体现现象的性质，所以 Noesis 系统中并不特别需要理解与
本体互相依赖，尽管这是可以做到的。于是一般在 Noesis 同构的记号中省略
本体的部分，一般将 $\proctr{a \sim i|b \sim j|\cdots|k}{cond}$
简写为 $\proctr{i|j|k}{cond}$。而将一些必要的本体限制放在 $cond$ 中，
上述的 $\mathbf{NSub}$ 更常用的 Noesis 同构是
\[ \mathbf{NSub} \proctr{\mathcal{N}^\leq_n|\mathcal{N}^\leq_n|
\mathcal{N}^\leq_n}{\lambda a\ b.\ a \geq b} (-) \]
展开后的表达是
\[ \forall n\ a_p\ a_e.\ a_p \widesim[2]{\mathcal{N}^\leq_n}
 a_e \Rightarrow \forall b_p\ b_e.\ b_p \widesim[2]{\mathcal{N}^\leq_n} b_e \Rightarrow
 a_e \geq b_e \Rightarrow
 \mathbf{NSub}\ a_p\ b_p \widesim[2]{\mathcal{N}^\leq_n} a_e - b_e\]
充分利用调用条件 $cond$ 就不怎么需要本体与理解互相依赖。

接下来论述 \noesishol 上的调用律、抽象律、一阶同构引入律、一阶同构削除律、
记号律、记号削除律。这些演绎律可以易于理解地写成下面的形式，尽管这些形式并不完整。
\footnotetext[1]{准确地说 \noesishol 上的调用律就是 HOL 逻辑的 MATCH\_MP
    律，此处的形式是 MATCH\_MP 的应用，更具有可读性，但并非所有的调用律的应用都具有
    这种形式。MATCH\_MP 律才是完整的 \noesishol 上的调用律。}
\footnotetext[2]{同样 \noesishol 上的抽象律是 HOL 逻辑的 DISCH 律，此处的形式也是为了
可读性。}

\begin{center}
    \AxiomC{$\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e$}
    \AxiomC{$\Gamma_2 \vdash a_p \widesim{i} a_e$}
    \RightLabel{(调用\footnotemark[1])}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash f_p\ a_p \proctr{j|\cdots|l}{cond\ a_e}
      f_e\ a_e$}
\DisplayProof

  \vspace{\baselineskip}
    \AxiomC{$\Gamma_1,\ a_p \widesim{i} a_e \vdash b_p \proctr{j|\cdots|l}{cond} b_e$}
    \RightLabel{(抽象\footnotemark[2])}
    \UnaryInfC{$\Gamma_1 \vdash (\lambda a_p.\ b_p)
      \proctr{i|j|\cdots|l}{\lambda a_e.\ cond\ a_e} (\lambda a_e.\ b_e)$}
\DisplayProof

\vspace{\baselineskip}
\begin{tabular}{c c}
    \AxiomC{$\Gamma, cond \vdash p \widesim{i} e$}
    \RightLabel{(一阶同构引入)}
    \UnaryInfC{$\Gamma \vdash p \proctr{i}{cond} e$} \DisplayProof &
    \AxiomC{$\Gamma_1 \vdash p \proctr{i}{cond} e$}
    \AxiomC{$\Gamma_2 \vdash cond$}
    \RightLabel{(一阶同构削除)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash p \widesim{i} e$} \DisplayProof
\end{tabular}

\vspace{\baselineskip}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(对应记号 $x$)}
    \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
    x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \widesim{i}  x_\mathrm{e}$} \DisplayProof

\vspace{\baselineskip}
  \AxiomC{$\Gamma \vdash p \proctr{i|\cdots|k}{cond} e$}
    \RightLabel{(同构记号 $x$)}
    \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
    x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \proctr{i|\cdots|k}{cond}  x_\mathrm{e}$} \DisplayProof

\vspace{\baselineskip}
  \AxiomC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (x_\mathrm{e} = e 
  ))\vdash p' \widesim{i}  e'$}
    \RightLabel{(对应记号 $x$ 削除)}
  \UnaryInfC{$\Gamma \vdash \mathrm{Let}\ p\ (\lambda x_\mathrm{p}.\ p')
    \widesim{i} \mathrm{Let}\ e\ (\lambda x_\mathrm{e}.\ e')$}\DisplayProof
\end{center}

\vspace{3mm}

\begin{minipage}{\linewidth}\begin{prooftree}
  \AxiomC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (x_\mathrm{e} = e))
  \vdash p' \proctr{i|\cdots|k}{cond}  e'$}
  \RightLabel{(同构记号 $x$ 削除)}
\UnaryInfC{$\Gamma \vdash \mathrm{Let}\ p\ (\lambda x_\mathrm{p}.\ p')
\proctr{i|\cdots|k}{cond} \mathrm{Let}\ e\ (\lambda x_\mathrm{e}.\ e')$}
\end{prooftree}\end{minipage}

\vspace{6mm}

\noindent 其中 Let 就是 HOL 上定义的 Let。

这些演绎律全部是 HOL 逻辑中已有演绎律的复合，\noesishol 本身不引入
新的演绎律，所以 \noesishol 作为一个形式系统其实是 HOL 逻辑的一种应用。
接下来将论述如何由已有的 HOL 逻辑的演绎律复合出上述 \noesishol 的规则。

\noesishol 调用律就是 HOL 逻辑中的 MATCH\_MP 律，MATCH\_MP 的意味是自动匹配全称量化
的肯定前件（Modus Ponens with quantification matching）。
将 \[\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e \]
的同构记号展开，注意 $a_p',b_p'$ 上的撇号与接下来的 $a_p,b_p$ 区分
\[\begin{split} \Gamma_1 \vdash \forall a_p'\ a_e'.\ a_p' \widesim{i} a_e' &\Rightarrow
    \forall b_p\ b_e.\ b_p \widesim{j} b_e \Rightarrow
    \cdots \Rightarrow\\ &cond\ a_e'\ b_e\ \cdots \Rightarrow f_p\ a_p'\ b_p\ \cdots
\widesim{l} f_e\ a_e'\ b_e\ \cdots \end{split}\]
对 $\Gamma_2 \vdash a_p \widesim{i} a_e$ 进行 MATCH\_MP 律得到
\[\begin{split} \Gamma_1 \cup \Gamma_2 \vdash \forall b_p\ &b_e.\ b_p \widesim{j} 
  b_e \Rightarrow
    \cdots \Rightarrow\\ &cond\ a_e\ b_e\ \cdots \Rightarrow f_p\ a_p\ b_p\ \cdots
\widesim{l} f_e\ a_e\ b_e\ \cdots \end{split}\]
就是同构记号下的
\[\Gamma_1 \cup \Gamma_2 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e \]
MATCH\_MP 是 \noesishol 上的调用律，却并不局限于这种形式，
\begin{sprooftree}
    \AxiomC{$\Gamma_1 \vdash f_p \proctr{i|j|\cdots|l}{cond} f_e$}
    \AxiomC{$\Gamma_2 \vdash a_p \widesim{i} a_e$}
    \RightLabel{MATCH\_MP}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash f_p\ a_p \proctr{j|\cdots|l}{cond\ a_e}
      f_e\ a_e$}
\end{sprooftree}
对于更复杂的 Noesis 同构，例如
\[ \forall g_p\ g_e.\ (\forall x_p\ x_e.\ x_p \widesim{i} x_e \Rightarrow 
cong_g\ x_e \Rightarrow
g_p\ x_p \widesim{j} g_e\ x_e) \Rightarrow cond\ g_e \Rightarrow
f_p\ g_p \widesim{k} f_e\ g_e \]
由 MATCH\_MP 律实现的 \noesishol 的调用律以 $g_p' \proctr{i|j}{cond_g} g_e'$ 作为参数
调用可以得到
\[ f_p\ g_p \proctr{k}{cond_g\ g_e} f_e\ g_e \]
非常有趣。如果非要用某个记号表达的话，$f_p,f_e$ 间的同构也许适合表达为
\[ f_p \proctr{\proctr{i|j}{cond_g}|k}{cond} f_e \]

\noesishol 上的抽象律就是 HOL 逻辑的 DISCH 律
\begin{sprooftree}
    \AxiomC{$\Gamma,\ a_p \widesim{i} a_e \vdash b_p \proctr{j|\cdots|k}{cond} b_e$}
    \RightLabel{DISCH\ $a_p \widesim{i} a_e$}
\UnaryInfC{$\Gamma \vdash a_p \widesim{i} a_e \Rightarrow b_p \proctr{j|\cdots|k}{cond} 
  b_e$}
  \RightLabel{即是}
    \UnaryInfC{$\Gamma \vdash \lambda a_p.\ b_p \proctr{i|j|\cdots|k}{\lambda a_e.\ cond} 
    \lambda a_e.\ b_e$}
\end{sprooftree}

最后一阶同构引入律也是 DISCH 律，一阶同构削除律是 MATCH\_MP 律。

记号律
\begin{sprooftree}
    \AxiomC{$\Gamma \vdash p \widesim{i} e$}
    \RightLabel{(对应记号 $x$)}
    \UnaryInfC{$\Gamma,\ ((x_\mathrm{p} = p)\ \land\ (
    x_\mathrm{e} = e)) \vdash
     x_\mathrm{p} \widesim{i}  x_\mathrm{e}$}
\end{sprooftree}
是由 ASSUME 律得到
\[ (x_p = p)\ \land\ (x_e = e)\vdash (x_p = p)\ \land\ (x_e = e) \]
再 CONJUNCT1 律与 CONJUNCT2 律分别得到
\begin{align*}
  (x_p = p)\ \land\ (x_e = e)&\vdash x_p = p&
  (x_p = p)\ \land\ (x_e = e)&\vdash x_e = e&
\end{align*}
而后依次 EQ\_MP 律即是。

记号削除律简单地就是
\[\begin{split}
  \mathrm{MATCH\_MP}\ (\ \vdash &(\forall p\ p'\ e\ e'\ R.\ ((p = p')\ \land\ 
  (e = e')) \Rightarrow p\ R\ e) \\&\Rightarrow
(\mathrm{let}\ p = p';\ e = e'\ \mathrm{in}\ p\ R\ e)) \end{split} \]

%又也许理解可以尝试地作为这样一种类型，但问题在于，任何一个现象都可以被应用于大量的理解
%——只要现象在理解的现象集内就行，若尝试将理解作为类型，就意味着每一个现象都可以属于大量的类型，
%这显然是荒谬的。

%本文对所有将 Noesis 对应描述成某种类型系统的尝试都失败了。根本在于，类型是一种对值的分类，
%以良好地提取维护值的部分性质；
%但本文的思路， Noesis 对应根本不尝试对值分类，而是尝试显示地确定理解方式而找到值对应的以某种
%数理对象表示的意义，进而提取出值在该理解下的全部性质。
%这与与指称语义（Denotational semantics）非常相似。

%指称语义尝试建立起程序与数学函数的对应关系，跟 Noesis 对应非常相似。
%但$\amlh$的优势在于程序的抽象，基于$\lamst$使得程序本身亦是抽象的结构。
%这导致一些重要的区别，指称语义在递归定义的函数与数据结构上遇到的困难带领指称语义
%走向了域理论，而对于$\amlh$，不使用域理论而
%是在？？？节将看到递归与归纳（Induction）间的内在联系。
%指称语义与 Noesis 对应尝试实现类似的目标，但解决思路与方式完全不同。

\input{./chapters/noesis/machine.tex}
