\section{类型系统的再思考}

长久以来类型系统仅被用作一种辅助程序开发的形式化工具，
一种 Model checker，能有效地检查某种形式的错误，并为程序开发提供
一定的辅助，特别是在语义层面上。
作为一种工具，类型系统的重心集中在类型推导与类型检查上，前者意味着
性质的自动推导而后者是性质的证明。
一个类型关系（Typing）是类型系统作为一个形式系统上的定理，类型推导
是对此定理的自动推理（inference）而类型检查则是对此定理的证明。
这个定理包含了两部分，一般写作 $x : \tau$ 即值 $x$ 具有类型 $\tau$，
而类型系统定义了一系列定理的推导规则，例如：

\begin{prooftree}
\AxiomC{$M : \sigma \rightarrow \tau$}
\AxiomC{$N : \sigma$}
\BinaryInfC{$M N : \tau$}
\end{prooftree}

即如果有定理 $f : \sigma \rightarrow \tau$ 且有定理 $a : \sigma$ 那么
可以演绎出定理 $f\ x : \tau$。

一直以来，类型系统与编程语言始终聚焦在，给出了一种计算，或者说一段源代码
，即类型关系的左边 $x$ 这一部分，这一部分可能包含一定的类型标注，
而类型系统推导或者验证类型关系的右边部分 $\tau$。包括各种编程语言如
C/C++、Jave、Ruby，以及那些 Curry-Howard 同构下用于形式化证明的系统如
Coq、Agda、Idris，都是着重于计算，由程序到类型关系。只不过编程语言
注重于程序本身，类型系统是辅助程序开发；而Coq 系的证明系统注重于
类型关系在 Curry-Howard 同构下对应的被形式验证的定理，而计算是以
得到这些定理的证明过程。

既然一个类型关系 $x : \tau$ 已经包含了程序部分 $x$，而类型关系是一个
定理，那能否着重于类型关系作为一个定理本身，推导作为定理的类型关系而
进行程序开发。即原本编写一段以 $a$ 对 $f$ 调用的程序是写下作为源程序
的文本 $f(x)$，但现在能否是从定理 $f : \sigma \rightarrow \tau$ 和
定理 $a : \sigma$ 中演绎出定理 $f\ x : \tau$，而$:$左边的 $f\ x$ 
就是得到的程序。

\begin{center} 演绎定理以构建程序。\end{center}

这一思路下，作为定理的类型关系成为构造的对象，而此定理已经不需要具有
$x : \tau$ 的形式只要包含程序 $x$，且有对程序 $x$ 的任意性质
的描述。在本文，融汇了指称语义（Denotation Semantic）理论后，这一
定理具有形式 $x \widesim{i} \epsilon$，$\sim$ 是一个三元关系，$x$
表示程序，$i$ 表示理解方式，$\epsilon$ 表示程序 $x$ 在理解方式 $i$
下的指称，即抽象对应。
本文通过构造具有形式 $x \widesim{i} \epsilon$ 的定理以构建程序，
无论是通过对已有定理的演绎还是从头证明，
当然 $x$ 要有些别的要求，它们必须是一些可以
看作是计算机处理器指令的特定函数的组合，以允许编译到这些指令上。
给 $\widesim{\cdot}$ 关系取个名字叫 {\it 超越对应}。

定理 $x \widesim{i} \epsilon$ 严格来说不是类型关系，
$\widesim{\cdot}$ 是一个三元关系，可以允许 $x$ 在 $i$ 解释下 
$x \widesim{i} \epsilon$ 的同时又在 $j$ 解释下 $x \widesim{j} \phi$。
程序 $x$ 要求必须是基元指令的组合，这些基元指令意味着目标执行平台的
指令集，而抽象对应 $\epsilon$ 可以是任意的抽象对象。
单独的指代并没有任何意义，超越对应可以肆意构造，例如
一些诡异的解释将黑指代为白，而将鹿指代为马。
意义体现在同构，一个函数满足在某种指代下的输入有某种指代下的输出。
例如某个定理表明名叫 Add 的程序输入解释 $\mathcal{N}$ 下
对应 $x$ 和 $y$ 的值，$x, y$ 是自然数，就能输出在同样解释 $\mathcal{N}$
下对应 $x + y$ 的值，程序 Add 满足了超越对应的同构，
显然是在这种情形下对应着自然数加法。那么解释 $\mathcal{N}$
的本质为何根本没有任何意义，不需要纠结它的本体论问题而只要某段程序过程
满足某几个解释的超越对应的同构，就足够表明这段过程的指代语义。
这种同构会在后文写作 $\mathrm{Add} \proctr{\mathcal{N}|\mathcal{N}
|\mathcal{N}}{cond} (+)$，其中 $cond$ 表示过程 Add 执行的条件。



Agda、Idris 等基于 Curry-Howard 同构的语言使用类型系统证明程序的性质，
即 $x : P$，$P$ 即是类型又是性质。
而程序 $x$ 不得不扮演多个角色，首先它必须是对定理的证明，然后又是
承载业务逻辑的可执行程序。

而本文的情况，先是在某种解释或者某种解释的同构下证明程序$x$对应于
抽象$\epsilon$，再证明抽象 $\epsilon$ 满足的任意性质 $Q$ 
以证明程序 $x$ 的性质。例如上文的 Add 函数的例子，可以轻易地证明
$(+)$ 属于 $\mathrm{Even} \rightarrow \mathrm{Even} \rightarrow 
\mathrm{Even}$ 或者 
$\mathrm{Odd} \rightarrow \mathrm{Odd} \rightarrow \mathrm{Odd}$
而由此证明 Add 在那理解下也有此性质。
于是 Add 的实现，只要专注于工程性能就可以，任意性质的证明只发生在其
抽象对应上，是在抽象的领域内完成的，抽象和工程的两个世界不会相互干扰。
于是在得到很好执行性能的编译结果的同时，对其性质的证明依旧容易。

演绎定理以构建程序。
Curry-Howard 同构连接起了程序与证明。
本文的新思路应与 Curry-Howard 同构有什么联系，看似如此而深入的思索与
更严谨的论述笔者都失败了。构造演算（COC）与基于此的 Coq 证明工具
受 Curry-Howard 同构的启发，从程序走向证明。本文似是相反的，
演绎或者证明定理以构建程序。但更严谨地论述，这套构建程序的新方法中并没有
类型系统，虽然这些程序也基于 λ 演算，但跟 λ 演算的类型系统关联并不大。
这似乎是种新的对应，一个看起来理所当然的对应，一个描述程序超越对应关系
的定理自然包含那个程序，于是演绎与证明这种定理自然也就在构造其中的程序。而背后是有内在关联的，定理的演绎与程序的构造，这两者的对应关系正是
Curry-Howard 同构的内涵。



