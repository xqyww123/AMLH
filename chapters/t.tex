\section{类型系统的再思考}

长久以来类型系统仅被用作一种辅助程序开发的形式化工具，
作为一种 Model checker，能有效地检查某种形式的错误，并为程序开发提供
一定的辅助，特别是在语义层面上。
作为一种工具，类型系统的重心集中在类型推导与类型检查上，前者意味着
性质的自动推导而后者是性质的证明。
一个类型关系（Typing）是类型系统作为一个形式系统上的定理，类型推导
是对此定理的自动推理（inference）而类型检查则是对此定理的证明。
这个定理包含了两部分，一般写作 $x : \tau$ 即值 $x$ 具有类型 $\tau$，
而类型系统定义了一系列定理的推导规则，例如：

……

即如果有定理 $f : \sigma \rightarrow \tau$ 且有定理 $a : \sigma$ 那么
可以演绎出定理 $f\ x : \tau$。

一直以来，类型系统与编程语言始终聚焦在，给出了一种计算，或者说一段源代码
，即类型关系的左边 $x$ 这一部分，这一部分可能包含一定的类型标注，
而类型系统推导或者验证类型关系的右边部分 $\tau$。包括各种编程语言如
C/C++、Jave、Ruby，以及那些 Curry-Howard 同构下用于形式化证明的系统如
Coq、Agda、Idris，都是着重于计算，由程序到类型关系。只不过编程语言
注重于程序本身，类型系统是辅助程序开发；而Coq 系的证明系统注重于
类型关系在 Curry-Howard 同构下对应的被形式验证的定理，而计算是以
得到这些定理的证明过程。

既然一个类型关系 $x : \tau$ 已经包含了程序部分 $x$，而类型关系是一个
定理，那能否着重于类型关系作为一个定理本身，推导作为定理的类型关系而
进行程序开发。即原本编写一段以 $a$ 对 $f$ 调用的程序是写下作为源程序
的文本 $f(x)$，但现在能否是从定理 $f : \sigma \rightarrow \tau$ 和
定理 $a : \sigma$ 中演绎出定理 $f\ x : \tau$，而$:$左边的 $f\ x$ 
就是得到的程序。

这一思路下，作为定理的类型关系成为构造的对象，而此定理已经不需要具有
$x : \tau$ 的形式只要包含程序 $x$，且有对程序 $x$ 的任意性质
的描述。在本文，融汇了指称语义（Denotation Semantic）理论后，这一
定理具有形式 $x \widesim{i} \epsilon$，$\sim$ 是一个三元关系，$x$
表示程序，$i$ 表示理解方式，$\epsilon$ 表示程序 $x$ 在理解方式 $i$
下的指称，即抽象对应。本文通过构造具有形式 
$x \widesim{i} \epsilon$ 的定理以构建程序，无论是通过对已有
定理的演绎还是从头证明，当然 $x$ 要有些别的要求，它们必须是一些可以
看作是计算机处理器指令的特定函数的组合，以允许编译到这些指令上。

定理 $x \widesim{i} \epsilon$ 严格来说不是类型关系，
$\sim$ 是一个三元关系，可以允许 $x$ 在 $i$ 解释下 
$x \widesim{i} \epsilon$ 的同时又在 $j$ 解释下 $x \widesim{j} \phi$。

Agda、Idris 等基于 Curry-Howard 同构的语言使用类型系统证明程序的性质，
即 $x : P$，$P$ 即是类型又是性质。
而程序 $x$ 不得不扮演多个角色，首先它必须是对定理的证明。

而本文的情况，先是在某种解释 $i$ 下，$x \widesim{i} \epsilon$，再
证明抽象对应 $\epsilon$ 满足的任意性质 $Q$ 以证明程序 $x$ 的性质。

