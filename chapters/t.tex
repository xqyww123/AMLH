\section{本文工作的介绍}
%\section{类型系统的再思考与 Noesis 系统}

%长久以来类型系统仅被用作一种辅助程序开发的形式化工具，
%一种 Model checker，能有效地检查某种形式的错误，并为程序开发提供
%一定的辅助，特别是在语义层面上。
%作为一种工具，类型系统的重心集中在类型推导与类型检查上，前者意味着
%性质的自动推导而后者是性质的证明。
%一对类型关系（Typing）是类型系统作为一个形式系统上的定理，类型推导
%是对此定理的推理（inference）或感知（reasoning）而类型检查则是对此定理的证明。
%这个定理包含了两部分，一般写作 $x : \tau$ 即值 $x$ 具有类型 $\tau$，
%而类型系统定义了一系列定理的推导规则，例如：
%
%\begin{prooftree}
%\AxiomC{$M : \sigma \rightarrow \tau$}
%\AxiomC{$N : \sigma$}
%\BinaryInfC{$M N : \tau$}
%\end{prooftree}
%
%即如果有定理 $f : \sigma \rightarrow \tau$ 且有定理 $a : \sigma$ 那么
%可以演绎出定理 $f\ x : \tau$。
%
%一直以来，旨在构建程序的编程语言仅将类型系统作为一种辅助工具——
%给出了一种计算，或者说一段源代码，即类型关系$x : \tau$的左边 $x$ 这一部分，
%这一部分可能包含一定的类型标注，而类型系统推导或者验证类型关系的右边部分 $\tau$。
%包括各种编程语言如 C/C++、Jave、Ruby 都是着重于程序部分，
%一般是由程序推演类型关系，而类型系统是辅助程序开发。
%
%既然一个类型关系 $x : \tau$ 已经包含了程序部分 $x$，而类型关系是一个
%定理，那能否着重于类型关系作为一个定理本身，推导作为定理的类型关系而
%进行程序开发。即原本编写一段以 $a$ 对 $f$ 调用的程序是写下作为源程序
%的文本 $f(x)$，但现在能否从定理 $f : \sigma \rightarrow \tau$ 和
%定理 $a : \sigma$ 中演绎出定理 $f\ x : \tau$，而$:$左边的 $f\ x$ 
%就是得到的程序。
%
%
%
%程序具有的性质也是其抽象语义具有的性质，于是可以证明抽象语义的性质以
%证明程序的性质。
%再而本文围绕 Noesis 定理提出了 Noesis 形式系统，允许演绎而构建
%Noesis 定理，进而构建程序，并得到此程序的抽象语义，且此程序的抽象语义与
%程序的关联被定理保障。
%
%证明程序的抽象语义的性质
%
%
%
%
%
%
%
%
%
%
%
%即演绎定理以构建程序。
%
%Curry-Howard 同构下{\it 程序即是证明(proof as program)}的编程语言与定理证明工具抓住了要点。特别是 Coq，
%完美地实现了演绎定理以构建程序。
%
%只是 Coq、Agda、Idris、F* 等等基于构造演算的系统还是将思维停留在了盒子中，
%本文的贡献在于，在演绎定理以构建程序的思路下，{\bfseries 演绎以构建程序的定理，
%不需要是 $x : \tau$ 的形式，不需要是二元的类型关系}。Curry-Howard 同构自然
%只在类型系统中显现，但单纯为了构建程序而演绎的定理，不需要限制在类型关系，
%只需要定理中包含程序即可，{\bfseries 进而可以是呈现更多性质的扩广}，
%而在此扩广下也会有相应的 Curry-Howard 同构的扩广。
%
%%$x \widesim{i} \epsilon$，
%%其中 $x$ 是程序，$i$ 是各种不同的理解方式，$\epsilon$ 是在理解 $i$ 下程序 $x$ 的抽象
%%对应，抽象的意义。
%%
%

\subsection{本文理论方面的工作} \label{Sec.works.theoritical}

本文首先提出一种新的公理系统，Noesis 系统，
描述程序与其抽象语义（Abstract Meanning）的关联。
一个程序的抽象语义，是一个数学对象，具有程序所拥有的，一切用户所关切的性质的数学对象，
进而可以通过证明抽象语义的性质来证明程序的性质。

一个程序的抽象语义由指令集与常量集确定，而
指令集与常量集的抽象语义是 Noesis 系统上的公理，是被定义而非证明的。
当指令与常量的抽象语义被正确定义为某个执行环境时，Noesis 定理即正确反映了程序
在此执行环境上的抽象语义。

本工作并非推理某段给定程序的抽象语义，本工作是提供一种技术，
允许用户构造具有明确抽象语义的程序。
更具体地说，这种技术允许用户从旧的、已有的程序与抽象语义的对应中构造新的程序及其抽象
语义的对应。而最初的对应来自于作为公理的基元指令与常量。
这种程序与抽象语义的对应表达为 Noesis 系统上的定理，用户通过演绎旧有的定理
构造新的，描述一个新程序的抽象语义的定理。而所有最初的定理就是公理。

与传统形式化方法不同，本文不是在构建一种分析工具，而是构造一种编程技术，使得用户通过这种
编程技术可以构造具有明确抽象语义的，易于被形式化验证的程序。
这套技术基于 HOL 交互式定理证明器完成，程序的抽象语义是定理证明器上易于分析的数学对象，
用户可以之后形式化地分析验证这抽象语义来完成对整个程序的分析与验证。

%例如 32 位加法指令 \texttt{i32.add} 的抽象语义定义为有限域 
%$\mathbb{F}_{2^{32}}$ 上的加法，常量 \texttt{1} 的抽象语义为
%$\mathbb{F}_{2^{32}}$ 中的 1，那么组合程序 \texttt{i32.add\ 1\ 1}
%的抽象语义自然就是 $1 + 1$。且这些抽象语义上的性质对应程序上的性质，
%于是由 $1 + 1$ 是偶数的证明亦是对组合程序 \texttt{i32.add\ 1\ 1} 会
%输出偶数的证明。对具象程序的分析变为对抽象数学对象的分析，
%形式化验证被有效地简化。

%，Curry-Howard 同构意味着可以演绎定理以构建程序。
%
%
%
%
%
%
%
%
%
%
%
%这种逻辑可以实现在经典逻辑中
%，或者说可以作为经典逻辑的子集。
%本文再而提出一种新的形式化方法，通过演绎 Noesis 形式系统上的
%Noesis 定理，来构建被验证的程序。
%
%本文提出的方法不是一种 Model check，它并不用于验证程序，
%它是用于构建被验证的程序。
%
%Curry-Howard 同构连接起程序世界与证明理论，一段程序同构于一段证明过程，
%程序的复合方法同构于演绎律，程序的复合同构于演绎律的复合。
%于是 Curry-Howard 同构意味着，可以演绎定理以构建程序。
%
%



现在更具体地讨论。
Noesis 定理具有形式
%在本文，演绎以构建程序的定理，是程序到其抽象语义的对应关系，具有形式
$x \widesim{i} \epsilon$，
其中 $\widesim{\cdot}$ 是一个三元关系，$x$ 表示值%，名叫 {\it 现象}
，%({\it phenomenon, φαινόμενον})，
$i$ 表示理解方式叫做 {\it 理解}({\it understanding, nóēsis})，%, νόησῐς})，
$\epsilon$ 表示值 $x$ 在理解 $i$ 下的抽象语义，
%名叫 {\it 本体}({\it noumenon, νoούμενον})，
$\widesim{\cdot}$ 关系叫做{\it Noesis 对应}({\it Noesis correspondence})。
类型关系被替换成 Noesis 对应，类型系统被替换成围绕 Noesis 对应
构造的名为 {\it Noesis 系统}({\it Noesis system }) 的形式系统。
本文不再关注类型关系而是围绕 Noesis 对应，
通过构造具有形式 $x \widesim{i} \epsilon$ 的定理以构建程序，
无论是通过对已有定理的演绎还是从头证明。
%当然 $x$ 要有些别的要求，它们必须是一些可以
%看作是计算机处理器指令的特定函数的组合，以允许编译到这些指令上。

抽象语义 $\epsilon$ 是定理证明器上任意的数学对象，是数学友好的并易于分析与证明的，
比如集合与数学映射。
Noesis 定理保障了程序实现与其抽象语义的对应，
而后用户只需证明抽象语义的性质以证明程序的性质，比如证明作为一个值的抽象语义的
自然数 $7$ 是质数以证明这个值表达一个质数，或者关于参数 $n$ 的程序的抽象语义
$2^n + 1$ 不总是质数以证明此程序并不总是输出质数。
去分析抽象的数学对象，而不是面对一段具象的复杂的程序。

若将程序的设计也由此定理证明器上的形式语言描述为一种抽象的数学对象，
就与程序的抽象语义位于同一个形式语言的空间中，
那么证明程序的抽象语义与此设计的抽象表达的相等性，就能彻底证明程序实现对于此设计的正确性。
而这种证明是容易的，因为程序的抽象语义是数学友好的，易于分析的。

这有点像指称语义（Denotation Semantic），有相似的初衷，
但实质的内容是完全不同的，不应被混淆。
最大的区别在于，指称语义从来不尝试替代类型系统，不考虑构建程序，其
找到的指称对应只是一种解释方式。
%指称语义既限制了不同理解的可能，
%它始终只围绕一种理解方式，又根本不精准，始终只是满足关系，而不是等价
%关系，这会疏漏很多的细节。

%Noesis 系统的灵感来源于形而上学(Metaphysics)的本体论(Ontolog)，在程序构成的世界中，
%直观可感受的现象值是数值与数值的计算，这些作为现象的数值背后的本体是计算所承载的
%抽象的理念（idea），该理念多数是由程序的编写者赋予。
%在程序的世界中，作为现象的计算的意义存在于理念的空间而无法被执行计算的计算机设备
%直接感受，计算设备直接感受到的只是作为现象的数值，故术语现象(phenomenon)与
%本体(noumenon)的使用是恰当的。而现象与本体直接的对应关系是通过程序的编写者，
%用户的智慧(nous)去理解的，词汇 noesis 意为智慧 nous 的行使，具有理解的意味，
%而 nous 是本体 noumenon 的词源，故 noesis 的使用也是恰当的。
%对现象 phenomenon 进行理解 noesis 的结果是本体 noumenon。

可以用一些例子更细致地说明 Noesis 系统，以及具体如何演绎定理以构建程序。
若已拥有定理 $x \widesim{i} \epsilon$ 表示值 $x$ 对应抽象语义 
$\epsilon$，定理 $\forall a\ \phi.\ a \widesim{i} \phi \Rightarrow
f(a) \widesim{i} g\ \phi$ 表示过程 $f$ 对应数学函数 $g$，
于是自然地由肯定前件（Modus Ponens）推导出
\[ f(x) \widesim{i} g\ \epsilon \]
即过程调用 $f(x)$ 的抽象语义为 $g\ \epsilon$。此肯定前件律的应用是程序 $f(x)$ 的构建。
用户的编程行为，既是通过程序操作抽象语义，也是通过编织抽象语义来构建程序。

一个程序在不同的理解下可以有不同的抽象语义。
%一个本体可以表现不同现象，这是自然的。
%而在本文的 Noesis 系统中，这一情形可以倒置过来，
%一个现象可以在不同的理解下对应
%到不同的本体，或者说不同的本体在不同理解下可以表达为同一个现象
%（现象的欺骗）。
$\widesim{\cdot}$ 是一个三元关系，可以允许 $x$ 在 $i$ 解释下 
$x \widesim{i} \epsilon$ 的同时又在 $j$ 解释下 $x \widesim{j} \phi$。
这也意味着 Noesis 对应根本不是某种类型关系的变形，而是根本地对
类型关系的扩展。

单独的对应并没有任何意义，理解可以任意地构造以将任何程序对应到
任何抽象语义。
%单独的指称并没有任何意义，理解可以肆意捏造以将任意的现象对应到
%任何本体，例如一些诡异的理解可以将黑指代为白，而将鹿指代为马。
意义体现在同构(Homomorphism)，无论怎样任意设定的{\it 理解} $i$，当其确定
，若能证明程序过程$p$ 输入理解$i$下对应到抽象语义$\epsilon$的值，
会输出在理解$j$下对应到抽象语义 $f(\epsilon)$ 的值，则此函数的抽象语义
就被理解 $i,\ j$ 确定，即 $f$。
例如某个定理表明名叫 Add 的程序当输入理解 $\mathcal{N}$ 下
对应 $x$ 和 $y$ 的值时，其中$x, y$ 是自然数，
就能输出在解释 $\mathcal{N}$ 下对应 $x + y$ 的值，
程序 Add 满足了 Noesis 对应的同构，
显然是在这种情形下对应着自然数加法。那么解释 $\mathcal{N}$
究竟为何根本没有任何意义，不需要纠结它的本体论问题，只要某段程序过程
满足某几个解释的 Noesis 对应的同构，就足够表明这段过程的抽象语义。
这种同构会在后文叫做 Noesis 同构，部分简单形式能用记号 
$\proctr{i|j|\cdots|k}{cond}$ 表达，
例如$\mathrm{Add} \proctr{\mathcal{N}|\mathcal{N}|\mathcal{N}}{cond} (+)$，
其中 $cond$ 表示过程 Add 执行的条件。更通用的
\[ f \proctr{i|j|\cdots|k}{cond} \psi \]
表示程序过程 $f$ 拥有参数的理解为 $i,j,\cdots$ 返回值的理解为 $k$ 
的 Noesis 对应的同构并同构于抽象的 $\psi$ ，且执行条件为 $cond$。

Noesis 系统中核心的演绎律是

\vspace{6mm}
{\centering 
  \begin{tabular}{c c}
\AxiomC{$\Gamma_1 \vdash a \widesim{i} \epsilon$}
\AxiomC{$\Gamma_2 \vdash
  f \proctr{i|j|\cdots|k}{cond} \psi $} \RightLabel{(调用)}
\BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash
  f\ a \proctr{j|\cdots|k}{cond\ \epsilon} \psi\ \epsilon$}
    \DisplayProof &
\AxiomC{$\Gamma_1 \vdash cond$} 
\AxiomC{$\Gamma_2 \vdash x \proctr{i}{cond} \phi $}
\RightLabel{(条件削除)} \BinaryInfC{$\Gamma_1 \cup \Gamma_2
  \vdash x \widesim{i} \phi$} \DisplayProof \end{tabular}

\hfill

\begin{tabular}{c c c}
  \AxiomC{$\Gamma, a \widesim{i} \epsilon \vdash f \proctr{j|\cdots|k}
  {cond} \phi $} \RightLabel{(抽象)}
\UnaryInfC{$\Gamma \vdash \lambda a.\ f \proctr{i|j|\cdots|k}{\lambda
  \epsilon.\ cond} \lambda\epsilon.\ \psi$}
  \DisplayProof & \AxiomC{} \RightLabel{(参数)} \UnaryInfC{
  $p \widesim{i} \epsilon \vdash p \widesim{i} \epsilon$}
    \DisplayProof &
\AxiomC{$\Gamma,\ cond \vdash x \widesim{i} \epsilon $}
\RightLabel{(条件引入)} \UnaryInfC{$\Gamma \vdash 
  x \proctr{i}{cond} \phi$} \DisplayProof
  \end{tabular} \par}

\vspace{6mm}
Neosis 系统的公理中的值与过程，构成了 Neosis 系统
上的程序的常量集与指令集。
一个形式系统的所有定理都来自于其公理按其定义的演绎律的演绎。
而同样是一种形式系统的 Neosis 系统，在通过演绎律由公理构造定理的同时也
由常量集和指令集构造了程序，这些程序就是指令集和常量集的组合.
而组合方式是上述的调用与抽象，即函数调用与函数构建。

于是 Noesis 系统中作为公理的基元指令与常量构建了一台抽象机器，
而 Noesis 系统构建的程序就是此抽象机器上的程序。
对程序等价变化展开成基元指令与常量的表达就成为了编译。
令抽象机器的基元指令与常量的设定尽可能接近某个目标执行环境，以至于这些基元指令与常量
可以实现在此目标执行环境上，于是程序的基元指令与常量表达也可以实现于目标执行环境，
就将 Noesis 系统上的程序编译到了目标执行环境，就能生产切实可执行的程序。
此即如何演绎 Noesis 定理以构建程序。

Agda、Idris 等具有依赖类型系统的语言使用类型表述程序的性质，
即 $x : P$，$P$ 即是类型又是性质，而程序得兼任证明，必须一人分饰两角，
这些批评前面已经讨论了。

而本文的情况是，先在某种解释或某种解释的同构下证明程序$x$对应于
抽象$\epsilon$，再证明抽象 $\epsilon$ 满足某个性质 $Q$ 
以证明程序 $x$ 具有此性质 $Q$。例如上文的 Add 函数的例子，可以轻易地证明
$(+)$ 属于 $\mathrm{Even} \rightarrow \mathrm{Even} \rightarrow 
\mathrm{Even}$ 或者 
$\mathrm{Odd} \rightarrow \mathrm{Odd} \rightarrow \mathrm{Odd}$
而由此证明 Add 在也有此性质。
于是 Add 的实现，只要专注于工程性能就可以，任意性质的证明只发生在其
抽象对应上，是在抽象的领域内完成的，抽象和工程的两个世界不会相互干扰。
于是在得到很好执行性能的编译结果的同时，对其性质的证明依旧容易。

演绎定理以构建程序。
Curry-Howard 同构连接起了程序与证明。
本文的新思路应与 Curry-Howard 同构有某种联系。Coq 证明工具
受 Curry-Howard 同构的启发，从程序走向证明。本文似是相反的，
演绎或者证明定理以构建程序。但更严谨地论述，这套构建程序的新方法中并没有
类型系统，虽然这些程序也基于 λ 演算，但跟 λ 演算的类型系统关联并不大。
这似乎是种新理所当然的对应，一个描述程序 Noesis 对应关系
的定理自然包含那个程序，于是演绎与证明这种定理自然也就在构造其中的程序。

特别是， Noesis 对应在一些特例下退化为类型关系，令冒号 $:$ 为一种程序
到定理的理解，而 $\mathrm{Abs}$ 同构于 $\rightarrow$
\[ \mathrm{Abs} \proctr{:|:|:}{\K \K \T}
(\lambda x\ y.\ x \rightarrow y) \]
这再次揭示 Noesis 对应是类型关系的扩广。而此时
以 $:$ 为理解的 Noesis 对应也显示出了 Curry-Howard 同构，程序成为证明
而抽象语义既是类型又是命题或者定理。既然 Noesis 对应是类型关系的扩广，那似乎暗示着 
Curry-Howard 同构也应存在着某种扩广，也许是沟通起程序与建构主义式的
抽象构造的桥梁。
似乎显然的一点是，一切被建构的构造，都有一个程序对应。%，数学是，证明是，
%一块布丁也是。

\subsection{用于实践本文理论的软件工具 \Eamlh} \label{Sec.works.eng}

本文设计并实现了工具 \Eamlh 以允许用户
在实际的工业生产中使用上一节介绍的 Noesis 理论，通过演绎 Noesis 定理
来构建具有明确抽象语义的程序，并对程序的抽象语义进行形式化验证。
图 \ref{fig:total-frame} 是软件 \Eamlh 的架构，由4部分组成：HOL 定理证明器上的 Noesis
理论、生产目标执行环境机器代码的编译后端、连接编译后端与定理证明器的中间层编辑壳层、
最终与用户交互的编辑前端。

\begin{figure}[h] 
  \centering \begin{tikzpicture}\useasboundingbox (-5,-5) rectangle (5,5);
\baselineskip=0.5cm
    \draw (0,0) node (O) {编辑壳层} circle [radius=1.2];
  \path[name path=vCbarD] (60:3.3) -- ([turn]-90:1.5);
  \path[name path=vCbarU] (60:3.3) -- ([turn]90:1.5);
  \path[name path=hCbarD] (15:1.5) -- ([turn]45:4);
  \path[name path=hCbarU] (105:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vCbarD and hCbarD, by=x}] 
  (60:1.5) arc [start angle=60, end angle=15, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vCbarU and hCbarU, by=x}]
  (60:1.5) arc [start angle=60, end angle=105, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (60:2.4) node {编译\\后端};
  \draw (60:4) node[dart,draw,minimum size=1cm, shape border rotate=60,
    shape border uses incircle,fill=white] (B) {编译};
  \draw [->] (65:0.9) -- ([turn]-5:0.8);
  \draw [<-] (55:0.9) -- ([turn]5:0.8);

  \path[name path=vbarD] (-60:3.7) -- ([turn]-90:1.5);
  \path[name path=vbarU] (-60:3.7) -- ([turn]90:1.5);
  \path[name path=hbarD] (-105:1.5) -- ([turn]45:4);
  \path[name path=hbarU] (-15:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vbarD and hbarD, by=x}] 
  (-60:1.5) arc [start angle=-60, end angle=-105, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vbarU and hbarU, by=x}]
  (-60:1.5) arc [start angle=-60, end angle=-15, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (-60:2.5) node {HOL\\证明器};
  \draw [fill=white] (-60:4.6) +(-60:1.3) -- +(-150:1.3) -- +(120:1.3) -- + (30:1.3) -- +(-60:1.3);
  \draw (-60:4.6) node [align=center] (A) {Noesis\\理论};
  \draw [->] (-55:0.9) -- ([turn]-5:0.8);
  \draw [<-] (-65:0.9) -- ([turn]5:0.8);
  \path[name path=Vbar] (-4,1.2) -- (-4,-1.2);
  \path[name path=Dhbar] (-135:1.5) -- +(-3,0);
  \path[name path=Uhbar] (135:1.5) -- +(-3,0);
  \draw [name intersections={of=Vbar and Uhbar, by=x}] 
  (-1.5,0) arc [start angle=180, end angle=135, radius=1.5] -- (x) -- (-4,0);
  \draw [name intersections={of=Vbar and Dhbar, by=x}]
  (-1.5,0) arc [start angle=180, end angle=225, radius=1.5] -- (x) -- (-4,0);
  \draw [align=center] (-2.8,0) node {编辑器\\前端};
  \draw [<-] (175:1) -- +(-0.8,0);
  \draw [->] (-175:1) -- +(-0.8,0);
  \draw (-4.4,0) node[left] {用户};
  \draw [<-] (175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  \draw [->] (-175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  %\path (B) ([turn]-90:2) node (BX) {};
  %\draw [->,thick,rounded corners=1cm] (A) ([turn]90:1.8) -- (0:1.8) -- (BX);
\end{tikzpicture}
\caption{演绎 Noesis 理论以构建程序的整体框架} \label{fig:total-frame}
\end{figure}

本工作使用 HOL 交互式定理证明工具作为定理推理引擎，其详细介绍在 \ref{Sec.ITP} 节。

首先在 HOL 定理证明工具上构造一系列定义、谓词、定理以及证明策略，将
Noesis 系统实现在 HOL 交互式定理证明器的证明系统中，进而可以使用 HOL 逻辑
表述值、理解、抽象语义。其中值与理解将被特别地定义，而
抽象语义就是 HOL 逻辑中任意的数学对象(mathematical object)，
例如数学映射、集合、有限域。于是可以有效且自然地证明抽象语义的任意性质，
因为这抽象语义就是 HOL 逻辑上自然存在的数理对象。

Noesis 对应成为 HOL 定理证明工具上的定理，演绎 Noesis 定理就是演绎 HOL 的定理。
关于定理演绎的一切数学操作都由 HOL 定理证明器完成，这些演绎的正确性，即定理推导的正确性，
就都由 HOL 定理证明器保障。

于是本工作的工程实现是缺陷免疫的。任何实现上的缺陷只会导致用户无法编织所期望的程序，
而任何推导出的定理必定是正确的，因为本工作推导出的一切定理都来自于 HOL 定理证明器，
本工作本身不生产定理只是操作 HOL 定理证明器演绎推导定理。而 HOL 定理证明器的正确性，
在 \ref{Sec.deBruijn} 节 de Bruijn 标准中详细的讨论。本工作是满足 de Bruijn 标准的，
本工作给出的任何定理的正确性严格等于 HOL 定理证明器的正确性，
而与本工作本身的工程实现无关。
即便工程实现中不幸引入了缺陷，也不影响本工作输出的定理的正确性。

实现在 HOL 证明器上的 Noesis 系统叫做 \noesishol，结合常量与基元指令设定后构成的
抽象机器叫做 \amlh。
\lamcr 是 Noesis 的古希腊文词源 νόησις 的动词原型，意为去理解、去思考。
图 \ref{fig:noe-sys-relas} 比较了 Noesis 系统、\noesishol、\amlh 与
\amlh 上的程序。

用户不需要直接操作定理证明器，交互式的编辑器前端与编辑壳层将定理证明器封装，并提供用户
统一的易于使用的接口。

最后编译方面，分为两步。首先操纵 HOL 证明器对 \amlh 上的程序等价变换展开成基元指令与常量
的表达，注意这种变换是由 HOL 证明器保障的，故至此的编译是被形式化验证的。
而后程序的基元指令与常量表达作为一种中间表达（Intermediate Representation, IR），
以文本的形式由 HOL 证明器输出，编辑壳层将其输入编译后端，并最终生成目标执行平台上的可执行
程序。编译后端最后的编译加工是没有保障的，在形式化验证之外的，可能有错误的。
但如前所述，\amlh 的基元指令集与常量被设定的如此接近目标执行环境，以至于编译后端的工作
尽可能的简单，几乎就只是 IR 文本到机器代码的映射，以至于潜在编译缺陷尽可能的非常少。
且编译后端作为一个程序是固定的，可以后续对其形式化验证以将形式化验证的范围扩展。
总之，本工作的形式化验证的保障范围是 IR 级别的，可以保障用户程序到 IR 级别的正确性。

\begin{figure}[h] 
  \centering \begin{tikzpicture} \baselineskip=0.5cm
    \draw (0,0) node (O) {编辑壳层} circle [radius=1.2];
  \path[name path=vCbarXD] (60:3.3) -- ([turn]-90:1.5);
  \path[name path=vCbarXU] (60:3.3) -- ([turn]90:1.5);
  \path[name path=hCbarXD] (15:1.5) -- ([turn]45:4);
  \path[name path=hCbarXU] (105:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vCbarXD and hCbarXD, by=x}] 
  (60:1.5) arc [start angle=60, end angle=15, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vCbarXU and hCbarXU, by=x}]
  (60:1.5) arc [start angle=60, end angle=105, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (60:2.4) node {编译\\后端};
  \draw (60:4) node[dart,draw,minimum size=1cm, shape border rotate=60,
    shape border uses incircle,fill=white] (B) {编译};
  \draw [->] (65:0.9) -- ([turn]-5:0.8);
  \draw [<-] (55:0.9) -- ([turn]5:0.8);

  \path[name path=vbarXD] (-60:3.7) -- ([turn]-90:1.5);
  \path[name path=vbarXU] (-60:3.7) -- ([turn]90:1.5);
  \path[name path=hbarXD] (-105:1.5) -- ([turn]45:4);
  \path[name path=hbarXU] (-15:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vbarXD and hbarXD, by=x}] 
  (-60:1.5) arc [start angle=-60, end angle=-105, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vbarXU and hbarXU, by=x}]
  (-60:1.5) arc [start angle=-60, end angle=-15, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (-60:2.5) node {HOL\\证明器};
  \draw [fill=white] (-60:4.6) +(-60:1.3) -- +(-150:1.3) -- +(120:1.3) -- + (30:1.3) -- +(-60:1.3);
  \draw (-60:4.6) node [align=center] (A) {Noesis\\理论};
  \draw [->] (-55:0.9) -- ([turn]-5:0.8);
  \draw [<-] (-65:0.9) -- ([turn]5:0.8);
  \path[name path=VbarX] (-4,1.2) -- (-4,-1.2);
  \path[name path=DhbarX] (-135:1.5) -- +(-3,0);
  \path[name path=UhbarX] (135:1.5) -- +(-3,0);
  \draw [name intersections={of=VbarX and UhbarX, by=x}] 
  (-1.5,0) arc [start angle=180, end angle=135, radius=1.5] -- (x) -- (-4,0);
  \draw [name intersections={of=VbarX and DhbarX, by=x}]
  (-1.5,0) arc [start angle=180, end angle=225, radius=1.5] -- (x) -- (-4,0);
  \draw [align=center] (-2.8,0) node {编辑器\\前端};
  \draw [<-] (175:1) -- +(-0.8,0);
  \draw [->] (-175:1) -- +(-0.8,0);
  \draw (-4.4,0) node[left] {用户};
  \draw [<-] (175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  \draw [->] (-175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  \path (B) ([turn]-90:2) node (BX) {};
  \draw [->,thick,rounded corners=1cm] (A) ([turn]90:1.8) -- (0:1.8) -- (BX);
\draw [align=center] (A) ([turn]90:2) node[right]{等价变换\\展开成基元指令\\与常量的表达};
    \draw [align=center] (2.7,0) node[right] {得到中间表达};
    \draw [align=center] (BX) node[right] {编译中间表达\\至目标执行环境};
\end{tikzpicture}
\caption{编译流程示意} \label{fig:compilation}
\end{figure}

此外还有很多问题值得讨论：既然是演绎定理来构建程序，就显然不能将源代码
写在纸上或者文本编辑器里，文本形式的源代码自然应当被抛弃，而定理与数理逻辑
对象才是 \amlh 上程序的源代码。本文设计了 {\it 编辑壳层}
以允许用户交互式地演绎定理、操作数学对象，以构造程序。
既然是演绎定理来构建程序，就显然不能
基于源代码分析而为用户提供编程辅助与支持，编程辅助与支持变成一种全新的
数理范畴内的，是使用定理证明器构造一系列证明策略与分析工具而为编程提供
支持，并且允许分析与辅助做得更多的多。由下层定理证明器对 \amlh 上程序
进行符号分析以允许对程序进行模拟执行，时间、开销、并行模型与资源都可以
考虑进来。

%诸如此类，非常多令人振奋的新视角新方法将在接下来慢慢论述。

\section{章节安排}

\begin{itemize}[leftmargin=1.5cm]
\item[第 \ref{Ch.intro} 章] 概括性地介绍本文工作。
  \item[第 \ref{Ch.ReqTh} 章] 进行混淆区分、记号定义、与必要的理论介绍，包括 HOL 交互式定理证明器
的介绍。
\item[第 \ref{Ch.AmLH} 章] 细致地论述本文提出的 Noesis 系统，以及其在 HOL 上的实现，
  以及相关的各种细节。
\item[附录 \ref{Ch.ES}] 详细论述编辑壳层，因内容过多且与 Noesis 系统相对无关故置于附录。
  仅给感兴趣的读者，可以选择性阅读或跳过。
\item[第 \ref{Ch.Implementation} 章] 论述本文工作在智能合约场景上的实现，包括用于智能合约
  的抽象机器 \amlhS 的定义与实现，\amlhS 上程序的编译方法。这一章给出了一种实际可行的
  构造正确性被证明的智能合约的方案，并最终能编译出可运行于 EOS.IO 等智能合约平台的
  WASM 格式的智能合约。
\item[第 \ref{Ch.conclusion} 章] 总结本文工作，与其他现有方案比较，特别是与依赖类型系统
  比较。
%\item[附录 \ref{Ch.lambda}] 包括了 λ 演算粗浅的介绍与定义。
\item[附录 \ref{Ch.example.transfer}] 是第 \ref{Ch.Implementation} 章的扩充，
给出了一段相对完整的代币合约的转账部分在 \amlhS 上具体的构建过程与编译，
    以及编译结果的 WASM。因内容过于细致放于附录。
\end{itemize}

本文实现的工具 \Eamlh 的 Noesis 理论部分是第 \ref{Ch.AmLH} 章讨论的 Noesis 系统在 HOL 上的实现；
编辑壳层部分在附录 \ref{Ch.ES} 中过分细致地论述；编译后端目前只实现了到 EOS.IO 智能合约平台的，
在第 \ref{Ch.Implementation} 章具体论述编译的实现；最后的编辑前端在目前的实现中非常简陋，仅
提供命令行界面，大概使用了不到500行代码，故不在本文中细致论述。
