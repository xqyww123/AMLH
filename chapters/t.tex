\section{类型系统的再思考}

长久以来类型系统仅被用作一种辅助程序开发的形式化工具，
一种 Model checker，能有效地检查某种形式的错误，并为程序开发提供
一定的辅助，特别是在语义层面上。
作为一种工具，类型系统的重心集中在类型推导与类型检查上，前者意味着
性质的自动推导而后者是性质的证明。
一个类型关系（Typing）是类型系统作为一个形式系统上的定理，类型推导
是对此定理的自动推理（inference）而类型检查则是对此定理的证明。
这个定理包含了两部分，一般写作 $x : \tau$ 即值 $x$ 具有类型 $\tau$，
而类型系统定义了一系列定理的推导规则，例如：

\begin{prooftree}
\AxiomC{$M : \sigma \rightarrow \tau$}
\AxiomC{$N : \sigma$}
\BinaryInfC{$M N : \tau$}
\end{prooftree}

即如果有定理 $f : \sigma \rightarrow \tau$ 且有定理 $a : \sigma$ 那么
可以演绎出定理 $f\ x : \tau$。

一直以来，类型系统与编程语言始终聚焦在，给出了一种计算，或者说一段源代码
，即类型关系的左边 $x$ 这一部分，这一部分可能包含一定的类型标注，
而类型系统推导或者验证类型关系的右边部分 $\tau$。包括各种编程语言如
C/C++、Jave、Ruby，以及那些 Curry-Howard 同构下用于形式化证明的系统如
Coq、Agda、Idris，都是着重于计算，由程序到类型关系。只不过编程语言
注重于程序本身，类型系统是辅助程序开发；而Coq 系的证明系统注重于
类型关系在 Curry-Howard 同构下对应的被形式验证的定理，而计算是以
得到这些定理的证明过程。

既然一个类型关系 $x : \tau$ 已经包含了程序部分 $x$，而类型关系是一个
定理，那能否着重于类型关系作为一个定理本身，推导作为定理的类型关系而
进行程序开发。即原本编写一段以 $a$ 对 $f$ 调用的程序是写下作为源程序
的文本 $f(x)$，但现在能否是从定理 $f : \sigma \rightarrow \tau$ 和
定理 $a : \sigma$ 中演绎出定理 $f\ x : \tau$，而$:$左边的 $f\ x$ 
就是得到的程序。

\begin{center} 演绎定理以构建程序。\end{center}

这一思路下，作为定理的类型关系成为构造的对象，而此定理甚至不需要具有
$x : \tau$ 的形式，不需要类型关系，
只要包含程序 $x$ 以及对程序 $x$ 的任意性质的描述。

在本文，用于演绎以构建程序的定理，是程序到其抽象意义的对应关系，这些抽象
意义可以是任意的数学对象，比如集合与数学函数。
定理本身证明程序实现与其抽象意义的对应性的正确，自然如此，
否则定理也不该被叫做定理。
而后用户只要证明程序的抽象意义对设计的满足性，就能证明程序的正确实现。
抽象意义是数学对象，于是对设计满足的证明非常自然与容易，就像
证明自然数 $7$ 是质数，或者 $2^n + 1$ 不总是质数，而不是去面对一段复杂的程序。

这一切是可行的。
形式证明程序实现正确于其设计的前提是其设计在一个证明系统中被形式地描述，
即所谓形式描述（Formal Specification）。
在本文，用于演绎以构建程序的定理，是程序到形式描述所位于的证明系统的对应
，更直白地说，是程序到其抽象意义的对应，这种抽象意义位于一个可被形式描述
的证明系统，可以在此证明系统上形式描述程序设计，证明抽象意义对程序设计
的相等性，进而证明程序正确实现了其设计。

这种定理具有形式 $x \widesim{i} \epsilon$，
$\widesim{\cdot}$ 是一个三元关系，$x$ 表示程序部分，名叫 {\it 现象}，
$i$ 表示理解方式叫做 {\it 理解}，$\epsilon$ 表示程序 $x$ 在理解方式 $i$ 
下的指称，是抽象对应或者意义，名叫 {\it 本质}，$\sim$ 关系叫做
{\it 超越对应关系}。
类型关系被替换成超越对应关系，本文不再关注类型关系而是围绕超越对应，
通过构造具有形式 $x \widesim{i} \epsilon$ 的定理以构建程序，
无论是通过对已有定理的演绎还是从头证明。
当然 $x$ 要有些别的要求，它们必须是一些可以
看作是计算机处理器指令的特定函数的组合，以允许编译到这些指令上。

这很像指称语义，有类似的意味，也许可以参考以助于理解，
但理论内容是完全不同，不应被混淆。

一个例子能很好地说明这些。
若已拥有定理 $x \widesim{i} \epsilon$ 表示值 $x$ 对应抽象意义 
$\epsilon$，定理 $\forall a\ \phi.\ a \widesim{i} \phi \Rightarrow
f(a) \widesim{i} g\ \phi$ 表示过程 $f$ 对应数学函数 $g$，
于是自然地由肯定前件（Modus Ponens）推导出
\[ f(x) \widesim{i} g\ \epsilon \]
即过程调用 $f(x)$ 的本质为 $g\ \epsilon$。以此构建程序 $f(x)$。

定理 $x \widesim{i} \epsilon$ 也根本不是类型关系，
$\widesim{\cdot}$ 是一个三元关系，可以允许 $x$ 在 $i$ 解释下 
$x \widesim{i} \epsilon$ 的同时又在 $j$ 解释下 $x \widesim{j} \phi$。
程序 $x$ 要求必须是基元指令的组合，这些基元指令意味着目标执行平台的
指令集，而抽象对应 $\epsilon$ 可以是任意的抽象对象。

单独的指称并没有任何意义，{\it 理解}可以肆意捏造，例如
一些诡异的理解将黑指代为白，而将鹿指代为马。
意义体现在同构，无论怎样肆意设定的{\it 理解} $i$，当其确定，若能证明
一段程序过程$p$在理解$i$下指代到某个本质$\epsilon$的输入会
输出另一种理解$j$下指代到本质$f(\epsilon)$的输出，此函数的抽象意义
就被理解 $i,\ j$ 确定，即本质 $f$。
例如某个定理表明名叫 Add 的程序输入理解 $\mathcal{N}$ 下
对应 $x$ 和 $y$ 的值，$x, y$ 是自然数，就能输出在同样解释 $\mathcal{N}$
下对应 $x + y$ 的值，程序 Add 满足了超越对应的同构，
显然是在这种情形下对应着自然数加法。那么解释 $\mathcal{N}$
的本质为何根本没有任何意义，不需要纠结它的本体论问题而只要某段程序过程
满足某几个解释的超越对应的同构，就足够表明这段过程的抽象意义。
这种同构会在后文写作 $\mathrm{Add} \proctr{\mathcal{N}|\mathcal{N}
|\mathcal{N}}{cond} (+)$，其中 $cond$ 表示过程 Add 执行的条件。


Agda、Idris 等基于依赖类型系统的语言使用类型表述程序的性质，
即 $x : P$，$P$ 即是类型又是性质。
而程序 $x$ 不得不扮演多个角色，依赖类型系统基于的 Curry-Howard 同构
意味了这一点，首先它必须是对定理的证明，然后又是
承载业务功能的可执行程序。

而本文的情况，先是在某种解释或者某种解释的同构下证明程序$x$对应于
抽象$\epsilon$，再证明抽象 $\epsilon$ 满足的任意性质 $Q$ 
以证明程序 $x$ 的性质。例如上文的 Add 函数的例子，可以轻易地证明
$(+)$ 属于 $\mathrm{Even} \rightarrow \mathrm{Even} \rightarrow 
\mathrm{Even}$ 或者 
$\mathrm{Odd} \rightarrow \mathrm{Odd} \rightarrow \mathrm{Odd}$
而由此证明 Add 在那理解下也有此性质。
于是 Add 的实现，只要专注于工程性能就可以，任意性质的证明只发生在其
抽象对应上，是在抽象的领域内完成的，抽象和工程的两个世界不会相互干扰。
于是在得到很好执行性能的编译结果的同时，对其性质的证明依旧容易。

演绎定理以构建程序。
Curry-Howard 同构连接起了程序与证明。
本文的新思路应与 Curry-Howard 同构有什么联系，看似如此而深入的思索与
更严谨的论述笔者都失败了。构造演算（COC）与基于此的 Coq 证明工具
受 Curry-Howard 同构的启发，从程序走向证明。本文似是相反的，
演绎或者证明定理以构建程序。但更严谨地论述，这套构建程序的新方法中并没有
类型系统，虽然这些程序也基于 λ 演算，但跟 λ 演算的类型系统关联并不大。
这似乎是种新的对应，一个看起来理所当然的对应，一个描述程序超越对应关系
的定理自然包含那个程序，于是演绎与证明这种定理自然也就在构造其中的程序。而背后是有内在关联的，定理的演绎与程序的构造，这两者的对应关系正是
Curry-Howard 同构的内涵。

更有趣的是，超越对应在一些特例下退化为类型关系，令冒号 $:$ 为一种程序
到定理的理解，而 $\mathrm{Abs}$ 同构于 $\rightarrow$
\[ \mathrm{Abs} \proctr{:|:|:}{} (\lambda x\ y.\ x \rightarrow y) \]
于是此时以 $:$ 为理解的超越对应显示出了 Curry-Howard 同构，程序成为证明
而意义是定理。超越对应是类型关系的扩广似乎暗示着，Curry-Howard 同构
也存在着某种扩广。

