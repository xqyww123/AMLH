\section{本文工作的介绍}
%\section{类型系统的再思考与 Noesis 逻辑}

%长久以来类型系统仅被用作一种辅助程序开发的形式化工具，
%一种 Model checker，能有效地检查某种形式的错误，并为程序开发提供
%一定的辅助，特别是在语义层面上。
%作为一种工具，类型系统的重心集中在类型推导与类型检查上，前者意味着
%性质的自动推导而后者是性质的证明。
%一对类型关系（Typing）是类型系统作为一个形式系统上的定理，类型推导
%是对此定理的推理（inference）或感知（reasoning）而类型检查则是对此定理的证明。
%这个定理包含了两部分，一般写作 $x : \tau$ 即值 $x$ 具有类型 $\tau$，
%而类型系统定义了一系列定理的推导规则，例如：
%
%\begin{prooftree}
%\AxiomC{$M : \sigma \rightarrow \tau$}
%\AxiomC{$N : \sigma$}
%\BinaryInfC{$M N : \tau$}
%\end{prooftree}
%
%即如果有定理 $f : \sigma \rightarrow \tau$ 且有定理 $a : \sigma$ 那么
%可以演绎出定理 $f\ x : \tau$。
%
%一直以来，旨在构建程序的编程语言仅将类型系统作为一种辅助工具——
%给出了一种计算，或者说一段源代码，即类型关系$x : \tau$的左边 $x$ 这一部分，
%这一部分可能包含一定的类型标注，而类型系统推导或者验证类型关系的右边部分 $\tau$。
%包括各种编程语言如 C/C++、Jave、Ruby 都是着重于程序部分，
%一般是由程序推演类型关系，而类型系统是辅助程序开发。
%
%既然一个类型关系 $x : \tau$ 已经包含了程序部分 $x$，而类型关系是一个
%定理，那能否着重于类型关系作为一个定理本身，推导作为定理的类型关系而
%进行程序开发。即原本编写一段以 $a$ 对 $f$ 调用的程序是写下作为源程序
%的文本 $f(x)$，但现在能否从定理 $f : \sigma \rightarrow \tau$ 和
%定理 $a : \sigma$ 中演绎出定理 $f\ x : \tau$，而$:$左边的 $f\ x$ 
%就是得到的程序。
%
%
%
%程序具有的性质也是其抽象语义具有的性质，于是可以证明抽象语义的性质以
%证明程序的性质。
%再而本文围绕 Noesis 定理提出了 Noesis 形式系统，允许演绎而构建
%Noesis 定理，进而构建程序，并得到此程序的抽象语义，且此程序的抽象语义与
%程序的关联被定理保障。
%
%证明程序的抽象语义的性质
%
%
%
%
%
%
%
%
%
%
%
%即演绎定理以构建程序。
%
%Curry-Howard 同构下{\it 程序即是证明(proof as program)}的编程语言与定理证明工具抓住了要点。特别是 Coq，
%完美地实现了演绎定理以构建程序。
%
%只是 Coq、Agda、Idris、\Fsharp  等等基于构造演算的系统还是将思维停留在了盒子中，
%本文的贡献在于，在演绎定理以构建程序的思路下，{\bfseries 演绎以构建程序的定理，
%不需要是 $x : \tau$ 的形式，不需要是二元的类型关系}。Curry-Howard 同构自然
%只在类型系统中显现，但单纯为了构建程序而演绎的定理，不需要限制在类型关系，
%只需要定理中包含程序即可，{\bfseries 进而可以是呈现更多性质的扩广}，
%而在此扩广下也会有相应的 Curry-Howard 同构的扩广。
%
%%$x \widesim{i} \epsilon$，
%%其中 $x$ 是程序，$i$ 是各种不同的理解方式，$\epsilon$ 是在理解 $i$ 下程序 $x$ 的抽象
%%对应，抽象的意义。
%%
%

%本文提出概念 {\it 抽象语义} 与公理化逻辑 {\it Noesis 逻辑}，并基于此提出
%一种新的智能合约开发方法与工具 \Eamlh。

\begin{itemize}
\item 本文理论方面的工作主要有三点：
\begin{enumerate}
  \item 用于承载开发者逻辑信息与意图的{\it 抽象语义}。
  \item 抽象语义的公理化程序构造逻辑 {\it Noesis 逻辑}。
  \item 构建具有显式抽象语义的智能合约的方法。
\end{enumerate}
\item 本文在工程实践方面主要提供了智能合约开发工具 \Eamlh，作为本文理论的实现，它允许
  并要求
  开发者开发智能合约的同时完整地表达逻辑信息与意图于抽象语义中，允许开发者
  在 HOL 交互式定理证明器上使用抽象语义简化并完成对智能合约的分析与形式化验证，
  最后可以生成 EOS.IO 平台上可执行的智能合约。
    \Eamlh 使用 HOL 证明器为证明引擎，将 Noesis 逻辑实现在其上，\Eamlh 得出的所有
    结论包括程序与抽象语义的关联均是 HOL 证明器上被验证的定理，具有非常强的可信与严谨性。
\end{itemize}

本工作并非推理某段智能合约的某种语义，也不是构建一种分析
或者验证工具，本文的目的是设计并实现一种技术，
允许并要求用户在构建智能合约的同时，显式地将逻辑信息与意图表达于
本文提出的抽象语义中，以允许使用抽象语义简化后续的分析与验证。

这种智能合约构建方法并不是一种编程语言。\Eamlh 是一个交互式工具，
用户输入简短的指令操控 \Eamlh 演绎 Noesis 定理而构建智能合约，而并非将
智能合约代码书写为文本。附录 \ref{Ch.htDTtCP} 直观地举例介绍了演绎定理以
构造程序或智能合约的具体方法。
%演绎 Noesis 定理构建程序的方法，跟演绎
%被演绎的定理，是 Noesis 公理系统中的 Noesis 定理，描述一个
%值或一段程序在某个理解下的抽象语义。

\Eamlh 本身不进行任何定理证明，而是实现在
 HOL 定理证明器上，Noesis 逻辑被定义在 HOL 逻辑上，Noesis
定理是 HOL 上的定理，Noesis 定理的演绎亦是 HOL 证明器的定理的演绎。
\Eamlh 得出的一切结论都是 HOL 证明器证明出的定理，
\Eamlh 的缺陷只会影响命题能否被证明而不会影响定理的正确性，
因此是极其严谨的。

%
%
%
%
%
%因此值或程序的抽象语义是被
%验证的，且
%
%
%
%
%
%
%本文并不构建任何的证明工具，而是实现在已有的证明工具上。
%
%
%抽象语义是证明工具上易于分析的数学对象，
%
%
%
%
%
%
%
%
%
%
%与传统形式化方法不同，
%
%本文
%而是构造一种编程技术，使得用户通过这种
%编程技术可以构造具有明确抽象语义的，易于被形式化验证的程序。
%这套技术基于 HOL 交互式定理证明器完成，程序的抽象语义是定理证明器上易于分析的数学对象，
%用户可以之后形式化地分析验证这抽象语义来完成对整个程序的分析与验证。
\subsection{本文理论方面的工作} \label{Sec.works.theoritical}

本文首先提出抽象语义这一概念，一个值或一段过程的
抽象语义是一个易于分析的数学对象，且具有所关切的此值或此过程
所有的性质。

同一个值或过程在不同理解下可以具有不同抽象语义。例如
数值 2 在自然数理解下的抽象语义是自然数 2 而在布尔理解下
的抽象语义是{\it 真}。
值 1 与 2 在布尔理解下的抽象语义均是{\it 真}，
{\it 真}包含了这些值的所有关切的性质，
而数值 1 与 2 间的差异均被忽略。

%Noesis 定理具有形式 $x \widesim{i} \epsilon$ 其中
%
%
%
%
%一个程序的抽象语义，是一个数学对象，具有程序所拥有的，一切用户所关切的性质的数学对象，
%进而可以通过证明抽象语义的性质来证明程序的性质。
%
%一个程序的抽象语义由指令集与常量集确定，而
%指令集与常量集的抽象语义是 Noesis 逻辑上的公理，是被定义而非证明的。
%当指令与常量的抽象语义被正确定义为某个执行环境时，Noesis 定理即正确反映了程序
%在此执行环境上的抽象语义。
%
%
%
%
%当指令集
%
%
%
%
%
%
%
%
%
%
%例如 32 位加法指令 \texttt{i32.add} 的抽象语义定义为有限域 
%$\mathbb{F}_{2^{32}}$ 上的加法，常量 \texttt{1} 的抽象语义为
%$\mathbb{F}_{2^{32}}$ 中的 1，那么组合程序 \texttt{i32.add\ 1\ 1}
%的抽象语义自然就是 $1 + 1$。且这些抽象语义上的性质对应程序上的性质，
%于是由 $1 + 1$ 是偶数的证明亦是对组合程序 \texttt{i32.add\ 1\ 1} 会
%输出偶数的证明。对具象程序的分析变为对抽象数学对象的分析，
%形式化验证被有效地简化。

%，Curry-Howard 同构意味着可以演绎定理以构建程序。
%
%
%
%
%
%
%
%
%
%
%
%这种逻辑可以实现在经典逻辑中
%，或者说可以作为经典逻辑的子集。
%本文再而提出一种新的形式化方法，通过演绎 Noesis 形式系统上的
%Noesis 定理，来构建被验证的程序。
%
%本文提出的方法不是一种 Model check，它并不用于验证程序，
%它是用于构建被验证的程序。
%
%Curry-Howard 同构连接起程序世界与证明理论，一段程序同构于一段证明过程，
%程序的复合方法同构于演绎律，程序的复合同构于演绎律的复合。
%于是 Curry-Howard 同构意味着，可以演绎定理以构建程序。
%
%

继而本文提出一种新的公理系统，{\it Noesis 逻辑}，
主要包含描述值与其抽象语义间关联的
{\it Noesis 定理}，以及其他描述过程的抽象语义的定理。
Noesis 定理具有形式
%在本文，演绎以构建程序的定理，是程序到其抽象语义的对应关系，具有形式
$x \widesim{i} \epsilon$，
其中 $\widesim{\cdot}$ 是一个三元关系，$x$ 表示值%，名叫 {\it 现象}
，%({\it phenomenon, φαινόμενον})，
$i$ 表示理解方式叫做 {\it 理解}({\it understanding, nóēsis})，%, νόησῐς})，
$\epsilon$ 表示值 $x$ 在理解 $i$ 下的抽象语义，
%名叫 {\it 本体}({\it noumenon, νoούμενον})，
$\widesim{\cdot}$ 关系叫做{\it Noesis 对应}({\it Noesis correspondence})。
Noesis 对应替换传统编程语言中的类型关系；Noesis 逻辑替换类型系统；
Noesis 定理描述了值在某理解下具有某抽象语义，
类型定理（Typing）描述值具有某类型；
在 Noesis 逻辑中演绎 Noesis 定理得到新的 Noesis 对应关系，
在类型系统中演绎类型定理得到新的类型关系。
类型系统的演绎律决定了类型定理的推导与程序的组织方式，并允许
演绎类型定理以构建程序，图 \ref{fig:lambda-st-rule} 是简单类型 λ
演算的演绎律；Noesis 逻辑同样如此，图 \ref{fig:noesis-main-rule}
是 Noesis 逻辑的演绎律，同样决定了抽象语义的推导与程序的组织
方式，并同样允许演绎 Noesis 定理以构建程序。

\begin{figure}[t] \centering \renewcommand{\arraystretch}{2}
\begin{tabular}{c c}\multicolumn{2}{c}{
\AxiomC{$\ $} \RightLabel{(公理)}
\UnaryInfC{$\Gamma, x : \tau \vdash x : \tau$}
    \DisplayProof} \\
\AxiomC{$\Gamma \vdash M : \sigma \rightarrow \tau$}
\AxiomC{$\Gamma \vdash N : \sigma$} \RightLabel{(调用)}
  \BinaryInfC{$\Gamma \vdash M N : \tau$} \DisplayProof &
\AxiomC{$\Gamma, x : \sigma \vdash M : \tau$}\RightLabel{(抽象)}
\UnaryInfC{$\Gamma \vdash \lambda x. M : \sigma \rightarrow \tau$}
    \DisplayProof 
  \end{tabular}
    \caption{简单类型 λ 演算的演绎律} \label{fig:lambda-st-rule}
    \vspace{5mm}
 \renewcommand{\arraystretch}{2}
\begin{tabular}{c c}
  \multicolumn{2}{c}{
\AxiomC{} \RightLabel{(参数)} \UnaryInfC{
  $p \widesim{i} \epsilon \vdash p \widesim{i} \epsilon$}
\DisplayProof}\\
\AxiomC{$\Gamma,\ cond \vdash x \widesim{i} \epsilon $}
\RightLabel{(条件引入)} \UnaryInfC{$\Gamma \vdash 
x \proctr{i}{cond} \phi$} \DisplayProof &
\AxiomC{$\Gamma_1 \vdash cond$} 
\AxiomC{$\Gamma_2 \vdash x \proctr{i}{cond} \phi $}
\RightLabel{(条件削除)} \BinaryInfC{$\Gamma_1 \cup \Gamma_2
  \vdash x \widesim{i} \phi$} \DisplayProof\\
\AxiomC{$\Gamma_1 \vdash a \widesim{i} \epsilon$}
\AxiomC{$\Gamma_2 \vdash
  f \proctr{i|j|\cdots|k}{cond} \psi $} \RightLabel{(调用)}
\BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash
  f\ a \proctr{j|\cdots|k}{cond\ \epsilon} \psi\ \epsilon$}
    \DisplayProof &
\AxiomC{$\Gamma, a \widesim{i} \epsilon \vdash f \proctr{j|\cdots|k}
  {cond} \phi $} \RightLabel{(抽象)}
\UnaryInfC{$\Gamma \vdash \lambda a.\ f \proctr{i|j|\cdots|k}{\lambda
  \epsilon.\ cond} \lambda\epsilon.\ \psi$}
  \DisplayProof
\end{tabular}
  %\vspace{2mm}
\caption{ Noesis 逻辑主要的演绎律} \label{fig:noesis-main-rule}
\begin{tablenotes} \centering\footnotesize
\item 记号相关的演绎律没有被列出，Noesis 逻辑完整的演绎律参见
\ref{Sec.naive.noesis} 节与
\ref{Sec.noesishol} 节。
\end{tablenotes}
\end{figure}

%若将传统编程语言与本文对比，
%类型关系对应 Noesis 对应，类型系统对应 Noesis 逻辑。
%
%本文不再关注类型关系而是围绕 Noesis 对应，
%通过构造具有形式 $x \widesim{i} \epsilon$ 的定理以构建程序，
%无论是通过对已有定理的演绎还是从头证明。
%当然 $x$ 要有些别的要求，它们必须是一些可以
%看作是计算机处理器指令的特定函数的组合，以允许编译到这些指令上。

一个程序在不同的理解下可以有不同的抽象语义。
$\widesim{\cdot}$ 是一个三元关系，可以允许 $x$ 在 $i$ 解释下 
$x \widesim{i} \epsilon$ 的同时又在 $j$ 解释下 $x \widesim{j} \phi$。
这也意味着 Noesis 对应不是某种类型关系的变形，而是在根本上扩展了
类型关系。

抽象语义是定理证明器上任意的数学对象，是数学友好的并易于分析与证明的，
比如集合与数学映射。
Noesis 定理保障了程序实现与其抽象语义的对应，
之后用户可以证明抽象语义的性质以证明程序的性质，比如证明作为一个值的抽象语义的
自然数 $7$ 是质数以证明这个值表达一个质数，或者关于参数 $n$ 的程序的抽象语义
$2^n + 1$ 不总是质数以证明此程序并不总是输出质数。
分析抽象的数学对象，而不是面对一段具象的复杂的程序。

若将程序的设计也由此定理证明器上的形式语言描述为一种抽象的数学对象，
就与程序的抽象语义位于同一个形式语言的空间中，
那么证明程序的抽象语义与此设计的抽象表达的相等性，就能完整证明程序实现对于此设计的正确性。
而这种证明是相对容易的，因为程序的抽象语义是数学友好的，易于分析的。

%这有点像指称语义（Denotation Semantic），有相似的初衷，
%但实质的内容是完全不同的，不应被混淆。
%最大的区别在于，指称语义从来不尝试替代类型系统，不考虑构建程序，其
%找到的指称对应只是一种解释方式。
%指称语义既限制了不同理解的可能，
%它始终只围绕一种理解方式，又根本不精准，始终只是满足关系，而不是等价
%关系，这会疏漏很多的细节。

%Noesis 逻辑的灵感来源于形而上学(Metaphysics)的本体论(Ontolog)，在程序构成的世界中，
%直观可感受的现象值是数值与数值的计算，这些作为现象的数值背后的本体是计算所承载的
%抽象的理念（idea），该理念多数是由程序的编写者赋予。
%在程序的世界中，作为现象的计算的意义存在于理念的空间而无法被执行计算的计算机设备
%直接感受，计算设备直接感受到的只是作为现象的数值，故术语现象(phenomenon)与
%本体(noumenon)的使用是恰当的。而现象与本体直接的对应关系是通过程序的编写者，
%用户的智慧(nous)去理解的，词汇 noesis 意为智慧 nous 的行使，具有理解的意味，
%而 nous 是本体 noumenon 的词源，故 noesis 的使用也是恰当的。
%对现象 phenomenon 进行理解 noesis 的结果是本体 noumenon。
%
%可以用一些例子更细致地说明 Noesis 逻辑，以及具体如何演绎定理以构建程序。
%若已拥有定理 $x \widesim{i} \epsilon$ 表示值 $x$ 对应抽象语义 
%$\epsilon$，定理 $\forall a\ \phi.\ a \widesim{i} \phi \Rightarrow
%f(a) \widesim{i} g\ \phi$ 表示过程 $f$ 对应数学函数 $g$，
%于是自然地由肯定前件（Modus Ponens）推导出
%\[ f(x) \widesim{i} g\ \epsilon \]
%即过程调用 $f(x)$ 的抽象语义为 $g\ \epsilon$。此肯定前件律的应用是程序 $f(x)$ 的构建。
%用户的编程行为，既是通过程序操作抽象语义，也是通过编织抽象语义来构建程序。

%一个本体可以表现不同现象，这是自然的。
%而在本文的 Noesis 逻辑中，这一情形可以倒置过来，
%一个现象可以在不同的理解下对应
%到不同的本体，或者说不同的本体在不同理解下可以表达为同一个现象
%（现象的欺骗）。

最初的抽象语义来自基元指令与常量，最初的 Noesis 定理是 Noesis 逻辑的公理。
基元指令与常量的 Noesis 定理作为公理被引入，其抽象语义被设定以
定义并限制指令与常量的语义与用途，
并提供最初的可供用户组织以表达逻辑信息与意图的元语。
一切程序都是基元指令与常量的递归组合，一切抽象语义都是基元指令与常量的抽象语义的
递归组合。
基元指令与常量的抽象语义定义了基元指令与常量的语义与用途，
因此一切开发者通过递归组合基元指令与常量实现的程序逻辑与意图，都可以用
抽象语义表达，即抽象语义有能力表达一切可由程序实现的逻辑信息与意图。

%Neosis 系统的公理中的值与过程，构成了 Neosis 系统
%上的程序的常量集与指令集。
一个形式系统的所有定理都来自于其公理按其定义的演绎律的演绎。
而同样是一种形式系统的 Neosis 系统，在通过演绎律由公理构造定理的同时也
由常量集和指令集构造了程序，这些程序就是指令集和常量集的组合。
组合方式被 Noesis 逻辑中的演绎律确定，
调用律描述函数调用，而抽象律描述与函数构建。

于是 Noesis 逻辑的公理中的基元指令与常量构建了一台抽象机器，
而 Noesis 逻辑构建的程序就是此抽象机器上的程序。
对程序等价变化展开成基元指令与常量的表达即是编译。
令抽象机器的基元指令与常量的设定尽可能接近某个目标执行环境，
使这些基元指令与常量可以实现在此目标执行环境上，
于是程序的基元指令与常量表达就成为了一种中间表达
（Intermediate Representation, IR）。由基元指令与常量到目标指令集的
映射，就能将中间表达编译到目标执行环境。

Agda、Idris 等具有依赖类型系统的语言使用类型表述程序的性质，
即 $x : P$，$P$ 既是类型又是性质，而程序必须兼任证明，必须一人分饰两角，
这些批评前面已经讨论了。

而本文的情况是，先在某种解释或某种解释的同构下证明程序$x$对应于
抽象$\epsilon$，再证明抽象 $\epsilon$ 满足某个性质 $Q$ 
以证明程序 $x$ 具有此性质 $Q$。例如可以证明加法过程的抽象语义
$(+)$ 属于 $\mathrm{Even} \rightarrow \mathrm{Even} \rightarrow 
\mathrm{Even}$ 或者 
$\mathrm{Odd} \rightarrow \mathrm{Odd} \rightarrow \mathrm{Odd}$
进而证明此过程也具有此性质。
于是过程的实现，只要专注于工程性能即可，任意性质的证明只发生在其
抽象对应上，是在抽象的领域内完成的，抽象和工程的两个世界不会相互干扰。
于是在得到很好执行性能的编译结果的同时，对其性质的证明依旧容易。

%
%但更严谨地论述，这套构建程序的新方法中并没有
%类型系统，虽然这些程序也基于 λ 演算，但跟 λ 演算的类型系统关联并不大。
%这似乎是种新理所当然的对应，一个描述程序 Noesis 对应关系
%的定理自然包含那个程序，于是演绎与证明这种定理自然也就在构造其中的程序。
%

%Curry-Howard 同构连接起了程序与证明，并暗含了演绎定理以构建程序的可能性。
%本文的新思路应与 Curry-Howard 同构有某种联系。
%一方面，Coq 证明工具受 Curry-Howard 同构的启发，从程序走向证明。本文似是相反的，
%演绎或者证明定理以构建程序。
%另一方面 Curry-Howard 同构是针对于类型系统，但本文提出的 Noesis 逻辑是
%类型系统的严格扩广，这暗示着也许也存在对应的 Curry-Howard 同构的扩广。
%特别是， Noesis 对应在一些特例下退化为类型关系，令冒号 $:$ 为一种程序
%到定理的理解，而 $\mathrm{Abs}$ 同构于 $\rightarrow$
%\[ \mathrm{Abs} \proctr{:|:|:}{\K \K \T}
%(\lambda x\ y.\ x \rightarrow y) \]
%这再次揭示 Noesis 对应是类型关系的扩广。而此时
%以 $:$ 为理解的 Noesis 对应也显式出了 Curry-Howard 同构，程序成为证明
%而抽象语义既是类型又是命题或者定理。既然 Noesis 对应是类型关系的扩广，那似乎暗示着 
%Curry-Howard 同构也应存在着某种扩广，也许是沟通起程序与建构主义式的
%抽象构造的桥梁。
%似乎显然的一点是，一切被建构的构造，都有一个程序对应。%，数学是，证明是，
%%一块布丁也是。

\subsection{实践本文理论的软件工具 \Eamlh} \label{Sec.works.eng}

本文设计并实现了工具 \Eamlh 以允许用户
在实际的工业生产中使用上一节介绍的 Noesis 理论，通过演绎 Noesis 定理
来构建具有明确抽象语义的智能合约。
\Eamlh 构建在 HOL 定理证明器上，并提供给用户接口，允许用户输入 HOL 证明器的
证明策略完成对程序的抽象语义的最终证明。
图 \ref{fig:total-frame} 是软件 \Eamlh 的架构，由4部分组成：HOL 定理证明器上的 Noesis
理论、生产目标执行环境机器代码的编译后端、连接编译后端与定理证明器的中间层编辑壳层、
最终与用户交互的编辑前端。

\begin{figure}[h] 
  \centering \begin{tikzpicture}\useasboundingbox (-5,-5) rectangle (5,5);
\baselineskip=0.5cm
    \draw (0,0) node (O) {编辑壳层} circle [radius=1.2];
  \path[name path=vCbarD] (60:3.3) -- ([turn]-90:1.5);
  \path[name path=vCbarU] (60:3.3) -- ([turn]90:1.5);
  \path[name path=hCbarD] (15:1.5) -- ([turn]45:4);
  \path[name path=hCbarU] (105:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vCbarD and hCbarD, by=x}] 
  (60:1.5) arc [start angle=60, end angle=15, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vCbarU and hCbarU, by=x}]
  (60:1.5) arc [start angle=60, end angle=105, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (60:2.4) node {编译\\后端};
  \draw (60:4) node[dart,draw,minimum size=1cm, shape border rotate=60,
    shape border uses incircle,fill=white] (B) {编译};
  \draw [->] (65:0.9) -- ([turn]-5:0.8);
  \draw [<-] (55:0.9) -- ([turn]5:0.8);

  \path[name path=vbarD] (-60:3.7) -- ([turn]-90:1.5);
  \path[name path=vbarU] (-60:3.7) -- ([turn]90:1.5);
  \path[name path=hbarD] (-105:1.5) -- ([turn]45:4);
  \path[name path=hbarU] (-15:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vbarD and hbarD, by=x}] 
  (-60:1.5) arc [start angle=-60, end angle=-105, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vbarU and hbarU, by=x}]
  (-60:1.5) arc [start angle=-60, end angle=-15, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (-60:2.5) node {HOL\\证明器};
  \draw [fill=white] (-60:4.6) +(-60:1.3) -- +(-150:1.3) -- +(120:1.3) -- + (30:1.3) -- +(-60:1.3);
  \draw (-60:4.6) node [align=center] (A) {Noesis\\理论};
  \draw [->] (-55:0.9) -- ([turn]-5:0.8);
  \draw [<-] (-65:0.9) -- ([turn]5:0.8);
  \path[name path=Vbar] (-4,1.2) -- (-4,-1.2);
  \path[name path=Dhbar] (-135:1.5) -- +(-3,0);
  \path[name path=Uhbar] (135:1.5) -- +(-3,0);
  \draw [name intersections={of=Vbar and Uhbar, by=x}] 
  (-1.5,0) arc [start angle=180, end angle=135, radius=1.5] -- (x) -- (-4,0);
  \draw [name intersections={of=Vbar and Dhbar, by=x}]
  (-1.5,0) arc [start angle=180, end angle=225, radius=1.5] -- (x) -- (-4,0);
  \draw [align=center] (-2.8,0) node {编辑器\\前端};
  \draw [<-] (175:1) -- +(-0.8,0);
  \draw [->] (-175:1) -- +(-0.8,0);
  \draw (-4.4,0) node[left] {用户};
  \draw [<-] (175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  \draw [->] (-175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  %\path (B) ([turn]-90:2) node (BX) {};
  %\draw [->,thick,rounded corners=1cm] (A) ([turn]90:1.8) -- (0:1.8) -- (BX);
\end{tikzpicture}
\caption{工具 \Eamlh 的整体框架} \label{fig:total-frame}
\end{figure}

本工作使用 HOL 交互式定理证明工具作为定理推理引擎，其详细介绍在 \ref{Sec.ITP} 节。

首先在 HOL 定理证明工具上构造一系列定义、谓词、定理以及证明策略，将
Noesis 逻辑实现在 HOL 交互式定理证明器的证明系统中，进而可以使用 HOL 逻辑
表述值、理解、抽象语义。其中值与理解将被特别地定义，而
抽象语义就是 HOL 逻辑中任意的数学对象(mathematical object)，
例如数学映射、集合、有限域。于是可以有效且自然地证明抽象语义的任意性质，
因为抽象语义就是 HOL 逻辑上自然存在的数理对象。

Noesis 对应成为 HOL 定理证明工具上的定理，演绎 Noesis 定理就是演绎 HOL 的定理。
关于定理演绎的一切数学操作都由 HOL 定理证明器完成，这些演绎的正确性，即定理推导的正确性，
皆由 HOL 定理证明器保障。

因此 \Eamlh 的工程实现是缺陷免疫的。任何实现上的缺陷只会导致智能合约构建的失败，
但任何构建出的智能合约的抽象语义必定是正确的，
因为智能合约的抽象语义来自 Noesis 定理，Noesis 定理是 HOL 定理证明器上的定理。
\Eamlh 本身不验证定理而是操作 HOL 证明器证明定理，
抽象语义的正确性严格等于 HOL 定理证明器的正确性，
与 \Eamlh 具体的工程实现无关，
即便 \Eamlh 中存在缺陷，也不影响抽象语义的正确性。
\Eamlh 继承了 HOL 证明器的严谨，
HOL 定理证明器满足 de Bruijn 标准，
因此 \Eamlh 也同样满足 de Bruijn 标准，
在 \ref{Sec.deBruijn} 节中有详细的讨论。

%实现在 HOL 证明器上的 Noesis 逻辑叫做 \noesishol，结合常量与基元指令设定后构成的
%抽象机器叫做 \amlh。
%\lamcr 是 Noesis 的古希腊文词源 νόησις 的动词原型，意为去理解、去思考。
%图 \ref{fig:noe-sys-relas} 比较了 Noesis 逻辑、\noesishol、\amlh 与
%\amlh 上的程序。

用户无需直接操作定理证明器，交互式的编辑器前端与编辑壳层将定理证明器封装，提供给用户
统一的易于操作的接口。

编译方面分为两步。首先操纵 HOL 证明器对 \amlh 上的程序等价变换展开成基元指令与常量
的表达，且此变换是由 HOL 证明器保障的，是被形式化验证的。
而后程序的基元指令与常量表达作为一种中间表达（Intermediate Representation, IR），
以文本的形式由 HOL 证明器输出，编辑壳层将其输入编译后端，最终生成目标执行平台上可执行的
智能合约。编译后端的编译加工发生在形式化验证之外，是可能有错误的。
但如前所述，\amlh 的基元指令集与常量被设定的非常接近目标执行环境，以至于编译后端的工作
尽可能的简单，几乎就是 IR 文本到机器代码的映射，以至于潜在编译缺陷尽可能的非常少。
且编译后端作为一个程序是固定的，可以后续对其形式化验证以将形式化验证的范围扩展。
总之，本工作的形式化验证的保障范围是 IR 级别的，可以保障智能合约到 IR 级别的正确性。

\begin{figure}[h] 
  \centering \begin{tikzpicture} \baselineskip=0.5cm
    \draw (0,0) node (O) {编辑壳层} circle [radius=1.2];
  \path[name path=vCbarXD] (60:3.3) -- ([turn]-90:1.5);
  \path[name path=vCbarXU] (60:3.3) -- ([turn]90:1.5);
  \path[name path=hCbarXD] (15:1.5) -- ([turn]45:4);
  \path[name path=hCbarXU] (105:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vCbarXD and hCbarXD, by=x}] 
  (60:1.5) arc [start angle=60, end angle=15, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vCbarXU and hCbarXU, by=x}]
  (60:1.5) arc [start angle=60, end angle=105, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (60:2.4) node {编译\\后端};
  \draw (60:4) node[dart,draw,minimum size=1cm, shape border rotate=60,
    shape border uses incircle,fill=white] (B) {编译};
  \draw [->] (65:0.9) -- ([turn]-5:0.8);
  \draw [<-] (55:0.9) -- ([turn]5:0.8);

  \path[name path=vbarXD] (-60:3.7) -- ([turn]-90:1.5);
  \path[name path=vbarXU] (-60:3.7) -- ([turn]90:1.5);
  \path[name path=hbarXD] (-105:1.5) -- ([turn]45:4);
  \path[name path=hbarXU] (-15:1.5) -- ([turn]-45:4);
  \draw [name intersections={of=vbarXD and hbarXD, by=x}] 
  (-60:1.5) arc [start angle=-60, end angle=-105, radius=1.5] -- (x) -- ([turn]90:1.5);
  \draw [name intersections={of=vbarXU and hbarXU, by=x}]
  (-60:1.5) arc [start angle=-60, end angle=-15, radius=1.5] -- (x) -- ([turn]-90:1.5);
  \draw [align=center] (-60:2.5) node {HOL\\证明器};
  \draw [fill=white] (-60:4.6) +(-60:1.3) -- +(-150:1.3) -- +(120:1.3) -- + (30:1.3) -- +(-60:1.3);
  \draw (-60:4.6) node [align=center] (A) {Noesis\\理论};
  \draw [->] (-55:0.9) -- ([turn]-5:0.8);
  \draw [<-] (-65:0.9) -- ([turn]5:0.8);
  \path[name path=VbarX] (-4,1.2) -- (-4,-1.2);
  \path[name path=DhbarX] (-135:1.5) -- +(-3,0);
  \path[name path=UhbarX] (135:1.5) -- +(-3,0);
  \draw [name intersections={of=VbarX and UhbarX, by=x}] 
  (-1.5,0) arc [start angle=180, end angle=135, radius=1.5] -- (x) -- (-4,0);
  \draw [name intersections={of=VbarX and DhbarX, by=x}]
  (-1.5,0) arc [start angle=180, end angle=225, radius=1.5] -- (x) -- (-4,0);
  \draw [align=center] (-2.8,0) node {编辑器\\前端};
  \draw [<-] (175:1) -- +(-0.8,0);
  \draw [->] (-175:1) -- +(-0.8,0);
  \draw (-4.4,0) node[left] {用户};
  \draw [<-] (175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  \draw [->] (-175:1) ++ (-2.7cm,0) -- +(-0.6,0);
  \path (B) ([turn]-90:2) node (BX) {};
  \draw [->,thick,rounded corners=1cm] (A) ([turn]90:1.8) -- (0:1.8) -- (BX);
\draw [align=center] (A) ([turn]90:2) node[right]{等价变换\\展开成基元指令\\与常量的表达};
    \draw [align=center] (2.7,0) node[right] {得到中间表达};
    \draw [align=center] (BX) node[right] {编译中间表达\\至目标执行环境};
\end{tikzpicture}
\caption{编译流程示意} \label{fig:compilation}
\end{figure}

此外还有很多问题值得讨论：既然是演绎定理来构建智能合约，就不应将源代码
写在纸上或者文本编辑器里，文本形式的源代码自然应当被抛弃，而定理与数理逻辑
对象才是 \amlh 上程序的源代码。本文设计了 {\it 编辑壳层}
以允许用户交互式地演绎定理、操作数学对象，以构造智能合约。
既然是演绎定理来构建智能合约，就不应
基于源代码分析而为用户提供编程辅助与支持，编程辅助与支持变成
在定理证明器上构造的一系列证明策略与分析工具，在数理范畴内
能发挥更多的功能。由下层定理证明器对 \amlh 上程序
进行符号分析以允许对程序进行模拟执行，时间、开销、并行模型与资源都可以
考虑进来。

%诸如此类，非常多令人振奋的新视角新方法将在接下来慢慢论述。

\section{章节安排}

\begin{itemize}[leftmargin=1.5cm]
\item[第 \ref{Ch.intro} 章] 概括性地介绍本文工作。
  \item[第 \ref{Ch.ReqTh} 章] 进行混淆区分、记号定义、与必要的理论介绍，包括 HOL 交互式定理证明器
的介绍。
\item[第 \ref{Ch.Noesis} 章] 细致地论述本文提出的 Noesis 逻辑，以及其在 HOL 逻辑上的实现。
\item[第 \ref{Ch.AmLH} 章] 论述使用 Noesis 逻辑进行智能合约开发的技术。
\item[第 \ref{Ch.Implementation} 章] 论述智能合约生成工具 \Eamlh，具体如何
  编译生成可运行于 EOS.IO 等智能合约平台的WASM 格式的智能合约。
%本文工作在智能合约场景上的实现，包括用于智能合约
%的抽象机器 \amlhS 的定义与实现，\amlhS 上程序的编译方法。这一章给出了一种实际可行的
%构造正确性被证明的智能合约的方案，并最终能编译出可运行于 EOS.IO 等智能合约平台的
%WASM 格式的智能合约。
\item[第 \ref{Ch.conclusion} 章] 总结本文工作，与其他现有方案比较，特别是与依赖类型系统
  比较。
%\item[附录 \ref{Ch.lambda}] 包括了 λ 演算粗浅的介绍与定义。
\item[附录 \ref{Ch.ES}] 详细论述编辑壳层，因内容过多且与 Noesis 逻辑相对无关故置于附录。
  仅给感兴趣的读者，可以选择性阅读或跳过。
\item[附录 \ref{Ch.example.transfer}] 是第 \ref{Ch.Implementation} 章的扩充，
  作为对工具 \Eamlh 的实验，
给出了一段相对完整的代币合约的转账部分在 \Eamlh 上具体的构建过程与编译，
    以及编译结果的 WASM。因内容过于细致放于附录。
\end{itemize}

本文实现的工具 \Eamlh 的 Noesis 理论部分是第 \ref{Ch.Noesis} 章与第 \ref{Ch.AmLH} 章讨论
的 Noesis 逻辑在 HOL 上的实现；
编辑壳层部分在附录 \ref{Ch.ES} 中过分细致地论述；编译后端目前可以生产 EOS.IO 平台的智能合约，
在第 \ref{Ch.Implementation} 章具体论述编译的实现；最后的编辑前端在目前的实现中非常简陋，仅
提供命令行界面，故不在本文中细致论述。
