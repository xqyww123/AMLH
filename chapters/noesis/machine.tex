
\section{常量、基元指令、理解的引入方法} \label{Sec.op-const-noesis.def}

常量、基元指令、理解均有两种引入方法：第一种是给出具体的计算表达式来定义，
即基元指令作为一个值的函数，具体地给出值的计算过程；常量作为一个值，具体地给出值的数值；
理解作为定义 \ref{Def.itp} 中的4元组，给出各个映射与集合具体的表达。
例如32位加法 \texttt{i32.add}的定义
\[ \texttt{i32.add}\ a\ b = a + b \Mod 2^{32} \]
另一种定义方法分别是，常量定理，基元指令虚构，理解虚构。
三者均不需要给出具体的表达，只是由所期望的抽象语义，证明必定存在这样的常量、基元指令、
理解满足所期望的抽象语义，进而引入。

\begin{theo}[常量定理] \label{T.Vconst}
  常量的虚构可以通过理解 $i$ 的 $\mathbf{Li}_i$ 完成
\[ \forall i\ e.\ \mathbf{V}_i\ \land\ e \in \mathbf{Se}_i
\Rightarrow \mathbf{Li}_i\ e \widesim{i} e \]
给定一个合法的理解 $i$ 与理念中的抽象语义 $e$，$\mathbf{Li}_i\ e$ 是
Noesis 对应到抽象语义 $e$ 的{\phew}。
\vspace{-4mm}
\begin{prooftree}
\AxiomC{$\Gamma_1 \vdash \mathbf{V}_i$}
\AxiomC{$\Gamma_2 \vdash e \in \mathbf{Se}_i$}
\RightLabel{(常量律)} \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash
\mathbf{Li}_i\ e \widesim{i} e$}
\end{prooftree}

\begin{proof} 
Noesis 对应的定义 \ref{Def.TR}
\[ p \widesim{i} e = \mathbf{V}_i \land p \in \mathbf{Sp}_i \land (\mathbf{Tr}_i\ e = p) \]
有效理解的定义 \ref{Def.Vi}，有
\[ \mathbf{V}_i \Rightarrow (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \in
    \mathbf{Sp}_i \land (\mathbf{Tr}_i(\mathbf{Li}_i\ e) = e))\]
    于是
\[\mathbf{V}_i \Rightarrow (\forall e.\ e \in \mathbf{Se}_i \Rightarrow \mathbf{Li}_i\ e \widesim{i} e)\]
命题得证。

\end{proof}
\end{theo}

%基元指令的第一种基于{\phew}的定义方法 \ref{Def.phenomenon}，
%具体地给出{\phew}上函数的定义，再由 Noesis 对应的定义 \ref{Def.TR} 证明此函数满足某个或某些
% Noesis 对应同构，
给出具体定义的{\phew}函数可以在不同的理解下具有多个 Noesis 对应同构。
%，于是由此可以定义具有多个抽象语义或者说是多个意义的函数。
例如在{\phew}上完整定义的加法函数，既可以 Noesis 同构到
自然数区间的加法，也可以是有限域的加法。

虚构基元指令方法则不需要明确定义，而是
%第二种是根据预先期望的 Noesis 对应同构，不给出明确的定义，而是
构造一个存在性命题，证明必定存在一个{\phew}函数满足此同构，
进而由此引入。%这一方式叫做 {\it 虚构引入}。
可以证明对于任意的 Noesis 对应同构，只要满足一些很宽松的条件，
就一定存在一个{\phew}函数满足此对应同构。
进而虚构的基元指令不需要具体地描述计算过程，可以根据意义直接引入，
%也根本不需要关注计算内容，
且只要得到了 Noesis 对应同构定理，就可以直接由组合律去应用。
%这点得益于基元指令 Noesis 同构的公理性，程序是不需要关注基元指令如何实现
%的，程序只要组合基元指令。

\begin{theo}[基元虚构定理]
给定所期望的抽象语义$f_e$，参数的理解$i\ \cdots\ k$，返回值的理解$l$，过程执行的条件$cond$，
只要 $l$ 有效，且 $cond$ 足以限定返回值的抽象语义 $f_e\ a_e\ \cdots\ c_e$到其理解$l$的抽象语义集
$\mathbf{Se}_l$内，则必定存在一个{\phew}上的过程 $f_p$，且满足期望的
Noesis 对应同构。
\[ \begin{split} \forall f_e\ i\ \cdots\ k\ l\ cond.\ 
 \mathbf{V}_l\ \land\ &\\
    (\forall a_e\ \cdots\ c_e.\ \mathbf{V}_i\ & \land a_e \in \mathbf{Se}_i \land \cdots
\land \mathbf{V}_k \land c_e \in \mathbf{Se}_k \land cond\ a_e\ \cdots\ c_e\ \Rightarrow\\
    & f\ a_e\ \cdots\ c_e \in \mathbf{Se}_l) \Rightarrow\\
    & \exists f_p.\ f_p \proctr{i|\cdots|k|l}{cond} f_e
\end{split} \]
\begin{proof} 此定理在没有参数时的特例，常量虚构定理
\[ \forall i\ e.\ \mathbf{V}_i \Rightarrow e \in \mathbf{Se}_i \Rightarrow
  \exists p.\ p \widesim{i} e \]
由常量定理 \ref{T.Vconst} 直接得到。

令 $x_e = f_e\ a_e\ \cdots\ c_e$，

$P_{cond} = (\forall a_e\ \cdots\ c_e.\ \mathbf{V}_i\ \land a_e \in 
\mathbf{Se}_i \land \cdots
\land \mathbf{V}_k \land c_e \in \mathbf{Se}_k \land cond\ a_e\ \cdots\ c_e\ \Rightarrow
    f\ a_e\ \cdots\ c_e \in \mathbf{Se}_l)$，

$\Gamma_\sim = \{a_p \widesim{i} a_e,\ \cdots\ ,\ c_p \widesim{k} c_e,\ cond\ x_e,\ 
\mathbf{V}_l,\ P_{cond} \}$

\begin{prooftree}
\AxiomC{$\Gamma_\sim \vdash P_{cond}$}
\AxiomC{$a_p \widesim{i} a_e \vdash \mathbf{V}_i \land a_e \in \mathbf{Se}_i$}
\AxiomC{$\cdots$}
\AxiomC{$c_p \widesim{i} c_e \vdash \mathbf{V}_i \land c_e \in \mathbf{Se}_i$}
\QuaternaryInfC{$\Gamma_\sim \vdash x_e \in \mathbf{Se}_l \land \mathbf{V}_l$}
\RightLabel{(常量虚构定理)}
\UnaryInfC{$\Gamma_\sim \vdash \exists p.\ p \widesim{i} x_e$}
\UnaryInfC{$\Gamma_\sim \vdash \exists f_p.\ f_p\ a_p\ \cdots\ c_p \widesim{i} f_e\ a_e\ \cdots c_e$}
\UnaryInfC{$\mathbf{V}_l,\ P_{cond} \vdash \exists f_p.\ 
    f_p \proctr{i|\cdots|k|l}{cond} f_e$}
\UnaryInfC{$\forall f_e\ i\ \cdots\ k\ l\ cond.\ 
\mathbf{V}_l\ \land\ P_{cond} \Rightarrow 
    \exists f_p.\ f_p \proctr{i|\cdots|k|l}{cond} f_e$}
\end{prooftree}
\end{proof}
\end{theo}

虚构基元的条件，是非常宽松的，下面的定理说明这一点。

\begin{theo}[Noesis 对应同构的条件的充分性]  \label{T.ptr.enough}
\[ \begin{split}
\forall f_p\ i\ &\cdots\ k\ l\ cond\ f_e.\ f_p \proctr{i|\cdots|k|l}{cond} f_e 
\Rightarrow\\ & \forall a_e\cdots c_e.\ \mathbf{V}_i \land a_e \in \mathbf{Se}_i
    \land \cdots \land \mathbf{V}_k \land c_e \in \mathbf{Se}_k \land
    cond\ a_e\ \cdots\ c_e \Rightarrow \\
    & \quad\quad\quad\quad \mathbf{V}_l \ \land\  f_e\ a_e\ \cdots\ c_e \in \mathbf{Se}_l
\end{split} \]
\end{theo}
\begin{proof}
\[\begin{split} f_p \proctr{i|\cdots|k|l}{cond} f_e = (\forall &a_e\ a_p\ \cdots c_e\ c_p.\
    a_p \widesim{i} a_e \ \Rightarrow \cdots \Rightarrow c_p \widesim{i} c_e \Rightarrow\\
    & cond\ a_e\cdots\ c_e \Rightarrow f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ 
c_e) \end{split} \tag{1} \]
令 $a_p = \mathbf{Li}_i\ a_e,\ \cdots,\ c_p = \mathbf{Li}_k\ c_e$，
由定义\ref{Def.TR}在前提 $\mathbf{V}_i \land a_e \in \mathbf{Se}_i
    \land \cdots \land \mathbf{V}_k \land c_e \in \mathbf{Se}_k$ 下有
    \[ a_p \widesim{i} a_e \land \cdots \land c_p \widesim{k} c_e \]
带入(1)并结合前提$cond\ a_e\cdots\ c_e$ 得到
    \[ f_p\ a_p\ \cdots\ c_p \widesim{l} f_e\ a_e\ \cdots\ c_e \]
由定义\ref{Def.TR}
    \[ \mathbf{V}_l \ \land\ f_e\ a_e\ \cdots\ c_e \in \mathbf{Se}_l \]
\end{proof}

最后理解也可以被类似地虚构地引入，而完全不给出任何具体的细节。
这一点是通过同构实现的。

\begin{defin}[单射的定义] \label{Def.INJ}
\[
    \mathbf{INJ}\ f\ S\ T \coloneqq (\forall s.\ s \in S \Rightarrow f\ s \in T) \land
    (\forall s_1\ s_2.\ s_1 \in S \land s_2 \in S \land (f\ s_1 = f\ s_2) \Rightarrow
    s_1 = s_2)
\]
\end{defin}
\begin{lemma}[单射存在逆函数] \label{L.inji}
\[ \forall f\ S\ T.\ \mathbf{INJ}\ f\ S\ T \Rightarrow \exists g.\ (\forall t.\ t \in T
    \Rightarrow g\ t \in S) \ \land\ (\forall s.\ s \in S \Rightarrow
    g(f(s)) = s) \]
\end{lemma}
\begin{defin}[势的偏序关系的定义] \label{Def.Card}
    \[ \abs{A} \leq \abs{B} \coloneqq (\exists f.\ \mathbf{INJ}\ f\ A\ B) \]
\end{defin}

\begin{theo}[理解虚构定理]
\[ \forall S_e. \abs{S_e} \leq \abs{\mathrm{phenomenon}} \Rightarrow
    \exists i.\ \mathbf{V}_i\ \land\ (\mathbf{Se}_i = S_e) \]
\end{theo}
\begin{proof}
在假设 $\abs{S_e} \leq \abs{\mathrm{phenomenon}} $ 下，由定义 \ref{Def.Card} 得到
由$S_e$到{\phew}的单射$f$，再由引理$\ref{L.inji}$得到逆函数$g$，记单射$f$的值域为
$S_p = \{f(a)\mbar a \in S_e \}$，有：
\[ \forall e.\ e \in S_e \Rightarrow f\ e \in S_p \land g(f\ e) = e  \tag{1} \]
\[ \forall p.\ p \in S_p \Rightarrow g\ e \in S_e \tag{2} \]
令 $i = \mathbf{Interpretation}\ f\ g\ S_e\ S_p$ 现只需证明 $\mathbf{V}_i$ 即可。
\[ \mathbf{V}_i = (\forall e.\ e \in S_e \Rightarrow f\ e \in S_p \land
    f(g(e)) = e)\ \land\ (\forall p.\ p \in S_p \Rightarrow g\ p \in S_e) \]
由(1)，(2) 这是显然的。
\end{proof}

一般而言$\amlh$的实现中{\phew}集同构于自然数集的一阶无穷，这就给$S_e$的选择带来很大的空间。
事实上任何计算机实际可触及的意义，或者说计算机上可表示的概念，一定是有限的，因为计算机的
内存是有限的，于是$S_e$是有限的；即便抛开内存的限制，需要去表示的概念也往往是一阶无穷。
这些一阶无穷集包括一阶无穷集上的列表、树结构、映射表等多种数据结构。

借助理解虚构定理，可以直接引入到期望本质集上的理解。尽管不给出理解的具体映射方式意味着
不可能直接证明某个{\phew}在该理解下的 Noesis 对应，但依旧可以通过虚构基元指令
与虚构常量的方式引入关于此虚构理解的基元指令。

至此，抽象机 \amlh 论述完成。
%它基于 \noesishol 系统，主要加入了
%基元指令与常量的引入方法。基元指令、常量、理解均可以用两种方式引入。
%
%第一种方法给出具体的包括完整的对{\phew}的计算的定义，根据定义证明其具有
% Noesis 同构、Noesis 对应、或者是合法的理解。一个{\phew}或{\phew}过程可能
% 在多种理解下有多种 Noesis 对应或同构，即有多个抽象语义对应。
%
%对于复杂的结构与过程第一种方法可能是困难的，
%第二种方法使用虚构基元指令、
%虚构常量、虚构理解，在给定的期望的 Noesis 同构、Noesis 对应、理解的
%抽象语义集下，证明及其简单与基本的几个条件，就可以虚构得到这些定理。
%虚构得到的基元指令、常量、理解只能拥有其虚构中给出的确定的一种
%Noesis 同构、Noesis 对应与抽象语义集，虽然不能有多重对应，但非常简单易用。
%
%虚构的基元指令、常量、理解不需要给出具体的实现，因为它们是作为公理式的。
%虚构的基元指令作为指令集中的指令，是由执行环境直接执行的，不需要实现的。
%
