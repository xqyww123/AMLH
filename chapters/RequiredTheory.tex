\chapter{必要的理论基础与工程工具介绍} \label{Ch.ReqTh}

\input{./chapters/Attention.tex}
\input{./chapters/RequiredTheory/theories.tex}

\section{定理证明工具} \label{Sec.ITP}

定理证明工具（Theorem Prover）是一个发展已久的领域，有众多优秀的成果
\cite{nawaz2019survey}。
著名的工具包括 HOL 系列，Coq\cite{coq.itp}，PVS\cite{pvs.itp}，Twelf\cite{twelf.itp}，
ACL2\cite{acl2.itp}，Isabelle/HOL\cite{isabelle.itp}。
其中 HOL 系列起源于 1972年 Robin Milner 的 LCF 程序\cite{milner1972logic}，
经过近半个世纪的发展已经演化出诸多版本与分支，HOL Light\cite{hol.light.itp}，
HOL4\cite{hol4.itp} 等是其中的佼佼者。

本工作使用 HOL4 作为定理证明器。

HOL4 是一种交互式定理证明工具，基于用户决定的证明策略进行半自动证明。而数学上已知不存在一个确定的算法解决任意的问题，故而不可能有
完全自动的证明工具，故而必须通过半自动的方式届由用户决定的策略完成证明。

\subsection{de Burijn 标准} \label{Sec.deBruijn}

机器证明领域一个重要的问题是，“如何相信一个定理证明器得出的结论是正确的”，机器证明的正确性。
即所谓 \textit{de Burijn criterion} （de Burijn 标准），若一个定理证明器的结果，
可以被一个独立的简单的方式验证，例如经由一个小的程序或是人工的手算，
那么此定理证明器满足 de Burijn 标准 \cite{barendregt2002autarkic,nawaz2019survey}。

HOL系列以及其中的 HOL4 是满足 de Burijn 标准的\cite{nawaz2019survey}。
HOL 系列内部使用一个微小的“核”（kernel）程序，决定了基元推理过程，
即证明系统的演绎律的程序实现。而一切推理过程都是基元推理
的复合，一如证明系统的证明是演绎律的复合。
于是所有的推理都经由这个微小的核，
复制核程序或者人工模拟核的运算就可以独立验证任何定理证明器得出的结论。

\subsection{HOL 逻辑概述} \label{Sec.HOL}

HOL 逻辑是 HOL 定理证明器上的证明系统，其详细定义比较复杂，可以
参见 HOL 系统描述\cite{norrish2019hol}。
$x : t$ 为类型标记，表达式 $x$ 具有类型 $t$。一般可以省略类型标记。
HOL 逻辑上的演绎律很多，以下是本文需要使用的部分。

\vspace{\baselineskip}
{\centering\begin{tabular}{c c}
    \AxiomC{$ \Gamma_1 \vdash t_1 \Rightarrow t_2 $}
    \AxiomC{$\Gamma_2 \vdash t_1 $}
    \RightLabel{(MP)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash t_2$} \DisplayProof&
    %\AxiomC{$ \Gamma_1 \vdash t_1 = t_2 $}
    %\AxiomC{$\Gamma_2 \vdash t_1 $}
    %\RightLabel{(EQ\_MP)}
    %\BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash t_2$} \DisplayProof
    \AxiomC{$ \Gamma \vdash t $}
    \RightLabel{(DISCH $u$)}
    \UnaryInfC{$\Gamma - \{u\} \vdash u \Rightarrow t$} \DisplayProof
\end{tabular}

\vspace{\baselineskip}\begin{tabular}{c c}
    \AxiomC{$ \Gamma_1 \vdash \forall x_1\cdots x_n.\ t_1 \Rightarrow t_2 $}
    \AxiomC{$\Gamma_2 \vdash t_1 $}
    \RightLabel{(MATCH\_MP)}
    \BinaryInfC{$\Gamma_1 \cup \Gamma_2 \vdash \forall x_a\cdots x_k.\ t_2$} 
    \DisplayProof&
    \AxiomC{$\ $} \RightLabel{(ASSUME)}
    \UnaryInfC{$ t \vdash t$} \DisplayProof
  \end{tabular}

\vspace{\baselineskip} \begin{tabular}{c c c}
    \AxiomC{$ \Gamma \vdash t $}
    \RightLabel{(GEN $x$)}
    \UnaryInfC{$\Gamma \vdash \forall x.\ t$} \DisplayProof&
    \AxiomC{$ \Gamma \vdash A\ \land\ B $}
    \RightLabel{(CONJUNCT1)}
    \UnaryInfC{$\Gamma \vdash A$} \DisplayProof &
    \AxiomC{$ \Gamma \vdash A\ \land\ B $}
    \RightLabel{(CONJUNCT2)}
    \UnaryInfC{$\Gamma \vdash B$} \DisplayProof
\end{tabular}\par}

\vspace{\baselineskip}
其中 MP 意为 Modus Ponens 即肯定前件，MATCH\_MP 是带有自动全称量化匹配的肯定前件
（Modus Ponens with matching of universal quantification），
DISCH 是 dischard 的简写，将一个假设作为条件移入结论，ASSUME 是假设公理，
GEN 将表达 $t$ 中的自由变量 $x$ 全称量化，CONJUNCT1 与 CONJUNCT2 分解合取（conjunction）。

HOL 定理证明器基于 SML(Standard Meta Language) 编程语言\cite{milner1997definition,SML}开发，
操作 HOL 证明器需要使用一种修改过的 SML 语言完成，
包括定义、推理、证明在内的操作都需要通过这种类 SML 语言的函数来完成。

\begin{notation}[用于定义HOL逻辑上新的类型的记号] 
使用如下文法表示 HOL 逻辑上的新的类型定义的构造。
    \[ \begin{split} 
        type\_name\ ::= \ & Constructor1\ arg1_1\ \cdots\ arg1_i \mbar \cdots \\
                        \mbar & ConstructorN\ argN_1\ \cdots\ argN_k
    \end{split} \]

$Constructor1 \cdots ConstructorN$ 表示构造函数的名称，$arg1_1 \cdots arg1_i \cdots argN_k$
均为类型，表示对应构造函数的参数的类型，即各构造函数具有如下类型。
\begin{gather*}
    Constructor1 :\ arg1_1 \rightarrow arg1_2 \cdots \rightarrow arg1_i \rightarrow type\_name \\
    \cdots \\
    ConstructorN :\ argN_1 \rightarrow argN_2 \cdots \rightarrow argN_k \rightarrow type\_name
\end{gather*}
这一记号对应的 HOL 代码是：
\begin{minted}{sml}
val _ = Datatype `type_name = Constructor1 arg11 ... arg1i | ...
                   | ConstructorN argN1 ... argNk`;
\end{minted}
\end{notation}

\begin{defin}[用于定义HOL逻辑上值与函数的记号] 然后是定义值与函数的记号
    \[ \begin{split}
        & value \coloneqq expression \\
        & function\ x_1\ \cdots\ x_n \coloneqq expression
    \end{split}   \]
其中 $x_1\cdots x_n$ 为参数符号。可以显示地指定参数类型：
    \[ 
        function\ (x_1:\tau_1) \cdots\ (x_n:\tau_n) \coloneqq expression
    \]
不造成混淆的情况下可以省略类型指示。对应的 HOL 代码是
\begin{minted}{sml}
val value_def = Define `value = expression`;
val func_def = Define `function x1 ... xn = expression`;
\end{minted}
\end{defin}

%\section{其他一些需要的理论与工具}
%
%这些逻辑上的理论与工具通用于经典逻辑与大多数非经典逻辑，下文的论述默认在 HOL 逻辑的范畴下。
%
%\begin{defin}[常用逻辑函数]
%\begin{align*}
%    & (\mathrm{I}:\alpha \rightarrow \alpha)\ x\ \coloneqq x \\
%    & (\mathrm{K}:\alpha \rightarrow \beta \rightarrow \alpha)\ x\ y\ \coloneqq x
%\end{align*}
%\end{defin}
%
%\begin{defin}[自然数类型] 遵循于皮亚诺定义方式。
%    \[ \mathrm{number} \Coloneqq 0 \mbar \Suc \mathrm{number} \]
%$\Suc$ 表示后继函数，即一切自然数都是0或者另一个自然数的后继。
%例如 1 是 $\Suc 1$，2 是 $\Suc(\Suc 1)$
%\end{defin}
%
%\begin{defin}[有限映射] \label{Def.FM}
%有限映射是定义域与值域均为有限集合的映射关系，
%从类型$\alpha$到类型$\beta$的有限映射类型写作
%    \[ \alpha \mapsto \beta \]
%有限映射的定义域函数为 $\mathbf{FDom} : (\alpha \mapsto \beta)
%    \rightarrow (\alpha\ \mathrm{set})$，值域函数为
%$\mathbf{FRng} : (\alpha \mapsto \beta)
%    \rightarrow (\beta\ \mathrm{set})$
%\[ \mathbf{FRng}\ f \coloneqq \{f\ x\mbar x \in \mathbf{FDom}\ f\} \]
%有限映射的空集为 $\mathbf{FEmpty}$
%    \[ \mathbf{FDom}\ \mathbf{FEmpty} = \emptyset\]
%有限映射的更新函数 $\fupdate$
%\[ \begin{split}
%\mathbf{FDom}\ ((x, y)\ \fupdate\ f) &= x \INSERT \mathbf{FDom}\ f \\
%    ((x, y)\ \fupdate\ f)\ a &= \xif x = a \xthen y \xelse f\ x
%\end{split} \]
%一切有限映射都是从$\mathbf{FEmpty}$ 开始，经有限次 $\fupdate$ 更新得到。
%\end{defin}
%
