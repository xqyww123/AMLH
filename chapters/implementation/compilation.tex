\section{抽象机器 \amlhS 的编译} \label{Sec.compile}

抽象机器 \amlh 的编译分为两步，首先程序被其定义展开成基元函数的组合，
成为一种中间表达（IR）。IR 由 HOL 作为文本输出而交给外部程序，外部程序
由基元函数到目标平台指令集的映射，将基元函数的组合翻译至目标平台。
用户程序到 IR 的编译是在 HOL 内部进行而被保障的，IR 到目标平台的编译
是在外部进行，是可能有错误的。

本文的 \amlhS 的基元函数存在到 WASM 的映射，其上的程序可以被编译到 WASM
，进而在任何 WASM 执行平台上运行。EOS.IO 等智能合约平台支持以 WASM 程序
作为智能合约。

WASM 的特点，只有 \Wi{32}，\Wi{64}，\Wf{32}，\Wf{64} 
四种类型，分别表示 32位整数、64位整数、32位浮点数、64位浮点数。本工作的
\amlhS 尚不支持浮点数，故只考虑 \Wi{32} 与 \Wi{64}。

\amlhS 中每一个理解都具有确定的字节数，理解的现象以此字节数排布在内存中
。计算时，所有小于等于4字节的现象以 WASM 的 \Wi{32} 表示，大于4字节但
小于等于8字节的以 \Wi{64} 表示，大于8字节的以指针表示。
本工作的实现中指针以32位整数 \Wi{32} 表示，但这是可变的。
 $\mathcal{T}_b$ 表示 $b$ 个字节的值的 WASM 类型
 \[ \mathcal{T}_b \coloneqq \left\{ \begin{array}{lcl} 
\Wi{32} &\when& b \leq 4\\\Wi{64} &\when& 4 < b \leq 8\\
   \Wpointer &\when& 8 < b \end{array} \right. \]

WASM 上的指令也为各种类型设计了不同版本。例如整数加法有 \texttt{i32.add}
，\texttt{i64.add} 两种版本。\amlhS 中的基元运算也根据字节长度有不同
版本，例如 $\mbar{IAdd}\ n$ 表示 $n$ 个字节的整数加法基元函数，
具体参见表 \ref{tab.IC.primop2}。$n$ 个字节的基元函数就对应 \Wtyp{n} 
类型的版本的指令。基元函数 $\mathbf{IAdd}\ n$ 对应的 WASM 指令是
\Winst{\Wtyp{n}.add}，这一记号表示类型 \Wtyp{n} 版本的 \texttt{add} 
指令。

以 WASM 为智能合约架构的智能合约平台一般提供外部函数以实现高精度运算。
目前的 \amlhS 尚不支持高精度整数运算，仅支持最高64位的运算，故 $n > 8$
，$\Wtyp{n} = \Wpointer$ 情况的整数运算不需要考虑。

WASM 采用一种树形结构表达， \amlhS 的 IR 的也同以树形结构表达，与 WASM
的结构类似。

\amlh 中的 Let 结构表示本地变量，
\[ \mathrm{Let}\ p\ (\lambda x.\ p') \]
将被编译为，赋值 $p$ 给名为 $x$ 的本地变量，并在编译 $p'$ 中，所有对
$x$ 的引用都编译为读取本地变量 $x$。

\amlhS 的 IR 中分支表达为
\[ \mathbf{If}\quad condition\quad branch_A\quad branch_B \]
对应的 WAST 表达为
\[ (\texttt{if}\quad (condition)\quad (\texttt{then}\quad branch_A)
\quad (\texttt{else}\quad branch_B)) \]
整个 $branch_A$ 与 $branch_B$ 都在分支块中，只有那些重复的计算被重用
地置于之前的临时变量赋值中。最后循环结构因 \amlhS 目前尚不支持而
不需要讨论。表 \ref{tab.primop.WASM} 列出了基元函数到 WASM 指令的映射。

\begin{table}[hp]
\begin{threeparttable}
\centering \caption{\amlhS 的基元函数到 WASM 指令的映射}
\label{tab.primop.WASM}
\begin{tabularx}{\linewidth}{ |c|c|c|X| } \hline
{\bfseries 基元函数} & {\bfseries 条件} & {\bfseries WASM 指令} &
{\bfseries 说明}\\ \hline
$\mathbf{IAdd}\ b$ & $b \leq 8$ & \Winst{\Wtyp{b}.add} & 
不支持 $b > 8$ 时的高精度运算 \\ \hline
$\mathbf{ISub}\ b$ & $b \leq 8$ & \Winst{\Wtyp{b}.sub} & 
不支持 $b > 8$ 时的高精度运算 \\ \hline
$\mathbf{IMul}\ b$ & $b \leq 8$ & \Winst{\Wtyp{b}.mul} &
不支持 $b > 8$ 时的高精度运算 \\ \hline
$\mathbf{ILt}\ b$ & $b \leq 8$ & \Winst{\Wtyp{b}.lt} &
不支持 $b > 8$ 时的高精度运算 \\ \hline
$\mathbf{ILe}\ b$ & $b \leq 8$ & \Winst{\Wtyp{b}.le} &
不支持 $b > 8$ 时的高精度运算 \\ \hline
$\mathbf{IEq}\ b$ & $b \leq 8$ & \Winst{\Wtyp{b}.eq} &
不支持 $b > 8$ 时的高精度运算 \\ \hline
$\mathbf{IConv}\ a\ b$ & $a \leq 4\ \land\ b \leq 4$ 
& 不生成指令 & 不需要任何计算 \\ \hline
$\mathbf{IConv}\ a\ b$ & $a \leq 4\ \land\ 4 < b \leq 8$ 
& \texttt{i64.extend\_u/i32} & \\ \hline
$\mathbf{IConv}\ a\ b$ & $4 < a \leq 8\ \land\ b < 4$ 
& \texttt{i32.wrap/i64} &  \\ \hline
$\mathbf{IConv}\ a\ b$ & $8 < a\ \land\ 8 < b$
& 不生成指令 & 不需要任何计算 \\ \hline
$\mathbf{IConv}\ a\ b$ & 其余情况
& 不支持 & 不支持任何高精度运算 \\ \hline
$\mathbf{INot}$ & $\T$ & \Winst{i32.eqz} & \\ \hline
$\mathbf{Append}\ i$ & $\T$ & \Winst{call $\texttt{append}\_{\Si_i}$} 
& 根据给定的理解 $i$ 的字节大小 $\Si_i$，生成 $\Si_i$ 字节版本的
列表增添函数并调用。\\ \hline
$\mathbf{Has}\ t$ & $\T$ & \Winst{call $\texttt{has}_t$}
& 生成表 $t$ 版本的区块链数据查找函数并调用。\\ \hline
$\mathbf{Read}\ t$ & $\T$ & \Winst{call $\texttt{read}_t$}
& 生成表 $t$ 版本的区块链数据读取函数并调用。\\ \hline
$\mathbf{Read0}\ t$ & $\T$ & \Winst{call $\texttt{read0}_t$}
& 生成表 $t$ 版本的区块链数据读取函数并调用。\\ \hline
$\mathbf{Write}\ t$ & $\T$ & \Winst{call $\texttt{write}_t$}
& 生成表 $t$ 版本的区块链数据写入命令构造函数并调用。\\ \hline
$\mathbf{Cart}\ n\ m$ & $\T$ & \Winst{call $\texttt{cart}_{n,m}$}
& 生成表 $n,m$ 版本的内存拼接函数并调用。\\ \hline
$\mathbf{Seg}\ n\ m$ & $\T$ & \Winst{call $\texttt{seg}_{n,m}$}
& 生成表 $n,m$ 版本的内存部分读取函数并调用。\\ \hline
$\mathbf{If}$ & $\T$ & \Winst{if} & 见正文的论述 \\ \hline
\end{tabularx}\end{threeparttable}\end{table}

一些基元函数不能直接对应到一个 WASM 上的指令，而是要通过预先构建的
WASM 上的函数，这些函数可以理解为 \amlhS 运行时的系统库，
当然这些函数也可以内联地展开在基元函数调用的地方。
现在将论述表 \ref{tab.primop.WASM} 中提及的系统库函数 $\texttt{has}_t$，
$\texttt{read}_t$，$\texttt{read0}_t$，$\texttt{write}_t$，
$\texttt{cart}_{n,m}$，$\texttt{seg}_{n,m}$。

\begin{description}
\item[全局值 \texttt{heap\_pointer : \Wpointer}] 指向堆的末尾。
\amlhS 在 WASM 的编译实现的堆正向增长。
\texttt{heap\_pointer} 的初始值是一常量，此值之前的为常量段内存，
之后为堆。
\item[函数 \texttt{malloc(size\ :\ \Wpointer)}\ :\ \Wpointer] 
在堆中分配大小为 \texttt
{size} 字节的内存。将 \texttt{heap\_pointer} 的值增加 \texttt{size}
而返回 \texttt{heap\_pointer} 的原始值。
\item[函数 $\texttt{has}_{(\mathbf{TC}\ c\ i\ j)}\texttt{(t\ :\ 
\Wtyp{\Si_i})}\ :\ \Wi{32}$] 根据目标智能合约平台，
调用智能合约平台提供的接口，查询链数据的表$c$
中是否有键 $k$，并返回 \Wi{32} 类型的 Bool 值。
\item[函数 $\texttt{read}_{(\mathbf{TC}\ c\ i\ j)}\texttt{(k\ :\ 
\Wtyp{\Si_i})\ :\ \Wtyp{\Si_j}}$]
根据目标智能合约平台，调用智能合约平台提供的接口，读取链数据的表$c$
的键 $k$。并根据 $\Si_j$ 决定是以指针方式还是值方式返回数据，并返回类型
\Wtyp{\Si_j}。
\item[函数 $\texttt{write}_{(\mathbf{TC}\ c\ i\ j)}\texttt{(k\ :\ 
\Wtyp{\Si_i},\ v\ :\ \Wtyp{\Si_j})\ :\ \Wpointer}$] 
构造链数据写入命令。
首先调用 \texttt{malloc} 函数分配适当的空间将键值存于内存，即，当 
$\Si_i \leq 8$ 时分配 $\Si_i$ 字节的内存并存储 $k$ 的值，当 $\Si_i
> 8$ 时 $k$ 就是指向键数据的指针。$v$ 的处理相同。
链数据写入命令的内存结构为
\begin{center}
\begin{tabular}{|c|c|c|c|c|} \hline
\text{表标识}&\text{键指针}&
\text{键大小}&\text{值指针}&\text{值大小}\\
\text{1byte}&\text{PointerSize} bytes&
\text{4bytes}&\text{PointerSize} bytes&\text{4byte} \\ \hline
\end{tabular}
\end{center}
表标识占用1字节，理论上表标识可以是任意字符串，但在编译实现中，
一段合约所有使用的表标识被唯一地分配$0\sim255$的编号，使用此编号表示
表标识，故一个合约支持访问的表数量不超过256个。\texttt{write} 函数
如上地分配并写入此内存结构，最后返回此内存结构的指针。
\item[函数 $\texttt{seg}_{l,m,n}\texttt{(v\ :\ \Wtyp{l})\ :\ 
\Wtyp{n}}$] 返回 $v$ 的第 $m$ 字节到第 $m+n-1$ 字节（从0开始）的共
$n$ 个字节的数据。若 $l > 8$ 则 $v$ 为指针，将指针位移 $m$ 并根据 $n$
的值，若 $n > 8$ 则直接返回指针 $v + m$ 否则读取 $v + m$ 处的数据并
根据 \Wtyp{n} 返回适当的 \Wi{32} 或 \Wi{64}。若 $l \leq 8$ 则 $v$
为一值，$(v\ \texttt{>>}\ 8m)\ \texttt{\&}\ ((1\ \texttt{<<}
\ 8n) - 1)$ 即是返回值，注意其中 $8m$，$((1\ \texttt{<<}\ 8n) - 1)$是
常量。
\end{description}

\begin{algorithm}[b]
\caption{用户程序的包装算法} \label{alg:package}
\begin{algorithmic}[1]
\Statex 对编译好的用户程序 user\_func
\State 读取来自智能合约平台的输入
\State 以输入调用 user\_func 并记返回值为 $(l, x)$，其中 $l$ 为
链数据写入命令序列，$x$ 为计算结果
\State 逐一遍历命令序列 $l$ 并执行链数据写入
\State 将计算结果 $x$ 返回给智能合约平台
\end{algorithmic}
\end{algorithm}


以上，由表 \ref{tab.primop.WASM} 以及上述的运行时函数，可以将 \amlhS 
的 IR 翻译成 WASM，进而完成编译。
而这一编译是非常简洁的，外部编译器所肩负的职责仅仅是对 \amlh 的 IR 进行
几乎指令对指令的翻译，不需要任何复杂的编排或逻辑。外部编译程序可以
非常简短，以有效降低缺陷的出现可能，并使对其的形式化验证更加容易。

编译好的用户程序会进行最后的包装，在函数执行之前插入处理来自智能合约
平台的输入的代码，并在函数之后增加对链数据写入指令的执行程序。
这两部分都是固定的。算法 \ref{alg:package} 描述了这一过程。
最后包装好的函数就是可以被智能合约执行平台调用并能
有效地计算输出并修改区块链数据的智能合约。

附录 \ref{Ch.example.transfer} 给出了对一段转账示例程序的编译结果，
对照本节内容可以清晰地看到 \amlhS 上的 IR 到 WASM 的编译是如何
指令对指令的简洁的。
