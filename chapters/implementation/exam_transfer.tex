\section{实验：转账合约} \label{Ch.example.transfer}

这节实验并分析使用 \Eamlh 构造、验证并编译一个代币合约的转账函数。

%将详细给出一个转账合约在 \amlhS 上的示例。
首先定义代币的理解，使用符号 \currency 表示此理解。
\begin{align*} 
  \currency &\coloneqq \NatSegI(\mathrm{TS} + 1)&
  \B_\currency &\coloneqq \lceil \log_{256}(\mathrm{TS} + 1)
  \rceil&
\end{align*}
TS 表示该货币的总供应量，$\NatSegI(\mathrm{TS} + 1)$ 表示所有小于 $\mathrm{TS} + 1$ 的自然数，
于是理解 \currency 保证了其所表示的货币一定不超过总供应量；$\B_\currency$ 表示理解 \currency 
的大小，以字节为单位。

先由公理律得到参数定理
\begin{flalign}
&\text{由公理得}& \dot{c} \widesim[2]{\OneI\ \phi} \phi &\vdash 
\dot{c} \widesim[2]{\OneI\ \phi} \phi & \label{f.a.c} \\
&\text{由公理得}& A \widesim{\AddressI} a &\vdash 
A \widesim{\AddressI} a & \label{f.a.a} \\
&\text{由公理得}& B \widesim{\AddressI} b &\vdash 
B \widesim{\AddressI} b & \label{f.a.b} \\
&\text{由公理得}& M \widesim{\currency} m &\vdash M \widesim{\currency} m&
\label{f.a.m} \end{flalign}
$\dot{c}$ 是状态参数，$\phi : \mathrm{chain}$ 是链状态，
$a : \mathrm{address}$ 是转账方，$b : \mathrm{address}$ 是被转账方，
$m:\mathrm{num}$ 是转账金额，链数据中的账户表标识为 
$\mathrm{c_\currency}$，数据表为
\[\tcurrency \coloneqq \mathbf{TC}\ \ccurrency\ \AddressI\ \currency \]
调用条件为 $P_0$
\[ P_0 \coloneqq (\Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}) \]
即表 $\tcurrency$ 的所有值的和始终等于总供应量，即货币不会丢失也不会增多
。之后将证明转账合约执行后的链数据仍将保持此属性，以证明转账的合理性。
在下文中，简写记号
\begin{align*}
\tilde{c} &\coloneqq \dot{c} \widesim[2]{\OneI\ \phi} \phi&
\tilde{a} &\coloneqq A \widesim{\AddressI} a&
\tilde{b} &\coloneqq B \widesim{\AddressI} b&
\tilde{m} &\coloneqq M \widesim{\currency} m&
\end{align*}
帮助缩短公式长度。此程序会用到如下基元函数或者预定义函数或者常量
\begin{flalign}
&\text{基元}& &\vdash \mathbf{Has}\ t
\proctr{\OneI\ x|i|\BoolI}{\lambda x\ k.\ \T} \Has t & \label{f.Has} \\
&\text{基元}&&\vdash 
\mathbf{Read0}\ t \proctr{\OneI\ x|i|j}{\lambda x\ k.\ \T} \ReadZ\ t
&\label{f.Read} \\
&\text{基元}&& \vdash \mathbf{Write}\ t \proctr{i|j|\CWI}
  {\lambda k\ v.\ \T} \Write\ t & \label{f.Write}\\
&\text{基元}&&\vdash \mathbf{ILt}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
  \BoolI}{\lambda x\ y.\ \T} (<) &\label{f.lt}\\
&\text{基元}&&\vdash\mathbf{IAdd}\ \B_n \proctr{\NatSegI\ n|
\NatSegI\ n|\NatSegI\ n}{\lambda x\ y.\ x + y < 256^n} (+)
  &\label{f.A} \\
&\text{基元}&&\vdash\mathbf{ISub}\ \B_n \proctr{\NatSegI\ n|
  \NatSegI\ n|\NatSegI\ n}{\lambda x\ y.\ x \geq y} (-) & \label{f.S} \\
&\text{常量}& &\vdash \emptylist \widesim[2]{\ListI\ i} \mathrm{Nil}&
  \label{f.Nil}\\
&\text{基元}&&\vdash\mathbf{Append}\ i \proctr{i|\ListI\ i|\ListI\ 
  i}{\lambda x\ l.\ \T} (::)& \label{f.Append}\\
  &\text{基元}&\begin{split}&\vdash
  p_c \widesim{\BoolI} P \Rightarrow (P \Rightarrow p_a \widesim{i}
  \epsilon_a) \Rightarrow (\lnot P \Rightarrow p_b \widesim{i}
  \epsilon_b) \Rightarrow \\
  &\quad\quad \mathbf{If}\ p_c\ p_a\ p_b \widesim{i} \xif P \xthen 
  \epsilon_a \xelse \epsilon_b \end{split}& \label{f.If} \\
&\text{基元}& &\vdash \mathbf{Cart} \proctr{\ListI\ \CWI|i|\RsI\ i}
  {\lambda l\ x.\ \T}(\lambda l\ x.\ (l,\ x)) & \label{f.Rsp} \\
  &\text{常量}& &\vdash \texttt{T} \widesim{\BoolI} \T& \label{f.T} \\
  &\text{常量}& &\vdash \texttt{F} \widesim{\BoolI} \F& \label{f.F} \\
\end{flalign}
通过演绎上述的常量与基元定理，可以如下构建用于转账的合约程序。
\begin{flalign}
&\text{\ref{f.Read}\ SPEC $\tcurrency$}&
&\vdash \mathbf{Read0}\ \tcurrency \proctr{\OneI\ x|\AddressI|\currency}
  {\lambda x\ k.\ \T} \ReadZ\ \tcurrency& \label{f.Rc1} \\
&\text{\ref{f.Rc1} 调用 \ref{f.a.c}}& \tilde{c} & 
\vdash \mathbf{Read0}\ \tcurrency\ \dot{c} \proctr{\AddressI|\currency}
  {\lambda k.\ \T} \ReadZ\ \tcurrency\ \phi&\label{f.Rcc}  \\
&\text{\ref{f.Rcc} 调用 \ref{f.a.a}}& \tilde{c},\ \tilde{a}
& \vdash \mathbf{Read0}\ \tcurrency\ \dot{c}\ A \widesim{\currency}
\ReadZ\ \tcurrency\ \phi\ a& \label{f.RccaX} \\
  &\text{简写记号}& &\hat{a} = 
  ((\letvp{a} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)
  \ \land\ (\letve{a} = \ReadZ\ \tcurrency\ \phi\ a))& \\
&\text{\ref{f.RccaX} 记号 $\hat{a}$}& \tilde{c},\ \tilde{a}&,\ 
  \hat{a}\vdash \letvp{a} \widesim{\currency} \letve{a}
& \label{f.Rcca} \\
&\text{\ref{f.lt} 调用 \ref{f.Rcca}}& \tilde{c},\ \tilde{a}
&,\ \hat{a} \vdash \mathbf{ILt}\ \B_\currency\ \letvp{a}
  \proctr{\currency|\BoolI}{\K \T} (\lambda x.\ \letve{a} < x) 
  & \label{f.LRcca} \\
  &\text{\ref{f.LRcca} 调用 \ref{f.a.m}}& \tilde{c},\ \tilde{a}&,\ 
  \tilde{m},\ \hat{a} \vdash \mathbf{ILt}\ 
  \B_\currency\ \letvp{a}\ M \widesim{\BoolI} (\letve{a} < M) 
  & \label{f.LRccam} \\
&\text{简写记号}& P_1 &\coloneqq \letve{a} < m & \label{f.P2} \\
&\text{\ref{f.S} 调用 \ref{f.Rcca}}& \tilde{c},\ \tilde{a}
  &,\ \hat{a} \vdash \mathbf{ISub}\ \B_\currency\ 
  \letvp{a} \proctr{\currency|\currency}{\lambda y.\ \letve{a}
  \geq y} (\lambda y.\ \letve{a} - y)
   & \label{f.SRcca}\\
&\text{\ref{f.SRcca} 调用 \ref{f.a.m}}&  \tilde{c},\ \tilde{a}&,\ 
  \tilde{m},\ \hat{a},\ \lnot P_1 \vdash 
  \mathbf{ISub}\ \B_\currency\ \letvp{a}\ M \widesim{\currency}
  \letve{a} - m& \label{f.SRccam}\\
&\text{\ref{f.Write} SPEC $\tcurrency$}& \tilde{c} &\vdash 
  \mathbf{Write}\ \tcurrency \proctr{\AddressI|\currency|\CWI}
  {\lambda k\ v.\ \T} \Write\ \tcurrency& \label{f.Wc}\\
&\text{\ref{f.Wc} 调用 \ref{f.a.a}}& \tilde{c},\ \tilde{a} &\vdash
  \mathbf{Write}\ \tcurrency\ A \proctr{\currency|\CWI}
  {\lambda v.\ \T} \Write\ \tcurrency\ a& \label{f.Wca}\\
&\text{\ref{f.Wca} 调用 \ref{f.SRccam}}& \begin{split}
  \tilde{c},\ \tilde{a}&,\ \tilde{m},\ \hat{a},\ 
  \lnot P_1 \vdash \mathbf{Write}\ \tcurrency\ 
  A\ (\mathbf{ISub}\ \B_\currency\ \letvp{a}\ M) \\&
\quad\quad\widesim[2]{\CWI}\Write\ \tcurrency\ a\ (\letve{a} - m)
\end{split}& \label{f.WcaSRcam} \\
  &\text{\ref{f.Append} 调用 \ref{f.WcaSRcam}}& \begin{split}
    \tilde{c},\ \tilde{a}&,\ \tilde{m},\ \hat{a},\ 
    \lnot P_1 \vdash\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
    \letvp{a}\ M))\\
    & \proctr{\ListI\ \CWI|\ListI\ \CWI}{\lambda l.\ \T} 
    (\lambda l.\ (\Write\ \tcurrency\ a\ (\letve{a} - m)) :: l)
  \end{split} & \label{f.LWcaSRcam1} \\
  &\text{\ref{f.LWcaSRcam1} 调用 \ref{f.Nil}}& \begin{split}
    \tilde{c},\ \tilde{a},\ &\tilde{m},\ \hat{a},\ 
    \lnot P_1 \vdash\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
    \letvp{a}\ M))\ \emptylist\\
  & \widesim[3]{\ListI\ \CWI} [\Write\ \tcurrency\ a\ (\letve{a} - m)]
  \end{split} & \label{f.LWcaSRcam} \\
&\parbox{1.7cm}{\linespread{1}\selectfont 抽象范畴内的证明}&
P_0,\ &\lnot P_1 \vdash \ReadZ\ \tcurrency\ \phi\ b + m < \mathrm{TS} + 1
\leq 256^{\B_\currency} & \label{f.P.addOK} \\
  &\text{\ref{f.Rcc} 调用 \ref{f.a.b}}& \tilde{c},\ \tilde{b} &\vdash 
\mathbf{Read0}\ \tcurrency\ \dot{c}\ B \widesim{\currency}
  \ReadZ\ \tcurrency\ \phi\ b & \label{f.RccbX}\\
&\text{简写记号}& &\hat{b} = ((\letvp{b} = \mathbf{Read0}\ \tcurrency\ 
  \dot{c}\ B)\ \land\ (\letve{b} = \ReadZ\ \tcurrency\ \phi\ b)) & \\
&\text{\ref{f.RccbX} 记号 $\hat{b}$}& \tilde{c},\ \tilde{b}&,\ 
  \hat{b}\vdash \letvp{b} \widesim{\currency} \letve{b} 
  & \label{f.Rccb}\\
&\text{\ref{f.Rccb} 调用 \ref{f.A}}& 
  \tilde{c},\ \tilde{b}&,\ \hat{b} \vdash \mathbf{IAdd}\ \B_\currency\ 
  \letvp{b} \proctr{\currency|\currency}
  {\lambda y.\ \letve{b} + y < 256^{\B_\currency}}
  (\lambda y.\ \letve{b} + y) &\label{f.ARccb} \\
&\parbox{2.4cm}{\ref{f.ARccb} 调用 \ref{f.a.m} 且由
\ref{f.P.addOK}}& \tilde{c},\ \tilde{b}&,\ \hat{b},\ \tilde{m},\ P_0,\ 
\lnot P_1 \vdash \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M 
\widesim{\currency} \letve{b} + m & \label{f.ARccbm} \\
&\text{\ref{f.Wc} 调用 \ref{f.a.b}}& \tilde{c},\ \tilde{b}&
\vdash \mathbf{Write}\ \tcurrency\ B \proctr{\currency|\CWI}
  {\lambda v.\ \T} \Write\ \tcurrency\ b &\label{f.Wcb}\\
&\text{\ref{f.Wcb} 调用 \ref{f.ARccbm}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ \hat{b},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M)
  \\ & \widesim[2]{\CWI} \Write\ \tcurrency\ b\ (\letve{b} + m)
\end{split} &\label{f.WcbARccbm}\\
&\text{\ref{f.Append} 调用 \ref{f.WcbARccbm}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ \hat{b},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M))\\ & 
  \proctr{\ListI\ \CWI|\ListI\ \CWI}{\lambda l.\ \T} (\lambda l.\ 
  (\Write\ \tcurrency\ b\ (\letve{b} + m))::l)
\end{split} & \label{f.LWcbARcbm}\\
&\text{\ref{f.LWcbARcbm} 调用 \ref{f.LWcaSRcam}}& \begin{split}
\tilde{c},\ \tilde{b},\ &\tilde{m},\ \hat{a},\ \hat{b},\ P_0,\ \lnot P_1
  \vdash \mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M))\\
  &\quad\quad(\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ A\ 
  (\mathbf{ISub}\ \B_\currency\ \letvp{a}\ M))\ \emptylist) \\ 
  &\widesim[3]{\ListI\ \CWI} [(\Write\ \tcurrency\ b\ (\letve{b} + m)),
  \ (\Write\ \tcurrency\ a\ (\letve{a} - m))]
\end{split} & \label{f.LLtrans1} \\
&\text{\ref{f.Rsp} 调用 \ref{f.LLtrans1}}& \begin{split}
\tilde{c},\ \tilde{b},\ &\tilde{m},\ \hat{a},\ \hat{b},\ P_0,\ \lnot P_1
  \vdash \mathbf{Cart}\ (\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ B\ (\mathbf{IAdd}\ \B_\currency\ 
  \letvp{b}\ M))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist)) \\ 
  &\proctr{i|\RsI\ i}{\lambda x.\ \T} (\lambda x.\ 
  ([(\Write\ \tcurrency\ b\ (\letve{b} + m)),\ (
  \Write\ \tcurrency\ a\ (\letve{a} - m))],\ x))
\end{split} & \label{f.LLtrans2} \\
&\text{\ref{f.LLtrans2} 调用 \ref{f.T}}& \begin{split}
\tilde{c},\ \tilde{b},\ &\tilde{m},\ \hat{a},\ \hat{b},\ P_0,\ \lnot P_1
  \vdash \mathbf{Cart}\ (\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ B\ (\mathbf{IAdd}\ \B_\currency\ 
  \letvp{b}\ M))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist))\ \texttt{T}\\ 
  &\widesim{\RsI\ \BoolI} ([(\Write\ \tcurrency\ b\ 
  (\letve{b} + m)),\ (\Write\ \tcurrency\ a\ (\letve{a} - m))],\ \T)
\end{split} & \label{f.LLtrans} \\
&\text{\ref{f.If} 调用 \ref{f.LRccam}}& \begin{split}
  \tilde{c},\ \tilde{a}&,\ \hat{a},\ \tilde{m} \vdash
  (P_1 \Rightarrow p_a \widesim{i} \epsilon_a) \Rightarrow 
  (\lnot P_1 \Rightarrow p_b \widesim{i} \epsilon_b) \Rightarrow \\
  \mathbf{If}\ &(\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)\ 
  p_a\ p_b \widesim{i} 
\xif P_1 \xthen \epsilon_a \xelse \epsilon_b \end{split}& \label{f.bc}
\\ &\text{\ref{f.Rsp} 调用 \ref{f.Nil}}&&\vdash \mathbf{Cart}\ 
\emptylist \proctr{i|\RsI\ i}{\lambda x.\ \T} (\lambda x.\ (\Nil,\ x))
& \label{f.b11}\\
&\text{\ref{f.b11} 调用 \ref{f.F}}&&\vdash \mathbf{Cart}\ 
\emptylist\ \texttt{F} \widesim{\RsI\ \BoolI} (\Nil,\ \F) 
& \label{f.b1} \\
&\text{\ref{f.bc} 调用 \ref{f.b1}}&\begin{split}
  \tilde{c},\ \tilde{a}&,\ \hat{a},\ \tilde{m} \vdash
(\lnot P_1 \Rightarrow p_b \widesim{\RsI\ \BoolI} \epsilon_b)
\Rightarrow \\&\mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)
  \ (\mathbf{Cart}\ \emptylist\ \texttt{F})\ p_b\\
  &\widesim{\RsI\ \BoolI} 
\xif P_1 \xthen (\Nil,\ \F) \xelse \epsilon_b \end{split}& \label{f.ook}
\\ &\text{\ref{f.ook} 调用 \ref{f.LLtrans}}& \begin{split}
  \tilde{c},\ \tilde{a}&,\ \tilde{b},\ \hat{a},\ \hat{b},\ \tilde{m},\ 
  P_0 \vdash \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist)\ \texttt{T})\\ 
  &\widesim{\RsI\ \BoolI} \xif P_1 \xthen (\Nil,\ \F) \xelse
  ([(\Write\ \tcurrency\ b\ (\letve{b} + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ (\letve{b} - m))],\ \T)
\end{split} & \label{f.OK1} \\
&\text{\ref{f.OK1} 条件 $P_0$}& \begin{split}
\tilde{c},\ \tilde{a}&,\ \tilde{b},\ \hat{a},\ \hat{b},\ \tilde{m}
  \vdash \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M)))
  \\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist)\ \texttt{T})\\ 
  &\proctr{\RsI\ \BoolI}{P_0} \xif P_1 \xthen (\Nil,\ \F) \xelse
  ([(\Write\ \tcurrency\ b\ (\letve{b} + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ (\letve{a} - m))],\ \T)
\end{split} & \label{f.OK2} \\
&\parbox{1.8cm}{\ref{f.OK2} 标记削除 $\hat{b},\ \hat{a}$}& \begin{split}
\tilde{c},\ \tilde{a}&,\ \tilde{b},\ \tilde{m}
\vdash \mathrm{Let}\ \letvp{a} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ A
  ;\ \letvp{b} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ B \ \mathrm{in} \\
  &\mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M)))
  \\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist)\ \texttt{T})\\ 
  &\proctr{\RsI\ \BoolI}{P_0} \mathrm{let}\ 
  \letve{a} = \ReadZ\ \tcurrency\ \phi\ a;\ 
  \letve{b} = \ReadZ\ \tcurrency\ \phi\ b\ 
  \mathrm{in}\\&\quad\xif \letve{a} < m \xthen (\Nil,\ \F) \xelse 
  \\&\quad\quad\quad([(\Write\ \tcurrency\ b\ (\letve{b} + m)),
  \Write\ \tcurrency\ a\ (\letve{a} - m))],\ \T)
\end{split} & \label{f.OK2L2} \\ \hline
&\parbox{2cm}{\ref{f.OK2L2} 抽象 $\tilde{m},\ \tilde{b},\ \tilde{a},\ 
\tilde{c}$}& \begin{split} &\vdash (\lambda \dot{c}\ A\ B\ M.\ 
\mathrm{Let}\ \letvp{a} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ A
  ;\ \letvp{b} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ B \ \mathrm{in} \\
  &\mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M)))
  \\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist)\ \texttt{T}))\\ 
  &\proctr{\RsI\ \BoolI}{\lambda \phi\ a\ b\ m.\ P_0} 
  \lambda \phi\ a\ b\ m.\ \mathrm{let}\ 
  \letve{a} = \ReadZ\ \tcurrency\ \phi\ a;\ 
  \letve{b} = \ReadZ\ \tcurrency\ \phi\ b\ 
  \mathrm{in}\\&\quad\xif \letve{a} < m \xthen (\Nil,\ \F) \xelse 
  \\&\quad\quad\quad([(\Write\ \tcurrency\ b\ (\letve{b} + m)),
  \Write\ \tcurrency\ a\ (\letve{a} - m))],\ \T
\end{split} & \label{f.Final}
\end{flalign}

式 \ref{f.Final} 是最后得到的定理，虽然上述表述非常冗长，但实际只进行了 35 步定理演绎，
即在实际的编辑前端上的操作只需要输入35个指令，基本与 Solidity 等传统方案的输入文本量是接近的。
式 \ref{f.Final} 中左侧是构建所得的目标智能合约，记为 $\mathbf{Transfer}_\mathrm{p}$。
\[ \begin{split} \lambda \dot{c}\ A\ &B\ M.\ 
\mathrm{Let}\ \letvp{a} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ A
  ;\ \letvp{b} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ B \ \mathrm{in} \\
  &\mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ \letvp{a}\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
  \mathbf{IAdd}\ \B_\currency\ \letvp{b}\ M)))
  \\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  \letvp{a}\ M))\ \emptylist)\ \texttt{T})
\end{split} \]
右侧是其对应的抽象意义，记为 $\mathrm{Transfer}_\epsilon$。
\[ \begin{split} \lambda \phi\ a\ &b\ m.\ \mathrm{let}\ 
  \letve{a} = \ReadZ\ \tcurrency\ \phi\ a;\ 
  \letve{b} = \ReadZ\ \tcurrency\ \phi\ b\ 
  \mathrm{in}\\&\quad\xif \letve{a} < m \xthen (\Nil,\ \F) \xelse 
  \\&\quad\quad\quad([(\Write\ \tcurrency\ b\ (\letve{b} + m)),
  \Write\ \tcurrency\ a\ (\letve{a} - m))],\ \T
\end{split} \]
中间的 Noesis 同构符号
\[ \proctr{\OneI\ \phi|\AddressI|\AddressI|\currency|\RsI\ \BoolI}
{\lambda \phi\ a\ b\ m.\ \Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}}\]
表明了合约的参数与返回的理解，以及调用条件。
而在 \amlhS 上，理解是固定大小的，于是也得到了此合约的各参数与返回的大小，
即输入参数为 $\phi,\ a,\ b,\ m$ 占用的字节数分别为 $0,\ \mathrm{AdrSize},\ \mathrm{AdrSize},\ \B_\currency$，
输出结果占用的字节数为 $1 + \mathrm{PointerSize}$。当输入与输出的大小被确定，这一函数的调用接口就被确定。

在以上的程序构建过程中，只有式 \ref{f.P.addOK} 涉及到 Noesis 逻辑外的
证明，进行简单地化简（展开 $P_0,\ P_1,\ \ReadZ,\ \letve{a},\ \B_\currency$ 的定义）后具有如下形式
\[ (\Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}),\ m \leq \phi^\tcurrency(a)
\vdash \phi^\tcurrency(b) + m < \mathrm{TS} + 1
\leq 256^{\lceil \log_{256}(\mathrm{TS} + 1) \rceil}\]
这是一个自然数相关的命题，
是关于抽象的数学理论的而不是关于复杂的具象程序。

这体现了本文的思想，\Eamlh 本身不进行任何的证明也不解决任何具体的证明问题，
\Eamlh 只是利用抽象语义，在形式化证明的保障下，将对复杂的具象程序的证明转化为对数理领域内的抽象问题的证明，
而最终抽象命题的证明依旧需要用户解决，但用户在 HOL 证明工具强大而专业的分析能力的帮助下，
这些抽象命题往往很容易被解决，且至少一定比直接分析复杂具象的现实程序更加容易。
在本节的实验中，式 \ref{f.P.addOK} 所涉及的抽象命题，就是对自然数小于与小于等于运算的传递律
的简单应用，可以在 HOL 证明器上用默认策略自动证明。这一实际的实验也反过来佐证了，将
具象的现实程序的证明问题转化为对抽象语义的证明，确实可以有效地简化形式化验证。

将调用条件记为 $P$
\[ P\ \phi \coloneqq (\Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}) \]
接下来将证明转账函数 $\mathbf{Transfer}_\mathrm{p}$ 对调用条件 $P$ 的不变性，即
$\mathbf{Transfer}_\mathrm{p}$ 执行后链上货币的总量依旧为总供应量，即不会有货币增加或丢失。
具体这是关于 $\mathrm{Transfer}_\epsilon$ 的命题
\[ P\ \phi \vdash P\ (\phi \fupdates \fst(\mathrm{Transfer}_\epsilon
\ \phi\ a\ b\ m)) \]
\begin{proof} 展开 $\mathrm{Transfer}_\epsilon$，命题等价于
  \[ \begin{split} P\ \phi \vdash P\ (\phi \fupdates 
 \xif & \ReadZ\ \tcurrency\ \phi\ a < M \xthen \Nil \xelse 
  [(\Write\ \tcurrency\ b\\& ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
    \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))])
  \end{split} \]
进一步等价于
\[ \begin{split} P\ \phi,\ \ReadZ\ \tcurrency\ \phi\ a &\geq M 
  \vdash P\ (\phi \fupdate (\Write\ \tcurrency\ b\ ((\ReadZ\ 
  \tcurrency\ \phi\ b) + m))\ \fupdate\\&
  (\Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))) 
  \end{split} \]
因为表 $\tcurrency$ 的零元素 $\tcurrency_0 = 0$ 于是
\[ \begin{split} 
  \Sigma \Ima (\phi\ \fupdate &(\Write\ \tcurrency\ b\ ((\ReadZ\ 
  \tcurrency\ \phi\ b) + m))\ \fupdate\\&
  (\Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))
  )^\tcurrency = \Sigma \Ima \phi^\tcurrency
\end{split} \]
于是命题得证。
\end{proof}

这一证明再次体现了本文的思想，不是直接证明程序的性质，而是证明程序
的抽象对应的性质；对抽象的数理对象进行证明，而不是直接证明复杂而具象的
程序代码。

最后，程序 $\mathbf{Transfer}_\mathrm{p}$ 以 EOS.IO 为目标平台，
此时账户类型是 64 位整数，且当 $4 < \B_\currency \leq 8$ ，
指针为32位时编译得到的 WAST 为
\begin{minted}[mathescape]{cl}
  (func "transfer"
      (param i64) ; 输入参数 账户 $A$
      (param i64) ; 输入参数 账户 $B$
      (param i64) ; 输入参数 转账金额 $M$
      (local i64) ; 本地变量 $\letvp{a}$
      (local i64) ; 本地变量 $\letvp{b}$
      (result i64) ; 输出元组 $(l,x)$ ，$l$ 为指向链数据写入命令序列的指针，
                   ; $x$ 是 $\mathrm{Bool}$ 值表示否转账成功
    (local.set 3 (call read0_0_8_8 (local.get 0))) ; 赋值 $\letvp{a} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ A$
              ; read0_0_8_8 表示以 $8$ 字节的键读取表 $0$，并期望得到 $8$ 字节的返回
    (local.set 4 (call read0_0_8_8 (local.get 1))) ; 赋值 $\letvp{b} = \mathbf{Read0}\ \tcurrency\ \dot{c}\ B$
    (if (i64.lt (local.get 3) (local.get 2))
      (then (call cart_4_1  ; 构造元组 $(\texttt{[]},\F)$
        (i32.const 0) ; 指向 $0$ 的指针，表示空数组
        (i32.const 0) ; $1$ 字节的 $0$ 值，表示 $\mathrm{Bool}$ 值 $\mathrm{False}$
      ))
      (else (call cart_4_1
        (call append_17 
          (call write_0_8_8 (local.get 1)
                ; write_0_8_8 构造以 $8$ 字节的键 $8$ 字节的值对表 $0$ 的写入命令
            (i64.add (local.get 4) (local.get 2)))
          (call append_17
            (call write_0_8_8 (local.get 0)
              (i64.sub (local.get 3) (local.get 2)))
            (i32.const 0) ; 指向 $0$ 的指针，表示空数组
          ))
        (i32.const 1) ; $1$ 字节的 $1$ 值，表示 $\mathrm{Bool}$ 值 $\mathrm{False}$
      )))
  )
\end{minted}

结合表 \ref{tab.primop.WASM} 与第 \ref{Sec.compile} 节的内容，清晰地看到
$\mathbf{Transfer}_\mathrm{p}$ 是如何指令对指令地编译到上述 WASM 的。
