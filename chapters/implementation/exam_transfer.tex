\appendix\chapter{示例：\amlhS 上的转账合约} \label{Ch.example.transfer}

这章将详细给出一个转账合约在 \amlhS 上的示例。首先
定义理解，使用符号 \currency 表示本示例中的货币理解
\begin{align*} 
  \currency &\coloneqq \NatSegI\ \mathrm{TS}&
  \B_\currency &\coloneqq \lceil \log_{256} \mathrm{TS}
  \rceil&
\end{align*}
TS 表示该货币的总供应量，于是理解 \currency 保证了其
本体一定在总供应量内。

先由公理律得到参数定理
\begin{flalign}
&\text{由公理得}& \dot{c} \widesim[2]{\OneI\ \phi} \phi &\vdash 
\dot{c} \widesim[2]{\OneI\ \phi} \phi & \label{f.a.c} \\
&\text{由公理得}& A \widesim{\AddressI} a &\vdash 
A \widesim{\AddressI} a & \label{f.a.a} \\
&\text{由公理得}& B \widesim{\AddressI} b &\vdash 
B \widesim{\AddressI} b & \label{f.a.b} \\
&\text{由公理得}& M \widesim{\currency} m &\vdash M \widesim{\currency} m&
\label{f.a.m} \end{flalign}
$\dot{c}$ 是状态参数，$\phi : \mathrm{chain}$ 是链状态，
$a : \mathrm{address}$ 是转账方，$b : \mathrm{address}$ 是被转账方，
$m:\mathrm{num}$ 是转账金额，链数据中的账户表标识为 
$\mathrm{c_\currency}$，表为
\[\tcurrency \coloneqq \mathbf{TC}\ \ccurrency\ \AddressI\ \currency \]
调用条件为 $P_0$
\[ P_0 \coloneqq (\Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}) \]
即表 $\tcurrency$ 的所有值的和始终等于总供应量，即货币不会丢失也不会增多
。之后将证明转账合约执行后的链数据仍将保持此属性，以证明转账的合理性。
在下文中，简写记号
\begin{align*}
\tilde{c} &\coloneqq \dot{c} \widesim[2]{\OneI\ \phi} \phi&
\tilde{a} &\coloneqq A \widesim{\AddressI} a&
\tilde{b} &\coloneqq B \widesim{\AddressI} b&
\tilde{m} &\coloneqq M \widesim{\currency} m&
\end{align*}
帮助缩短公式长度。此程序会用到如下基元函数或者预定义函数或者常量
\begin{flalign}
&\text{基元}& &\vdash \mathbf{Has}\ t
\proctr{\OneI\ x|i|\BoolI}{\lambda x\ k.\ \T} \Has t & \label{f.Has} \\
&\text{基元}&&\vdash 
\mathbf{Read0}\ t \proctr{\OneI\ x|i|j}{\lambda x\ k.\ \T} \ReadZ\ t
&\label{f.Read} \\
&\text{基元}&& \vdash \mathbf{Write}\ t \proctr{i|j|\CWI}
  {\lambda k\ v.\ \T} \Write\ t & \label{f.Write}\\
&\text{基元}&&\vdash \mathbf{ILt}\ \B_n \proctr{\NatSegI\ n|\NatSegI\ n|
  \BoolI}{\lambda x\ y.\ \T} (<) &\label{f.lt}\\
&\text{基元}&&\vdash\mathbf{IAdd}\ \B_n \proctr{\NatSegI\ n|
\NatSegI\ n|\NatSegI\ n}{\lambda x\ y.\ x + y < 256^n} (+)
  &\label{f.A} \\
&\text{基元}&&\vdash\mathbf{ISub}\ \B_n \proctr{\NatSegI\ n|
  \NatSegI\ n|\NatSegI\ n}{\lambda x\ y.\ x \geq y} (-) & \label{f.S} \\
&\text{常量}& &\vdash \emptylist \widesim[2]{\ListI\ i} \mathrm{Nil}&
  \label{f.Nil}\\
&\text{基元}&&\vdash\mathbf{Append}\ i \proctr{i|\ListI\ i|\ListI\ 
  i}{\lambda x\ l.\ \T} (::)& \label{f.Append}\\
  &\text{基元}&\begin{split}&\vdash
  p_c \widesim{\BoolI} P \Rightarrow (P \Rightarrow p_a \widesim{i}
  \epsilon_a) \Rightarrow (\lnot P \Rightarrow p_b \widesim{i}
  \epsilon_b) \Rightarrow \\
  &\quad\quad \mathbf{If}\ p_c\ p_a\ p_b \widesim{i} \xif P \xthen 
  \epsilon_a \xelse \epsilon_b \end{split}& \label{f.If} \\
&\text{基元}& &\vdash \mathbf{Cart} \proctr{\ListI\ \CWI|i|\RsI\ i}
  {\lambda l\ x.\ \T}(\lambda l\ x.\ (l,\ x)) & \label{f.Rsp} \\
  &\text{常量}& &\vdash \texttt{T} \widesim{\BoolI} \T& \label{f.T} \\
  &\text{常量}& &\vdash \texttt{F} \widesim{\BoolI} \F& \label{f.F} \\
\end{flalign}
现在可以演绎定理以构建程序
\begin{flalign}
&\text{\ref{f.Read}\ SPEC $\tcurrency$}&
&\vdash \mathbf{Read0}\ \tcurrency \proctr{\OneI\ x|\AddressI|\currency}
  {\lambda x\ k.\ \T} \ReadZ\ \tcurrency& \label{f.Rc1} \\
&\text{\ref{f.Rc1} 调用 \ref{f.a.c}}& \tilde{c} & 
\vdash \mathbf{Read0}\ \tcurrency\ \dot{c} \proctr{\AddressI|\currency}
  {\lambda k.\ \T} \ReadZ\ \tcurrency\ \phi&\label{f.Rcc}  \\
&\text{\ref{f.Rcc} 调用 \ref{f.a.a}}& \tilde{c},\ \tilde{a}
& \vdash \mathbf{Read0}\ \tcurrency\ \dot{c}\ A \widesim{\currency}
\ReadZ\ \tcurrency\ \phi\ a& \label{f.Rcca} \\
&\text{\ref{f.lt} 调用 \ref{f.Rcca}}& \tilde{c},\ \tilde{a}
  & \vdash \mathbf{ILt}\ \B_\currency\ (
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)
\proctr{\currency|\BoolI}{\K \T} (\lambda x.\ \ReadZ\ \tcurrency\ \phi
  \ a< x) & \label{f.LRcca} \\
  &\text{\ref{f.LRcca} 调用 \ref{f.a.m}}& \tilde{c},\ \tilde{a},\ &
  \tilde{m} \vdash \mathbf{ILt}\ \B_\currency\ (
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M
\widesim{\BoolI} (\ReadZ\ \tcurrency\ \phi\ a < M) & \label{f.LRccam} \\
&\text{简写记号}& P_1 &\coloneqq \ReadZ\ \tcurrency\ \phi\ a
  < M & \label{f.P2} \\
&\text{\ref{f.S} 调用 \ref{f.Rcca}}& \begin{split}\tilde{c},\ \tilde{a}
  &\vdash \mathbf{ISub}\ \B_\currency\ (\mathbf{Read0}\ 
    \tcurrency\ \dot{c}\ A) 
  \proctr{\currency|\currency}{\lambda y.\ \ReadZ\ \tcurrency\ \phi\ a
\geq y}\\ &\quad\quad (\lambda y.\ (\ReadZ\ \tcurrency\ \phi\ a) - y)
  \end{split} & \label{f.SRcca}\\
&\text{\ref{f.SRcca} 调用 \ref{f.a.m}}&  \tilde{c},\ \tilde{a},\ &
  \tilde{m},\ \lnot P_1 \vdash \mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M \widesim{\currency}(\ReadZ
  \ \tcurrency\ \phi\ a) - m& \label{f.SRccam}\\
&\text{\ref{f.Write} SPEC $\tcurrency$}& \tilde{c} &\vdash 
  \mathbf{Write}\ \tcurrency \proctr{\AddressI|\currency|\CWI}
  {\lambda k\ v.\ \T} \Write\ \tcurrency& \label{f.Wc}\\
&\text{\ref{f.Wc} 调用 \ref{f.a.a}}& \tilde{c},\ \tilde{a} &\vdash
  \mathbf{Write}\ \tcurrency\ A \proctr{\currency|\CWI}
  {\lambda v.\ \T} \Write\ \tcurrency\ a& \label{f.Wca}\\
&\text{\ref{f.Wca} 调用 \ref{f.SRccam}}& \begin{split}
  \tilde{c},\ \tilde{a},\ &\tilde{m},\
  \lnot P_1 \vdash \mathbf{Write}\ \tcurrency\ 
  A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M) \\&
  \quad\quad\widesim[2]{\CWI}\Write\ \tcurrency\ a\ ((\ReadZ
\ \tcurrency\ \phi\ a) - m) \end{split}& \label{f.WcaSRcam} \\
  &\text{\ref{f.Append} 调用 \ref{f.WcaSRcam}}& \begin{split}
\tilde{c},\ \tilde{a},\ &\tilde{m},\ \lnot P_1 \vdash\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\\
    & \proctr{\ListI\ \CWI|\ListI\ \CWI}{\lambda l.\ \T} 
    (\lambda l.\ (\Write\ \tcurrency\ a\ ((\ReadZ
\ \tcurrency\ \phi\ a) - m)) :: l)
  \end{split} & \label{f.LWcaSRcam1} \\
  &\text{\ref{f.LWcaSRcam1} 调用 \ref{f.Nil}}& \begin{split}
\tilde{c},\ \tilde{a},\ &\tilde{m},\ \lnot P_1 \vdash\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist\\
    & \widesim[3]{\ListI\ \CWI} [\Write\ \tcurrency\ a\ ((\ReadZ
    \ \tcurrency\ \phi\ a) - m)]
  \end{split} & \label{f.LWcaSRcam} \\
&\parbox{1.7cm}{\linespread{1}\selectfont 抽象范畴内的证明}&
P_0,\ &\lnot P_1 \vdash \ReadZ\ \tcurrency\ \phi\ b + m < \mathrm{TS}
\leq 256^{\B_\currency} & \label{f.P.addOK} \\
  &\text{\ref{f.Rcc} 调用 \ref{f.a.b}}& \tilde{c},\ \tilde{b} &\vdash 
\mathbf{Read0}\ \tcurrency\ \dot{c}\ B \widesim{\currency}
  \ReadZ\ \tcurrency\ \phi\ k & \label{f.Rccb}\\
&\text{\ref{f.Rccb} 调用 \ref{f.A}}& \begin{split}
  \tilde{c},\ \tilde{b} &\vdash \mathbf{IAdd}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B) \proctr{\currency|\currency}
{\lambda y.\ (\ReadZ\ \tcurrency\ \phi\ b) + y < 256^{\B_\currency}}\\
&(\lambda y.\ (\ReadZ\ \tcurrency\ \phi\ b) + y) \end{split} 
  &\label{f.ARccb} \\
  &\parbox{2.3cm}{\ref{f.ARccb} 调用 \ref{f.a.m} 且由
\ref{f.P.addOK}}& \tilde{c},\ \tilde{b},\ &\tilde{m},\ P_0,\ \lnot P_1
\vdash
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M \widesim{\currency} (\ReadZ\ \tcurrency\ \phi\ b) + m & 
  \label{f.ARccbm} \\
&\text{\ref{f.Wc} 调用 \ref{f.a.b}}& \tilde{c},\ \tilde{b}&\vdash 
  \mathbf{Write}\ \tcurrency\ B \proctr{\currency|\CWI}
  {\lambda v.\ \T} \Write\ \tcurrency\ b &\label{f.Wcb}\\
&\text{\ref{f.Wcb} 调用 \ref{f.ARccbm}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M) \\ & \widesim[2]{\CWI} \Write\ \tcurrency\ b\ (
(\ReadZ\ \tcurrency\ \phi\ b) + m) \end{split} &\label{f.WcbARccbm}\\
&\text{\ref{f.Append} 调用 \ref{f.WcbARccbm}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
M))\\ & \proctr{\ListI\ \CWI|\ListI\ \CWI}{\lambda l.\ \T} (\lambda l.\ 
(\Write\ \tcurrency\ b\ ((\ReadZ\ \tcurrency\ \phi\ b) + m))::l)
\end{split} & \label{f.LWcbARcbm}\\
&\text{\ref{f.LWcbARcbm} 调用 \ref{f.LWcaSRcam}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist) \\ 
  &\widesim[3]{\ListI\ \CWI} [(\Write\ \tcurrency\ b\ 
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))]
\end{split} & \label{f.LLtrans1} \\
&\text{\ref{f.Rsp} 调用 \ref{f.LLtrans1}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Cart}\ (\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)) \\ 
  &\proctr{i|\RsI\ i}{\lambda x.\ \T} (\lambda x.\ 
  ([(\Write\ \tcurrency\ b\ 
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ x))
\end{split} & \label{f.LLtrans2} \\
&\text{\ref{f.LLtrans2} 调用 \ref{f.T}}& \begin{split}
  \tilde{c},\ \tilde{b},\ &\tilde{m},\ P_0,\ \lnot P_1 
  \vdash \mathbf{Cart}\ (\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist))\ 
  \texttt{T}\\ 
  &\widesim{\RsI\ \BoolI} ([(\Write\ \tcurrency\ b\ 
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T)
\end{split} & \label{f.LLtrans} \\
&\text{\ref{f.If} 调用 \ref{f.LRccam}}& \begin{split}
  \tilde{c},\ \tilde{a},\ &\tilde{m} \vdash
  (P_1 \Rightarrow p_a \widesim{i} \epsilon_a) \Rightarrow 
  (\lnot P_1 \Rightarrow p_b \widesim{i} \epsilon_b) \Rightarrow \\
  \mathbf{If}\ &(\mathbf{ILt}\ \B_\currency\ (
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ p_a\ p_b \widesim{i} 
\xif P_1 \xthen \epsilon_a \xelse \epsilon_b \end{split}& \label{f.bc}
\\ &\text{\ref{f.Rsp} 调用 \ref{f.Nil}}&&\vdash \mathbf{Cart}\ 
\emptylist \proctr{i|\RsI\ i}{\lambda x.\ \T} (\lambda x.\ (\Nil,\ x))
& \label{f.b11}\\
&\text{\ref{f.b11} 调用 \ref{f.F}}&&\vdash \mathbf{Cart}\ 
\emptylist\ \texttt{F} \widesim{\RsI\ \BoolI} (\Nil,\ \F) 
& \label{f.b1} \\
&\text{\ref{f.bc} 调用 \ref{f.b1}}&\begin{split}
 \tilde{c},\ \tilde{a},\ &\tilde{m} \vdash
(\lnot P_1 \Rightarrow p_b \widesim{\RsI\ \BoolI} \epsilon_b)
  \Rightarrow \\&\mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\ p_b\\
  &\widesim{\RsI\ \BoolI} 
\xif P_1 \xthen (\Nil,\ \F) \xelse \epsilon_b \end{split}& \label{f.ook}
\\ &\text{\ref{f.ook} 调用 \ref{f.LLtrans}}& \begin{split}
  \tilde{c},\ \tilde{a},\ &\tilde{b},\ \tilde{m},\ P_0 \vdash 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
  \texttt{T})\\ 
  &\widesim{\RsI\ \BoolI} \xif P_1 \xthen (\Nil,\ \F) \xelse
  ([(\Write\ \tcurrency\ b\ 
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T)
\end{split} & \label{f.OK1} \\
&\text{\ref{f.OK1} 条件 $P_0$}& \begin{split}
  \tilde{c},\ \tilde{a},\ &\tilde{b},\ \tilde{m} \vdash 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
  \texttt{T})\\ 
  &\proctr{\RsI\ \BoolI}{P_0} \xif P_1 \xthen (\Nil,\ \F) \xelse
  ([(\Write\ \tcurrency\ b\ 
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),\\&\quad\quad(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T)
\end{split} & \label{f.OK2} \\
&\text{\ref{f.OK2} 抽象 $\tilde{m}$}& \begin{split}
  \tilde{c},\ \tilde{a},\ &\tilde{b} \vdash (\lambda M.\ 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
  \texttt{T}))\\ 
  &\proctr{\currency|\RsI\ \BoolI}{\lambda m.\ P_0} (\lambda m.\ 
\xif P_1 \xthen (\Nil,\ \F) \xelse ([(\Write\ \tcurrency\ b\\&
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T))
\end{split} & \label{f.OK3} \\
&\text{\ref{f.OK3} 抽象 $\tilde{b}$}& \begin{split}
  \tilde{c},\ \tilde{a},\ &\vdash (\lambda B\ M.\ 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
  \texttt{T}))\\ 
&\proctr{\AddressI|\currency|\RsI\ \BoolI}{\lambda b\ m.\ P_0} 
  (\lambda b\ m.\ 
\xif P_1 \xthen (\Nil,\ \F) \xelse ([(\Write\ \tcurrency\ b\\&
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T))
\end{split} & \label{f.OK4} \\\hline
&\text{\ref{f.OK4} 抽象 $\tilde{a}$}& \begin{split}
  \tilde{c}&\vdash (\lambda A\ B\ M.\ 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
  \texttt{T}))\\ 
&\proctr{\AddressI|\AddressI|\currency|\RsI\ \BoolI}
  {\lambda a\ b\ m.\ P_0} (\lambda a\ b\ m.\ 
\xif P_1 \xthen (\Nil,\ \F) \xelse ([(\Write\ \tcurrency\ b\\&
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T))
\end{split} & \label{f.OK5}  \\
&\text{\ref{f.OK5} 抽象 $\tilde{c}$}& \begin{split}
  &\vdash (\lambda \dot{c}\ A\ B\ M.\ 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
  \texttt{T}))\\ 
&\proctr{\OneI\ \phi|\AddressI|\AddressI|\currency|\RsI\ \BoolI}
  {\lambda \phi\ a\ b\ m.\ P_0} (\lambda \phi\ a\ b\ m.\ 
\xif P_1 \xthen (\Nil,\ \F) \xelse ([(\Write\ \tcurrency\ b\\&
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T))
\end{split} & \label{f.Final}
\end{flalign}

式 \ref{f.Final} 是最后得到的定理。式 \ref{f.Final} 的左侧是构建的程序
\[ \begin{split} &(\lambda \dot{c}\ A\ B\ M.\ 
  \mathbf{If}\ (\mathbf{ILt}\ \B_\currency\ ( 
  \mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M)\ (
  \mathbf{Cart}\ \emptylist\ \texttt{F})\\ &\quad(
  \mathbf{Cart}\ (\mathbf{Append}\ (\mathbf{Write}\ \tcurrency\ B\ (
\mathbf{IAdd}\ \B_\currency\ (\mathbf{Read0}\ \tcurrency\ \dot{c}\ B)\ 
  M)))\\&\quad\quad(\mathbf{Append}\ (
  \mathbf{Write}\ \tcurrency\ A\ (\mathbf{ISub}\ \B_\currency\ 
  (\mathbf{Read0}\ \tcurrency\ \dot{c}\ A)\ M))\ \emptylist)\ 
\texttt{T})) \end{split} \]
右将此记为 $\mathbf{Transfer}_\mathrm{p}$。侧是其对应的抽象意义
\[ \begin{split} (\lambda \phi\ a\ b\ m.\ &
\xif \ReadZ\ \tcurrency\ \phi\ a
  < M \xthen (\Nil,\ \F) \xelse ([(\Write\ \tcurrency\ b\\&
  ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
  \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))],\ \T))
\end{split} \]
将此记为 $\mathrm{Transfer}_\epsilon$。中间的 Noesis 同构符号
\[ \proctr{\OneI\ \phi|\AddressI|\AddressI|\currency|\RsI\ \BoolI}
{\lambda \phi\ a\ b\ m.\ \Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}}\]
表明了合约的参数与返回的理解，以及调用条件。
而在 \amlhS 上，理解是固定大小的，
于是也得到了此合约的各参数与返回的大小。

在以上的程序构建过程中，只有式 \ref{f.P.addOK} 涉及到 Noesis 系统外的
证明，而式 \ref{f.P.addOK} 的证明完全是在抽象范畴内的，是对抽象的数理
对象的证明而不是粗鲁地直接对程序证明。这体现了 \amlh 的思想，
{\bfseries\songti
从来不限制证明的范围——证明范围是全部的 HOL 逻辑，故而具有完整的 HOL 
逻辑的表达能力——而是通过 Noesis 对应与同构，将一切对程序的证明转化为
对抽象的数理对象的证明，以发挥所继承的 HOL 证明器的强大证明能力。}
这些抽闲的数理对象是直接的数学领域中自然
数学友好的事物，例如自然数、整数、有限域，是易于证明的。在本例中，
唯一的证明即式 \ref{f.P.addOK} 的证明是对自然数的，核心是自然数小于
与小于等于的传递律。

将调用条件记为 $P$
\[ P\ \phi \coloneqq (\Sigma\ \Ima \phi^\tcurrency = \mathrm{TS}) \]
现在证明对任意的输入，$\mathbf{Transfer}_\mathrm{p}$ 执行后
条件 $P$ 不变，即仍然满足。
为此证明关于 $\mathrm{Transfer}_\epsilon$ 的命题
\[ P\ \phi \vdash P\ (\phi \fupdates \fst(\mathrm{Transfer}_\epsilon
\ \phi\ a\ b\ m)) \]
\begin{proof} 展开 $\mathrm{Transfer}_\epsilon$，命题等价于
  \[ \begin{split} P\ \phi \vdash P\ (\phi \fupdates 
 \xif & \ReadZ\ \tcurrency\ \phi\ a < M \xthen \Nil \xelse 
  [(\Write\ \tcurrency\ b\\& ((\ReadZ\ \tcurrency\ \phi\ b) + m)),(
    \Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))])
  \end{split} \]
进一步等价于
\[ \begin{split} P\ \phi,\ \ReadZ\ \tcurrency\ \phi\ a &\geq M 
  \vdash P\ (\phi \fupdate (\Write\ \tcurrency\ b\ ((\ReadZ\ 
  \tcurrency\ \phi\ b) + m))\ \fupdate\\&
  (\Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))) 
  \end{split} \]
因为表 $\tcurrency$ 的零元素 $\tcurrency_0 = 0$ 于是
\[ \begin{split} 
  \Sigma \Ima (\phi\ &\fupdate (\Write\ \tcurrency\ b\ ((\ReadZ\ 
  \tcurrency\ \phi\ b) + m))\ \fupdate\\&
  (\Write\ \tcurrency\ a\ ((\ReadZ\ \tcurrency\ \phi\ a) - m))
  )^\tcurrency = \Sigma \Ima \phi^\tcurrency
\end{split} \]
于是命题得证。
\end{proof}

这一证明再次体现了 \amlh 的思想，不是直接证明程序的性质，而是证明程序
的抽象对应的性质；对抽象的数理对象进行证明，而不是直接证明复杂而具象的
程序代码。
