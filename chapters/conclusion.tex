\chapter{实验与比较分析}\label{Ch.conclusion}

%这种技术本身也是一种新的形式化方法，由其生产的程序具有明确的且被验证的抽象语义。
%、且易于形式化验证的
%工程实践方面，%这种技术在智能合约场景被实验。
%本文设计并实现了 允许开发者构造精简的、较高性能的智能合约，
%并显式地表达开发者的逻辑信息
%并且 \Eamlh 允许用户操作内部的 HOL 定理证明器完成最后的形式化验证。
%目前 \Eamlh 已可以生产智能合约并应用于 EOS.IO 平台。

本章首先在 \ref{Ch.example.transfer} 节实验使用本文的技术构建、验证并编译一段代币合约的转账功能。
然后在 \ref{Sec.Eamlh.concl} 节中论述工具 \Eamlh 的证明复杂度、编写复杂度，
以及 \Eamlh 编译出的智能合约的时空性能、编译结果的大小。最后在 \ref{Sec.theo.compare}
节将本文的技术与其他现有方案比较。
%进行本文的技术与其他形式化方法的比较。此外 \ref{Sec.smart-contract-compare}
%节着重将本文工作与智能合约领域中其他的形式化验证方法比较。

\input{chapters/implementation/exam_transfer.tex}
\section{工具 \Eamlh 及其编译结果的性能分析} \label{Sec.Eamlh.concl}
\subsection{证明复杂度与编写复杂度的分析}

首先编写复杂度方面，程序编写即是演绎 Noesis 逻辑上的定理。
这些定理被实现在 HOL 证明器上，HOL 证明器上的演绎律被封装为 SML 语言
上的函数，于是 Noesis 逻辑的定理演绎即是调用 HOL 证明器的演绎函数。
Noesis 逻辑的演绎律是确定的，这些演绎律实现为 \Eamlh 编辑壳层上的命令，
用户的开发行为即是从作为公理的常量与基元指令开始，引用已有的定理，
执行编辑壳层上的命令进行定理演绎，得到新的定理，如此循环。
因此 \Eamlh 上程序的编写是容易的。
%对于递归函数可能会有一点困难，不过 HOL 证明器内建了一套全自动的策略能证明大多数
%递归良好性命题（WF 命题）。目前 \Eamlh 对这些内建策略的应用还在实现中。

对于证明复杂度，
Noesis 逻辑本身只关联程序与抽象语义，从抽象语义到程序性质的证明
留给 HOL 定理证明器。
抽象语义最后到性质的证明在大多时候是简单的，毕竟抽象语义是易于分析的
数学对象并已经完整承载了用户的逻辑与意图，
且对抽象语义的证明一定比直接证明程序本身更加简单。
但的确会有一些复杂的情况，
例如用户期望实现一个图的最短路算法，而此时求解程序的抽象语义仍旧是一系列复杂的
数学函数，证明此数学函数能求解出一个图的最短路是困难的且需要数学技巧的。
但关键是，此时的命题本身已经高度抽象并涉及到专业的问题，任何别的方案也是同样困难，
甚至根本不可行的。

的确可以对一个特定的问题设计一个专用的 Model checker 以得到一个全自动的方案。但
若能构建出此 Model checker，就可以同样地按照此 Model checker 的算法在 HOL 证明器
上实现相同功能的证明策略，于是可以同样全自动地证明此类问题。
且如此实现的 Model checker 会更加容易且能力更强，因为它能得到原本程序
的代码信息的同时，还能得到额外的，承载用户逻辑信息与意图的抽象语义。
因此本文的方案是严格优于任何 Model
checker 的，因为对于任何 Model checker，此 Model checker 都可以实现为 HOL 证明器
上的策略进而纳入本文的方案中。且本文的方案提供的程序的抽象语义的对应甚至可以帮助
这些 Model checker 或者 HOL 的证明策略的编写。

最后作为总结，本文的方案以及工具 \Eamlh 可以简化形式化验证，并在很多时候简化到几乎
已经完成了验证，但 Noesis 逻辑及工具 \Eamlh 依旧无法完全解决形式化验证问题，
因为数学上已经证明不存在一个算法证明任意的命题，用户的参与与决策始终是必要的。
而本工作在程序验证方面的价值是，连结一个程序的抽象语义，帮助用户跳过具象程序与抽象数学对象的鸿沟，
使用户可以专注证明一个抽象的数学问题，而不需要考虑充满现实繁杂的具象程序。

\subsection{\Eamlh 生产的智能合约的性能分析}

从表 \ref{tab.IC.primop} 以及附录 \ref{Ch.example.transfer} 进行的实验可以清晰地看到，
抽象机 \amlhS 上基元指令的基本就是 WASM 上的基元指令，而少数无法用一个 WASM 指令实现的
\amlhS 指令也都通过调用一个执行迅速且短小的程序过程完成。
这意味着工具 \Eamlh 上的程序设计是非常接近 WASM 的，用户既可以使用
\ref{Sec.amlhS} 节最后给出的高层函数库，也可以直接使用底层的基元指令，于是
可以构造执行性能非常良好的智能合约。

值得一提的是 \Eamlh 编译出的智能合约也非常短小精简。相比而言 Agda、Idris 等
编译出的可执行文件中包含相当大部分的运行时代码，这些运行时也会被加载到内存中
并影响实际的执行性能。而 \Eamlh 编译出的智能合约尽管也需要运行时的辅助，
但这些运行时仅仅是 \ref{Sec.compile} 节论述的非常短小的内建函数，主要是对
智能合约执行平台的接口的封装以及必要的诸如内存分配函数，
只消耗很小的计算时间与运行时内存。

%演绎定理以构建程序，这不是本文的原创，而仅仅是 Curry-Howard 同构所蕴含的推论。
%Coq 系列很早就意识到了这点，并围绕此发展出程序式的证明方式
%（\textit{proof as program}）。
%但 Coq 仅仅将定理的演绎与程序的构建限定在直觉逻辑\footnote{
%或加入排中律（law of excluded middle）时扩广至经典逻辑。}与 λ 演算。
%λ 演算非常优秀也能表达几乎所有的计算逻辑，以至于人们都忽略了
%类型关系的冒号。
%
%既然是，{\it 演绎定理以构造程序}，定理就根本不只限于类型定理也自然不限于
%类型的二元关系。本文的贡献在于发现了类型关系的一种扩展，Noesis
%对应，以及相应由类型系统扩展而来的 Noesis 逻辑，并演绎 Noesis 对应与
%同构的定理以构建程序的开发方法。

\section{本文技术与其他现有方案的比较} \label{Sec.theo.compare}

比较本文工作与 \ref{Sec.contract-tools} 节中的其他工作，\Eamlh 属于一种旨在提升安全性的智能合约构建工具，
基于 \Eamlh 的形式化验证方法是一种基于定理证明器、半自动、同时分析低级与高级语言、支持分析
泛有与特有性质、可以保障到中间级别的方案。与其他基于演绎证明的方案的区别是，本文利用抽象语义能有效
降低半自动证明的困难。

该技术与依赖类型系统有较大关联，
\ref{Sec.compare.dependent} 节先着重与基于依赖类型的验证方法比较，
而后 \ref{Sec.compare.fv} 节与其余的验证方法比较。

\subsection{与依赖类型系统的比较} \label{Sec.compare.dependent}

使用依赖类型系统对智能合约验证的方案包括 Bhargavan 的 Solidity 到 \Fsharp  的翻译
\cite{bhargavan2016short}，Pettersson 的 Idris 到 EVM 的编译后端
\cite{pettersson2016safer}。

Coq 与基于依赖类型的编程语言如 Agda，Idris，\Fsharp 上开发的程序，必须同时
兼顾作为证明的理论上的简谐，与作为程序的工程实践的性能。
程序构造必须数学的同时又工程。这意味着既要把本应用于工程的程序代码
拿去做数学证明，又不能丢失作为程序的本质，必须要考虑性能与实现；
又要把本应描述数学性质的作为类型的定理拿去描述工程，还不能丢失理论
简谐性。无论哪一者都带来很多麻烦，于是这种暧昧的结果是同时损害了
工程实现的性能与用户证明的性能，特别是
工程实现的性能还要额外受制于函数式语言本身的局限。

一个典型的案例是皮亚诺加法用于工程实现的窘境。
皮亚诺数作为普遍的自然数的定义
\[ \mathbb{N} \Coloneqq 0\mbar \Suc \mathbb{N} \]
其上的加法被递归定义
\[ \begin{array}{rcl} 
n + 0 &=& n \\
n + (\Suc m) &=& (\Suc n) + m
\end{array}\]
照此递归定义直接在工程上实现显然很荒谬，对一个简单的自然数 $N$ 的加法
需要消耗$O(N)$ 的复杂度。MCMQ 的方案是将所有系统库中的自然数运算
替换为指令集上的运算或是其他标准库中或者是自己实现的 C 语言函数。
暂且不苛刻地责备这种简单干脆的替换直接割断了 Coq 对一切自然数相关的
理论证明—— C 语言上的函数与 Coq 中的自然数理论是两个事物——
而抛开了正确性不管，事实上 MCMQ 对于 C 语言整数运算溢出的处理很值得
怀疑，Coq 的世界中自然数根本没有运算溢出，于是一切 MCMQ 编译出的
程序的数值溢出问题只能依靠 MCMQ 开发者的谨慎与认真，
而数值溢出是形式化验证的基础
问题。这些都不是关键的都不去苛刻地指责，关键在于当一个用户遇到了这样
的需求尝试类似实现一个不同的自然数，一些别的有别于系统库的构造时，
他会可怕地发现递归定义无法绕过而编译而得的程序不得不消耗大量的实践。

这种构造存在，且很普遍，传统编程语言中大量使用的比特位标记
(bit flags) 是一个例子。Coq、Agda、Idris 的无法将几个比特位标记压入
整型中，因为比特位标记的构造对应于数学上的有限集，而这些语言依赖的
重写规则（rewrite rule）技术不允许位压缩。于是 Coq、Agda、Idris 可能永远
无法顺利地实现一个 IPv4 协议栈程序，除非非常艰难地绕路。

绕路可以让一些问题解决，但工程程序与数理证明之间暧昧的纠缠不清无法剪断。
如果类型关系的冒号太小了又承载了太多，就把它拉长，变成三元关系，右边也
不是定理了而是程序在抽象领域的对应，就像 Noesis 对应关系那样，把
具象的程序与抽象的数理世界划分清晰，而严谨地保持两者的映射关系，显式地
列在形式系统中而不留隐晦。本文的思路，以 Noesis 逻辑替代类型系统，
并可以同样地像 Coq 那样演绎定理以构造程序似乎很可行。

另一方面，同样的隐晦出现在以类型对程序性质的证明。
类型是一个集合，一些有某种共性的元素构成的集合而类型反映了这种共性。
既然是共性，就必定只是类型中各个实例的所有性质中的一部分，
而人们却期望使用类型表达尽可能多的性质。
类型承载的信息对于某个实例全部的性质必然是粗糙的，类型却被期望尽可能
精细。当一个类型完全表达一个值的所有性质时，此类型就只具有一个元素；
当一个类型完全表达一个值的所有开发者所关注的性质时，此类型就只具有
一个等价元素，此类型的所有实例对于开发者的关注，都是相等的。而此时
类型中唯一的等价元素，就是抽象语义。
%唯一的特例是类型中只包括一个元素，此时类型的性质完全涵盖了所有元素
%的所有特性，是精细的极致，但此时类型也失去了泛用性，自然不应被叫做类型。
值得反思类型对于编程语言本应具有的意义，与本应担当的角色，
是否强加给了类型不适合的功能，而强加的结果，是用户实际应用时的苦难。

%\amlhS
本文的 Noesis 逻辑中，理解承载共性的部分，并在 \Eamlh 中理解决定了
函数参数的位宽。理解承载的共性是通用程序与通用函数的通用性所必须的。
而抽象语义承载每一个{\phew}在某个理解下所有的性质，特别是理解的共性之外的特性，
在一个理解下每个本质不同的{\phew}都对应到不同的一个抽象语义，
此理解下的任何特性不会丢失，以允许之后对抽象语义进行任何的分析。
相比而言，对类型的分析始终只能是共性的分析，因为特性全部丢失了；
而若尝试让类型更加精细，就产生了上一段的尴尬局面。

最后作为总结，依赖类型系统的语言虽然一定程度上能证明程序实现的正确性，
但代价是昂贵的，使用类型系统去描述程序的性质这本身就不易，
而函数式的程序实现令时空性能堪忧，尽管有 MCMQ 等编译到 C 语言的方案，
但根本上的程序既要作为证明又要兼顾工程实现无法拯救程序实现的性能问题
与开发效率。
这两点问题 \Eamlh 都可以很好地解决。抽象语义完整地承载开发者的逻辑信息
与意图，进而完整地承载了值所具有的所有开发者关切的性质。另一方面，
分析与验证集中在抽象语义，程序不需要担当两个角色而
可以专注于工程实现的性能。
最后可以证明不同版本的程序实现的抽象语义是等价的，证明两个程序实现
是等价的，进而证明某一个性能优化是不影响程序正确性的。

\subsection{与其他形式化验证方法比较} \label{Sec.compare.fv}

Hirai 与 Amani 的工作\cite{hirai2017defining,amani2018towards}
与本文的比较是容易并清晰的，他们同样使用 HOL 
交互式定理证明器进行证明。但缺少抽象与逻辑信息的提取，直接使用定理
证明器分析字节码或者程序源代码必定是困难的，Amani 的工作很清晰地指出
来自高级语言表示的程序源代码提供的基础构造块信息可以有效加速证明。
本文的工作与他们的比较是 Noesis 理论完成了对程序的抽象，抽象语义完整地
承载了开发者的逻辑信息与意图，且抽象语义是易于分析的数学对象，
对抽象语义的分析与验证显然比具象而复杂的程序容易的很多。

\textsc{Oyente}\cite{luu2016making}、SASC\cite{zhou2018security}、\textsc{ZEUS}
\cite{kalra2018zeus}、\textsc{Securify}\cite{tsankov2018securify}、
MythX\cite{mythril}、Manticore\cite{Manticore}、solgraph\cite{solgraph}、
SmartCheck\cite{SmartCheck}等工具，
以及 Majan \cite{nikolic2018finding} 等人的工作均是基于 Model check。

Model checker 的问题在于，只能证明限定类型的性质而只能发现特定种类的缺陷。
如果一个形式化验证方法，仅仅是能更多地发现程序实现上潜在的缺陷，
而不能彻底地证明正确性，那问题没有被根本解决。
数学界早就证明，不存在一阶逻辑之外的证明算法，因此全自动的 Model check 不可能
解决一阶逻辑之外的问题。
于是对于更复杂的一阶逻辑外的命题，
特别是程序实现的完整证明要求证明实现与给定的形式描述的相等，
Model check 是无能为力的。

%只能说比单元测试
%好那么一点。如果缺陷不能被彻底排除，那么很难说，这种技术要求更高的
%形式化验证，相比廉价但暴力地充分地单元测试同样能够达到的保障，到底
%优势在哪里。

而且 Model check 同样面临程序代码中开发者逻辑信息的缺失。
从源程序中引入更多的逻辑信息恰是 Model check 中一种非常有效的优化手段，
SASC\cite{zhou2018security}、\textsc{ZEUS}\cite{kalra2018zeus} 的工作体现了这一点。
这也是为何本文致力于显式且完整地记录开发者的逻辑信息与意图。

事实上本文的工作与 Model check 是不冲突的，可以在本文的抽象语义层面上实现 Model check，
具体实现为 HOL 定理证明器上的策略。而如此实现的 Model check 能够获得显式的、且被保障的
程序的逻辑信息与意图，并同时也能得到原始的程序代码以及编译后的中间表达，这样的 Model
check 能获得的信息显著且严格大于传统方法的，因此能比传统方法的 Model check 实现更好
的效果。

%K Framework\cite{rosu2010overview,KFramework.soft} 的问题在这里，它非常优秀，
%是一个非常强大的形式语义的语言框架。
%但问题它不是一个交互式定理证明器，因此无法证明所有的问题。
%它可以由形式语义生成非常有效的 model checker，
%但永远只能证明有限的特定的性质。实际上
%K Framework 和本文的工作致力于做不同的事情。

%对于其他将源代码演绎到定理证明器来完成的形式化验证，
%据我所知道都经历了相当的辛劳，
%如 SeL4 内核的验证。这些方法难以推广于普遍工业界。

%\subsection{用于程序设计的形式化方法的比较}
%
%最后一块未谈及的形式化方法的领域是以 Z 记号\cite{Znotation}与 VDM 闻名的用于辅助设计的
%形式化方法，特别是形式化描述（Formal Specification）。
%
%这一节首先要讨论的是 \amlh 的表述能力。\amlh 将作为{\phew}的程序由理解对应
%到抽象的抽象语义，抽象语义是用高阶逻辑描述的。理论上高阶逻辑能够表达几乎所有的
%数学问题。但如果数学逻辑能表达计算机世界所有的描述，那 Z 记号与 VDM 
%就不会有存在的理由。这是难以断言的，也许不得不承认直接使用数学逻辑描述
%计算机上的事务是有局限的。有关这些的结论只能交由实践的检验，只能交给
%未来工作，也许很多抽象抽象语义上的模型是非常值得设计的。
%
%不过对于现状，对一个致力于彻底证明程序实现正确性的工作，不应这样地苛求，
%就像不应质疑依赖类型语言不得不用构造演算或者直觉主义逻辑来描述作为类的
%值的性质，而不是别的什么自然语言。
%
%\section{智能合约的相关形式化验证的比较} \label{Sec.smart-contract-compare}
%
%
%Hirai 的方案 \cite{hirai2017defining} 是典型的将目标语言翻译装入另一个
%定理证明器的方法。尽管 Hirai 是将 EVM 定义而削除了翻译正确性的问题。
%但直接对用于工程的程序代码进行分析势必困难重重，Hirai 消耗了 5000 行
%证明代码与 3 个小时去验证只有 501 个指令的合约。
%本文已经一而再再而三地强调不应直接对程序代码分析而是对代码的意义对应的抽象对象分析。
%就像之后 Amani 对 Hirai 的工作优化时得出的结论，源自编译前的源代码的高层
%信息非常重要 \cite{amani2018towards}。
%Amani 通过程序的基础构造块结构提升了验证的性能，但这只是
%治标不治本，对于更复杂的程序，特别是那些有抽象意义的例如一个图的最短路
%求解算法，显然从程序代码开始的证明难以想象地困难。
%
% Abdellatif 考察智能合约平台上用户的行为并用形式模型建模以形式地分析验证
%，进而验证智能合约的协议模型 \cite{abdellatif2018formal}。
% Dey 也尝试用博弈论分析智能合约 \cite{dey2018securing}。
%他们的思路是非常好的。
%在本文的情况可以基于智能合约的抽象抽象语义建立博弈论模型，彻底地分析智能合约
%在诸如矿工作弊、日食攻击时的情况。并同样地建立智能合约的完整的模型，
%也许能彻底证明智能合约的实现之外，其设计的正确性，而在 Noesis 对应的
%纽带联系下得到智能合约的设计与实现的完整的正确性。这些想象非常激动人心，
%尽管本文尚未着手探索，这些都是未来工作。
%
%此外 Hildenbrandt 基于 K Framework 构建了 EVM 的 KEVM 
%\cite{hildenbrandt2018kevm}，关于 K Framework 的讨论已在\ref{Sec.compare.fv}节进行。


\chapter{结语与未来展望}

本文最终得到了一种生产相对易于形式化验证的智能合约开发技术，软件工具 \Eamlh 是该技术的实现，
允许并要求开发者在构造智能合约时显式并完整地表达逻辑信息与意图于抽象语义中，
并利用抽象语义有效地简化并完成形式化验证，
最终生产精简的、较高执行性能的可应用于 EOS.IO 的智能合约。

论文已经在智能合约上开展了实际测试与应用。
%的方法已经开始积极地实践，工具 \Eamlh 已用于实际工程的检验。
目前 \Eamlh 已包括 4867 行的 HOL 交互式证明系统上的 SML 语言，与 9907 
行的编辑壳层
与外部编译器以及测试代码的 Crystal 语言\cite{CrystalLang}。
总共 433 次版本仓库的提交与 33 个分支中，共计
增删代码 $2\,780\,207$ 行次，包括 $1\,400\,834$ 行的添加与 $1\,379\,373$
行的删除，在各个分支中最后留存总计 $21\,461$ 行。分支与分支间有大量共享
代码故总代码行数不等于分支数乘以单个分支留存的代码行数。图 
\ref{fig:works} 列出了这些数据的统计方法。

不得不说，大量的工作有待完成。一些非常关键的问题还未透彻，有没有更好的
规范的方法处理递归与循环；能否基于历史流来处理状态而不需要将计算与状态
分离，以允许真正的有状态；编辑壳层需要更形式地论述，编辑壳层的类型系统
的一致性与完备性需要修复；编辑壳层需要真正地易用，需要将逻辑可视化。
还有许多工作需要进行。
%等等等等，这是一条漫长的道路。

\begin{figure}[p]
\caption{本工作的数据统计} \label{fig:works}
\begin{minted}{console}
# 主分支的代码量
$ cloc src --vcs=git
     134 text files.
     134 unique files.                                          
       6 files ignored.
----------------------------------------------------------------------
Language            files          blank        comment           code
----------------------------------------------------------------------
Crystal                69           1194            499           9413
Standard ML            63            575            721           4867
Markdown                1              7              0             18
----------------------------------------------------------------------
SUM:                  133           1776           1220          14298
----------------------------------------------------------------------
# 总提交数
$ git rev-list --all --count
433
# 总分支数
$ git branch | wc -l                    
33
# 总修改量
$ git log  --pretty=tformat: --numstat \
| gawk '{ add += $1; subs += $2; loc += $1 - $2 } END \
{ printf "added lines: %s removed lines: %s total lines: %s\n",\
add, subs, loc }' -
added lines: 1400834 removed lines: 1379373 total lines: 21461
\end{minted}
\end{figure}
