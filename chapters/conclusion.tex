\chapter{结论与比较}\label{Ch.conclusion}

演绎定理以构建程序，这不是本文的原创，而仅仅是 Curry-Howard 同构所蕴含的小小推论。
Coq 系列很早就意识到了这点，并围绕此发展出程序式的证明方式
（\textit{proof as program}）。
但 Coq 仅仅将定理的演绎与程序的构建限定在直觉逻辑\footnote{
或加入排中律（law of excluded middle）时扩广至经典逻辑。}与 λ 演算。
λ 演算非常优秀也能表达几乎所有的计算逻辑，以至于人们都忽略了
类型关系那小小的冒号。

既然是，{\it 演绎定理以构造程序}，定理就根本不只限于类型定理也自然不限于
类型的二元关系。本文梦幻的贡献在于发现了类型关系的一种扩展，Noesis
对应，以及相应由类型系统扩展而来的 Noesis 系统，并演绎 Noesis 对应与
同构的定理以构建程序的开发方法。

\section{与依赖类型系统的比较}

Coq 与基于依赖类型的编程语言如 Agda，Idris，F*，它们非常优秀，但始终处于
理论证明工具与程序开发工具的暧昧不清之间。于其上开发的程序，必须同时
兼顾作为证明的理论上的简谐，与作为程序的工程实践的性能。
程序构造必须数学的同时又工程。这意味着既要把本应用于工程的程序代码
拿去做数学证明，又不能丢失作为程序的本质，必须要考虑性能与实现；
又要把本应描述数学性质的作为类型的定理拿去描述工程，还不能丢失理论
简谐性。无论哪一者都带来很多麻烦，于是这种暧昧的结果是同时损害了
工程实现的性能与用户证明的性能，特别是
工程实现的性能还要额外受制于函数式语言本身的局限。

一个典型的案例是皮亚诺加法用于工程实现的窘境。
皮亚诺数作为普遍的自然数的定义
\[ \mathbb{N} \Coloneqq 0\mbar \Suc \mathbb{N} \]
其上的加法被递归定义
\[ \begin{array}{rcl} 
n + 0 &=& n \\
n + (\Suc m) &=& (\Suc n) + m
\end{array}\]
照此递归定义直接在工程上实现显然很荒谬，对一个简单的自然数 $N$ 的加法
需要消耗$O(N)$ 的复杂度。MCMQ 的方案是将所有系统库中的自然数运算
替换为指令集上的运算或是其他标准库中或者是自己实现的 C 语言函数。
暂且不苛刻地责备这种简单干脆的替换直接割断了 Coq 对一切自然数相关的
理论证明——C 语言上的函数与 Coq 中的自然数理论是两个事物——
而抛开了正确性不管，事实上 MCMQ 对于 C 语言整数运算溢出的处理很值得
怀疑，Coq 的世界中自然数根本没有运算溢出于是一切 MCMQ 编译出的
程序的数值溢出问题只能依靠 MCMQ 开发者的谨慎与认真，
而数值溢出是形式化验证的基础
问题。这些都不是关键的都不去苛刻地指责，关键在于当一个用户遇到了这样
的需求尝试类似实现一个不同的自然数，一些别的有别于系统库的构造时，
他会可怕地发现递归定义无法绕过而编译而得的程序不得不消耗大量的实践。

这种尴尬的构造存在，且很普遍，就是传统编程语言中大量使用的比特位标记
(bit flags)。Coq、Agda、Idris 的思想是无法将几个比特位标记压入小小的
整型中，因为比特位标记的构造对应于数学上的有限集，而这些语言依赖的
重现规则（rewrite rule）不允许位压缩。于是 Coq、Agda、Idris 可能永远
无法顺利地实现一个 IPv4 协议栈程序，除非非常艰难地绕路。

绕路可以让一些问题解决，但工程程序与数理证明之间暧昧的纠缠不清无法剪断。
如果类型关系的冒号太小了又承载了太多，就把它拉长，变成三元关系，右边也
不是定理了而是程序在抽象领域的对应，就像 Noesis 对应关系那样，把
具象的程序与抽象的数理世界划分清晰，而严谨地保持两者的映射关系，显示地
列在形式系统中而不留隐晦。本文的思路，以 Noesis 系统替代类型系统，
并可以同样地像 Coq 那样演绎定理以构造程序似乎很可行。

另一方面，同样的隐晦出现在以类型对程序性质的证明。
类型是一个集合，一些有某种共性的
元素构成的集合而类型反映了这种共性。既然是共性，就必定只是类型中
各个实例的所有特性的一小部分，而人们却期望用类型体现尽可能多的性质。
类型承载的信息对于某个实例全部的特性必然是粗糙的，类型却被期望尽可能
精细。唯一的特例是类型中只包括一个元素，此时类型的性质完全涵盖了所有元素
的所有特性，是精细的极致，但此时类型也失去了泛用性，自然不应被叫做类型。
值得反思类型对于编程语言本应的意义，是否强加给了类型不适合的角色，
而强加的结果，是用户实际证明时的苦难。

本文的 Noesis 系统中，理解承载共性的部分，并在 \amlhS 中理解决定了
函数参数的位宽。理解承载的共性是通用程序与通用函数的通用性所必须的。
而本体承载每一个现象在某个理解下所有的性质，特别是理解的共性之外的特性，
在一个理解下每个本质不同的现象都对应到不同的一个本体，
此理解下的任何特性不会丢失，以允许之后对本体进行任何的分析。
相比而言，对类型的分析始终只能是共性的分析，因为特性全部丢失了；
而若尝试让类型更加精细，就产生了上一段的尴尬局面。

最后作为总结，依赖类型系统的语言虽然一定程度上能证明程序实现的正确性，
但代价是昂贵的，使用类型系统去描述程序的性质这本身就不易，
而函数式的程序实现令时空性能堪忧，尽管有 MCMQ 等编译到 C 语言的方案，
但根本上的程序即要作为证明又要兼顾工程实现无法拯救程序实现的性能问题
与开发效率。

\section{与其他形式化验证方法比较}

如果一个形式化验证方法，仅仅是能更多地发现程序实现上潜在的缺陷，
而不能彻底地证明正确性，那问题就根本没有被解决。只能说比单元测试
好那么一点。如果缺陷不能被彻底排除，那么很难说，这种技术要求更高的
形式化验证，相比廉价但暴力地充分地单元测试同样能够达到的保障，到底
优势在哪里。

而对于程序实现的彻底证明，我不认为有任何全自动的方法，这显然不是一个
一阶逻辑上的问题，数学界早就证明，不存在一阶逻辑之外的万能的证明算法。
因此要能彻底地证明程序的实现，一定要通过一个交互式定理证明器，
否则一切就太困难。

K Framework\cite{rosu2010overview,KFramework.soft} 的问题在这里，它非常优秀，
是一个非常强大的形式语义的语言框架。
但问题它不是一个交互式定理证明器，它可以由形式语义生成
非常有效的 model checker，但永远只能证明有限的特定的性质。实际上
K Framework 和本文的工作致力于做不同的事情。

对于其他基于定理证明器完成的形式化验证，据我所知道都经历了相当的辛劳，
如 SeL4 内核的验证。这些方法难以推广于普遍工业界。

\section{用于程序设计的形式化方法}

最后一块未谈及的形式化方法的领域是以 Z 记号\cite{Znotation}与 VDM 闻名的用于辅助设计的
形式化方法，特别是形式化描述（Formal Specification）。

这一节首先要讨论的是 \amlh 的表述能力。\amlh 将作为现象的程序由理解对应
到抽象的本体，本体是用高阶逻辑描述的。理论上高阶逻辑能够表达几乎所有的
数学问题。但如果数学逻辑能表达计算机世界所有的描述，那 Z 记号与 VDM 
就不会有存在的理由。这是难以断言的，也许不得不承认直接使用数学逻辑描述
计算机上的事务是有局限的。有关这些的结论只能交由实践的检验，只能交给
未来工作，也许很多抽象本体上的模型是非常值得设计的。

不过对于现状，对一个致力于彻底证明程序实现正确性的工作，不应这样地苛求，
就像不应质疑依赖类型语言不得不用构造演算或者直觉主义逻辑来描述作为类的
值的性质，而不是别的什么自然语言。

\section{智能合约的相关形式化验证}

 Bhargavan 将 EVM 字节码与 Solidity 源代码被验证地翻译到 F* 语言上，
 以利用 F* 的依赖类型证明智能合约的性质 \cite{bhargavan2016short}。
 关于依赖类型语言与本文工作的比较已在前几节进行了。
 Pettersson 使用 Idris 对以太坊智能合约的尝试也是类似工作 \cite{pettersson2016safer}。

Hirai 的方案 \cite{hirai2017defining} 是典型的将目标语言翻译装入另一个
定理证明器的方法。尽管 Hirai 是将 EVM 定义而削除了翻译正确性的问题。
但直接对用于工程的程序代码进行分析势必困难重重，Hirai 消耗了 5000 行
证明代码与 3 个小时去验证只有 501 个指令的合约。
本文已经一而再再而三地强调不应直接对程序代码分析而是对代码的意义对应的抽象对象分析。
就像之后 Amani 对 Hirai 的工作优化时得出的结论，源自编译前的源代码的高层
信息非常重要 \cite{amani2018towards}。
Amani 通过程序的基础构造块结构提升了验证的性能，但这只是
治标不治本，对于更复杂的程序，特别是那些有抽象意义的例如一个图的最短路
求解算法，显然从程序代码开始的证明难以想象地困难。

 Abdellatif 考察智能合约平台上用户的行为并用形式模型建模以形式地分析验证
，进而验证智能合约的协议模型 \cite{abdellatif2018formal}。
 Dey 也尝试用博弈论分析智能合约 \cite{dey2018securing}。
他们的思路是非常好的。
在本文的情况可以基于智能合约的抽象本体建立博弈论模型，彻底地分析智能合约
在诸如矿工作弊、日食攻击时的情况。并同样地建立智能合约的完整的模型，
也许能彻底证明智能合约的实现之外，其设计的正确性，而在 Noesis 对应的
纽带联系下得到智能合约的设计与实现的完整的正确性。这些想象非常激动人心，
尽管本文尚未着手探索，这些都是未来工作。

此外 Hildenbrandt 基于 K Framework 构建了 EVM 的 KEVM 
\cite{hildenbrandt2018kevm}，关于 K Framework 的讨论已在前一节进行。


\section{结语与未来展望}

本文期望本文完成了本文的期望，一种廉价而有效可行的开发正确性被证明的
程序实现的方法。它代价不高, 不消耗大量的开发成本, 只需要
专业的数学知识与机器证明技能, 而本身施行起来不复杂不困难, 
进而能被普遍地应用在现实的普通工业生产中；
但却能有效而彻底地证明程序实现的正确性。本文期望 \amlh 是这样的方法，
但最终只有实践能下此定论。

本文的方法已经开始积极地实践，所有的工具链都已完成并开始以工程的检验。
这些实现包括 4867 行的 HOL 交互式证明系统上的 SML 语言，与 9907 编辑壳层
与外部编译器以及测试代码的 Crystal 语言\cite{CrystalLang}。
总共 433 次版本仓库的提交与 33 个分支中，共计
增删代码 $2\,780\,207$ 行次，包括 $1\,400\,834$ 行的添加与 $1\,379\,373$
行的删除，在各个分支中最后留存总计 $21\,461$ 行。分支与分支间有大量共享
代码故总代码行数不等于分支数乘以单个分支留存的代码行数。图 
\ref{fig:works} 列出了这些数据的统计方法。

不得不说，大量的工作有待完成。一些非常关键的问题还未透彻，有没有更好的
规范的方法处理递归与循环；能否基于历史流来处理状态而不需要将计算与状态
分离，以允许真正的有状态；编辑壳层需要更形式地论述，编辑壳层的类型系统
的一致性与完备性需要修复；编辑壳层需要真正地易用，需要将逻辑可视化。
等等等等，这是一条漫长的道路。

\begin{figure}[p]
\caption{本工作的数据统计} \label{fig:works}
\begin{minted}{console}
# 主分支的代码量
$ cloc src --vcs=git
     134 text files.
     134 unique files.                                          
       6 files ignored.
----------------------------------------------------------------------
Language            files          blank        comment           code
----------------------------------------------------------------------
Crystal                69           1194            499           9413
Standard ML            63            575            721           4867
Markdown                1              7              0             18
----------------------------------------------------------------------
SUM:                  133           1776           1220          14298
----------------------------------------------------------------------
# 总提交数
$ git rev-list --all --count
433
# 总分支数
$ git branch | wc -l                    
33
# 总修改量
$ git log  --pretty=tformat: --numstat \
| gawk '{ add += $1; subs += $2; loc += $1 - $2 } END \
{ printf "added lines: %s removed lines: %s total lines: %s\n",\
add, subs, loc }' -
added lines: 1400834 removed lines: 1379373 total lines: 21461
\end{minted}
\end{figure}
