\chapter{结论与比较}

{\it 演绎定理以构建程序，}

这不是本文的原创，而仅仅是 Curry-Howard 同构所蕴含的小小推论。
Coq 系列很早就意识到了这点，并围绕此发展出程序式的证明方式
（\textit{proof as program}）。
但 Coq 仅仅将定理的演绎与程序的构建限定在直觉主义类型与 λ 演算。
λ 演算非常优秀也能表达几乎所有的计算逻辑，以至于人们都忽略了
类型关系那小小的冒号。

既然是，{\it 演绎定理以构造程序}，定理就根本不只限于类型定理也自然不限于
类型的二元关系。本文最梦幻的贡献在于找到了类型关系的一种扩展，Noesis
对应，以及相应由类型系统扩展而来的 Noesis 系统，并演绎 Noesis 对应与
同构的定理以构建程序的开发方法。

\section{与依赖类型系统的比较}

Coq 与基于依赖类型的编程语言如 Agda，Idris，它们非常优秀，但始终处于
理论证明工具与程序开发工具的暧昧不清之间。于其上开发的程序，必须同时
兼顾作为证明的理论上的简谐，与作为程序的工程实践的性能。
程序构造必须数学的同时又工程。这意味着既要把本应用于工程的程序代码
拿去做数学证明，又不能丢失作为程序的本质，必须要考虑性能与实现；
又要把本应描述数学性质的作为类型的定理拿去描述工程，还不能丢失理论
简谐性。无论哪一者都带来很多麻烦，于是这种暧昧的结果是同时损害了
工程实现的性能与用户证明的性能，特别是
工程实现的性能还要额外受制于函数式语言本身的局限。

一个典型的案例是皮亚诺加法用于工程实现的窘境。
皮亚诺数作为普遍的自然数的定义
\[ \mathbb{N} \Coloneqq 0\mbar \Suc \mathbb{N} \]
其上的加法被递归定义
\[ \begin{array}{rcl} 
n + 0 &=& n \\
n + (\Suc m) &=& (\Suc n) + m
\end{array}\]
照此递归定义直接在工程上实现显然很荒谬，对一个简单的自然数 $N$ 的加法
需要消耗$O(N)$ 的复杂度。MCMQ 的方案是将所有系统库中的自然数运算
替换为指令集上的运算或是其他标准库中或者是自己实现的 C 语言函数。
暂且不苛刻地责备这种简单干脆的替换直接割断了 Coq 对一切自然数相关的
理论证明——C 语言上的函数与 Coq 中的自然数理论是两个事物——
而抛开了正确性不管，事实上 MCMQ 对于 C 语言整数运算溢出的处理很值得
怀疑，Coq 的世界中自然数根本没有运算溢出于是一切 MCMQ 编译出的
程序的数值溢出问题只能依靠 MCMQ 开发者的谨慎与认真，
而数值溢出是形式化验证的基础
问题。这些都不是关键的都不去苛刻地指责，关键在于当一个用户遇到了这样
的需求尝试类似实现一个不同的自然数，一些别的有别于系统库的构造时，
他会可怕地发现递归定义无法绕过而编译而得的程序不得不消耗大量的实践。

这种尴尬的构造存在，且很普遍，就是传统编程语言中大量使用的比特位标记
(bit flags)。Coq、Agda、Idris 的思想是无法将几个比特位标记压入小小的
整型中，因为比特位标记的构造对应于数学上的有限集，而这些语言依赖的
重现规则（rewrite rule）不允许位压缩。于是 Coq、Agda、Idris 可能永远
无法顺利地实现一个 IPv4 协议栈程序，除非非常艰难地绕路。

绕路可以让一些问题解决，但工程程序与数理证明之间暧昧的纠缠不清无法剪断。
如果类型关系的冒号太小了又承载了太多，就把它拉长，变成三元关系，右边也
不是定理了而是程序在抽象领域的对应，就像 Noesis 对应关系那样，把
具象的程序与抽象的数理世界划分清晰，而严谨地保持两者的映射关系，显示地
列在形式系统中而不留隐晦。本文的思路，以 Noesis 系统替代类型系统，
并可以同样地像 Coq 那样演绎定理以构造程序似乎很可行。

另一方面，同样的隐晦出现在以类型对程序性质的证明。
类型是一个集合，一些有某种共性的
元素构成的集合而类型反映了这种共性。既然是共性，就必定只是类型中
各个实例的所有特性的一小部分，而人们却期望用类型体现尽可能多的性质。
类型承载的信息对于某个实例全部的特性必然是粗糙的，类型却被期望尽可能
精细。唯一的特例是类型中只包括一个元素，此时类型的性质完全涵盖了所有元素
的所有特性，是精细的极致，但此时类型也失去了泛用性，自然不应被叫做类型。
值得反思类型对于编程语言本应的意义，是否强加给了类型不适合的角色，
而强加的结果，是用户实际证明时的苦难。

本文的 Noesis 系统中，理解承载共性的部分，并在 \amlhS 中理解决定了
函数参数的位宽。理解承载的共性是通用程序与通用函数的通用性所必须的。
而本体承载每一个现象在某个理解下所有的性质，特别是理解的共性之外的特性，
在一个理解下每个本质不同的现象都对应到不同的一个本体，
此理解下的任何特性不会丢失，以允许之后对本体进行任何的分析。
相比而言，对类型的分析始终只能是共性的分析，因为特性全部丢失了；
而若尝试让类型更加精细，就产生了上一段的尴尬局面。



本文期望本文完成了本文的期望，一种廉价而有效可行的开发正确性被证明的
程序实现的方法。它代价不高, 不消耗大量的开发成本, 只需要
专业的数学知识与机器证明技能, 而本身施行起来不复杂不困难, 
进而能被普遍地应用在现实的普通工业生产中；
但却能有效而彻底地证明程序实现的正确性。本文期望 \amlh 是这样的方法，
但最终只有实践能下此定论。

本文的方法已经开始积极地实践，所有的工具链都已完成并开始以工程的检验。
这些实现包括 4867 行的 HOL 交互式证明系统上的 SML 语言，与 9907 编辑壳层
与外部编译器以及测试代码的 Crystal 语言。
总共 433 次版本仓库的提交与 33 个分支中，共计
增删代码 $2\,780\,207$ 行次，包括 $1\,400\,834$ 行的添加与 $1\,379\,373$
行的删除，在各个分支中最后留存总计 $21\,461$ 行。分支与分支间有大量共享
代码故总代码行数不等于分支数乘以单个分支留存的代码行数。图 
\ref{fig:works} 列出了这些数据的统计方法。

\begin{figure}[p]
\caption{本工作的数据统计} \label{fig:works}
\begin{minted}{console}
# 主分支的代码量
$ cloc src --vcs=git
     134 text files.
     134 unique files.                                          
       6 files ignored.
----------------------------------------------------------------------
Language            files          blank        comment           code
----------------------------------------------------------------------
Crystal                69           1194            499           9413
Standard ML            63            575            721           4867
Markdown                1              7              0             18
----------------------------------------------------------------------
SUM:                  133           1776           1220          14298
----------------------------------------------------------------------
# 总提交数
$ git rev-list --all --count
433
# 总分支数
$ git branch | wc -l                    
33
# 总修改量
$ git log  --pretty=tformat: --numstat \
| gawk '{ add += $1; subs += $2; loc += $1 - $2 } END \
{ printf "added lines: %s removed lines: %s total lines: %s\n",\
add, subs, loc }' -
added lines: 1400834 removed lines: 1379373 total lines: 21461
\end{minted}
\end{figure}

\section{与现有形式化方法的比较}

第 \ref{Sec.formal_method} 节已经介绍了三类流行的形式化方法，本节
将一一比较。

第一类 model checker 式的，因为有限的表达能力与证明能力不在讨论范围中。

第二类尝试将程序翻译到另一个证明系统中并以此证明的，它们的缺陷已经在 
\ref{Sec.formal_method} 节论述过了。困难的证明与可疑的翻译正确性。

必须讨论的是著名的 K Framework。

第三类基于依赖系统的，它们非常优秀，本文将一一讨论。


