\chapter{背景技术描述}
\section{本发明所属技术领域}
形式化方法与编程语言，特别是形式化验证领域与类型系统。
具体设计了一种类型系统的扩广，即 Noesis 形式系统，并使用 Noesis
形式系统构建正确性被彻底证明的程序实现的方法。
\section{该行业的技术发展现状}

软件开发的主要挑战是在有限而可控的的时间与经费预算下开发高质量的软件
\cite{DinesSE1, brooks1995mythical}。
大量的方法提出以提升软件工程的效率与产品的质量
\cite{DinesSE1, SoftwareQuality}。
形式化方法（formal method）也可有效地应用于此，
以提升软件质量，并辅助软件的开发以提升开发效率\cite{formal_method_view1} 。
实际上大量的形式化方法已经在实际地发挥作用\cite{pierce2002types, jackson2012software}。

其中重要的一点是程序实现的验证，即一实现是否正确实现了设计的全部功能，且
不具有违背设计的包括漏洞在内的任何缺陷。
传统的单元测试难以发掘程序的全部潜在缺陷，
而相比而言形式化验证可以更有效地验证程序实现而发现更多的缺陷
\cite{formal_method_view1}。
但问题在于，倘若某种可行的形式化验证仅仅是更有效而并非是彻底，
即被验证后的程序实现依旧可能存在种种缺陷，
那这种形式化验证只能称之为比传统测试更好，
但问题仍未被彻底解决，仍然不能说一个实现是对于设计正确的满足而无任何缺陷。

软件的正确性包括其设计的正确性与程序实现的正确性。
软件的设计可能有缺陷，也许难以预见而难以检验，
但是否有可能一个程序的实现是彻底正确而无缺陷地满足了其设计？
进而能否验证一个程序是否被正确实现？
再而能否构造正确实现的而无任何缺陷的程序，
即所谓被验证的程序（verified software）\cite{verified_soft_grand}？

这一点具有实际的意义。
特别是在安全严苛（Safety critical）\cite{DinesSE1}的场景上尤其紧要。
有太多的计算机硬件与软件系统直接与生命安全、重要的民生事务相关。

%本工作聚焦的基于区块链技术的各种智能合约平台就是这样的安全严苛场景。
%因为区块链技术与平台的特殊性，被叫做智能合约的程序一旦被部署往往就无法修改，
%进而无法更新以修复任何部署前未被发现的缺陷 \cite{swan2015blockchain}。
%而目前区块链技术与智能合约平台大量应用于金融领域，如 Bitcoin 等诸多的
%加密货币\cite{narayanan2016bitcoin}，与加密金融这一新领域\cite{came2019}。
%短短的数年以来智能合约领域已有大量的缺陷案例\cite{atzei2016survey}。
%这些缺陷往往会导致严重的经济损失 cite???。
%这些案例中，软件的设计往往是正确的而因为程序错误的实现而造成了损失。
%这凸显了验证程序实现的重要性。

程序实现是否是可以彻底正确而无任何缺陷的？大规模的程序实现是否可以
彻底正确？能否有效地开发彻底正确的程序实现？

我们不能因为过往与眼前经受的种种困难就放弃，而轻易地留下一句
“这始终是一门发展的学科而程序亦始终在发展而不存在完美的一刻”，
以对一切草草了事。
一个程序实现是否可以是彻底正确的，这一问题事关计算机科学作为科学的严谨
性。若一个科学，连其主要研究对象的正确性都无法自信地断言，这就动摇了
其作为科学的基础。需要一个认真的回答，而如果无法回答，那就是计算机科学
研究领域重要的空缺。将程序开发视作一个发展的过程而因此忽视程序实现正确性
的证明，这是自我开脱。

对正确而无缺陷的程序实现及这种开发方法的追求并非是痴人说梦。
1967年 Floyd 的论文就清晰地旨在寻找一种严格的对程序证明
包括正确性证明与停机性证明的方案\cite{floyd1967}。
2009 年 SeL4 系统内核被成功地形式化验证，
完整地证明了其程序实现的正确性。

以 Hoare 与 Milner 的话说，
这是计算科学界的“伟大挑战”（Grand challenge in computing research）
\cite{hoare2004grand, hoare2006ideal}。
众多的支持文章从不同角度涌现：“具有验证功能的编译器”（verifying compiler）
\cite{verifying_compiler}，“被验证的软件”（verified software）
\cite{verified_soft_grand}，“可依赖的系统演化”（Dependable Systems Evolution）
\cite{Dependable_Systems_Evolution_grand}。

然而相比数理逻辑的简洁，现实的需求是如此复杂，系统具有如此多的细节，
形式化模型难以描述这些，而对其进行分析就更加困难，
就意味着更加巨大的资源投入与消耗\cite{jackson2012software}。


%本文追求这一点，一种能严谨证明程序实现的正确性的，切实工业界可行的
%形式化方法。

\section{工业实践中彻底证明程序实现正确性的困难(现有技术中存在的缺陷)} \label{Sec.formal_method}

现代编程语言基本都是形式语言，编程语言上的程序是这一形式语言上的表达，
而类型系统是编程语言上的形式系统，类型系统本身就是一种形式化方法，
它对程序的分析与推断构成了对程序的形式化验证。

类型系统属于形式化方法中的 model checker。model checker 全自动地
分析检查程序是否满足声明的性质。
但类型系统与各种 model checker 的通病是，其形式语言的表达能力往往是
有限的，只能表达有限的性质进而只能推导与证明这些有限的，就
只能削除有限种类的缺陷，大量别的缺陷依旧可能存在，
程序实现的正确性无法被彻底证明。
这就是为什么这个世界的形式化方法这一领域还依旧活跃
并存在如此多的问题尚未解决。

基于此学界有多个思路以解决。第一种思路力图保留 Model checker 简单易用
的良好特性而有限地加强 model checker 的功能，例如采用覆盖面更广表达能力
更强的模型，例如 refinement type。这种思路依旧是无法彻底证明程序实现
正确性的，故在本文的目标下全都一笔带过。

第二种思路尝试将编程语言上的程序装入另一个表达能力更强的证明系统，
即将程序翻译进另一个证明系统以此完成原本类型系统无法触及的，
对程序实现正确性的证明。
这有诸多困难，首先程序到证明系统的翻译必须正确，既然是形式化证明
而非主观臆测的断言这翻译就必须被证明，这并不容易。其次
在一种形式语言上的程序翻译到另一个证明系统内，其表达一定会更加复杂。
根本上，程序验证的困难来自于编程语言一开始就未考虑证明而
仅针对程序的执行，将程序翻译到证明系统中除了增加复杂并不能使
程序更易于证明，因为根本的问题并未得到解决。

著名的 seL4 内核的形式化验证是这种思路的代表，
仅8700行的C语言与600行的汇编语言的程序被翻译到Isabelle/HOL 证明系统上
去形式化验证，最后生成了200,000行 Isabelle 代码并消耗
20人年才得以完成\cite{klein2009sel4}。

简化程序形式化验证的困难一定要从编程语言上着手，一开始就未考虑到证明
难度的编程语言上的程序一定是难以证明的。

第三种思路围绕依赖类型（Dependent typed system）踩在了点上。
Curry–Howard 同构\cite{sorensen2006lectures} 揭示了程序与证明的内在关联，而后的
构造演算（Calculus of Construction, CoC）可以同时作为数学的基础与程序的基础，
于是可以同时用于构建程序与定理证明，
其类型系统等价于完整的数学逻辑（具体而言，经典逻辑或者直觉主义逻辑），
几乎可以表达所有性质，进而可以彻底证明程序的正确性。
事实上，依赖类型系统本身已经接近定理证明工具。
Coq\cite{coq.itp}, Agda\cite{norell2008dependently}, Idris\cite{brady2013idris}
，是其中的代表，而 Coq 就是一种定理证明工具。
依赖类型系统本身作为一个数学理论是完美而梦幻的，但其中的程序不得不同时扮演作为工程
实现的角色与定理的证明过程，程序开发者需要写下一份文本而同时有两个相悖的角色，
有良好的工程实现的性能又具有巧妙的数学灵性，以易于证明而完成证明。
这是非常困难并在一些场合上不可能的，在现实中一人分饰两角都称得上精彩的戏剧了。
最后一章结论部分本文细致地分析。
此外，即便一个天才的程序员成功让作为数学证明的程序兼顾了工程实现的性能，
但高度抽象的类型系统自身将掐断他的希望。
依赖类型的编程语言首先一定是函数式的，而近百年尝试的结果是函数式编程语言，
因为性能包括空间性能与时间性能，然后是易用性等种种原因，
从一度占据的编程语言界的王座上退让下来而留下了
被过程式编程语言统治的软件工业界。各种现代的函数式语言费劲功力尽力优化，但仍无法企及
Java 等高度抽象的过程式语言，更不用说 C 语言。
而依赖类型系统的语言更难以应用所有这些优化。
尽管有一些诸如 MCMQ\cite{ioannidis2019extracting}，F* 等将程序编译到高性能的平台上的方案，
MCMQ 将 Coq 代码翻译到C++语言而 F* 编译到公共语言运行时（Common Language Runtime, CLR），
但前面说过了，依赖类型系统让程序具有相悖的双重角色是问题的根本来源，
在最后一章将详细论述并与本文的工作进行对比。而作为结论，我个人认为依赖类型系统很优秀，
但不适合用于描述形式化验证所需的那些全部的性质。而作为证明，软件工业界的形式化验证
还没有被依赖类型统治，还是有很多现实的项目拒绝了这一伟大的发现。

现状是，作为总结，软件开发的商业与工业主流已牢牢地得益于各种形式化方法，
形式化方法已渗入软件开发的各个方面，在安全严苛场景已大量地应用，
但对软件普遍地形式化验证仍未到来。
形式化方法的确已经有效地帮助程序开发而形式化验证也已有效地发现并避免了诸多
软件缺陷，但缺陷与漏洞依旧存在。
在一些限定的范围，被验证的程序实现已经能够生产，却
在现实的工业生产的普遍范围内因为种种原因未被广泛应用。
现实软件工业的普遍现状是，缺陷与漏洞始终存在，随处可见。
现实的商业生产尚未选择——因为尚未发现——一种折合成本与收益后更划算的方案，
生产完美无缺的程序实现，即任何已有手段的实施成本本身，相比缺陷本身的潜在危害都更加昂贵。

无论是软件工程方面的现实经济意义，还是计算机科学角度的学术意义，
形式化方法都从未实现它的愿景，因此这“伟大挑战”也得以是一种挑战。

本文尝试寻找并实现这样的形式化方法，它代价不高，不消耗大量的开发成本，
只需要不可规避的专业数学知识与机器证明技能，而本身施行起来不复杂不困难，
进而能被普遍地应用在现实的普通工业生产中；
但却能有效而彻底地证明程序实现的正确性。
