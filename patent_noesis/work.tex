\chapter{本发明的技术方案}
\section{本发明采用的技术方案}

本发明首先开创性地提出 Noesis 对应关系，并以 Noesis 对应关系 $\widesim{\cdot}$ 替代
传统编程语言中的类型关系，以 Noesis 对应关系构成的形式系统 Noesis 形式系统
替代传统的类型系统，以此构建程序，这是本发明的核心技术。

具体而言，Noesis 对应关系 $\widesim{\cdot}$ 是一个三元关系
具有形式 $x \widesim{i} \epsilon$，其中 $x$ 表示程序部分，名叫 {\it 现象}
({\it phenomenon, φαινόμενον})，$i$ 表示理解方式叫做 {\it 理解}
({\it understanding, nóēsis, νόησῐς})，$\epsilon$ 表示程序 $x$ 在理解 $i$ 下的抽象对应，
表示抽象意义，名叫 {\it 本体}({\it noumenon, νoούμενον})。

朴素 Noesis 形式系统围绕 Noesis 对应关系，提供演绎 Noesis 对应关系的定理以构建程序的能力。
图 \ref{fig:naive_noesis_lang} 表示朴素 Noesis 形式系统的形式语言，
其中 $\hat{\mathcal{P}}, \hat{\mathcal{E}}, \mathcal{I}$ 为给定的单词集，
记号 $\bnf{BNF}$ 表示 BNF 语法，最后的 $L_\mathrm{N}$ 即为朴素 Noesis 形式系统的形式语言。
图 \ref{fig:naive_noesis_rule} 为朴素 Noesis 形式系统的演绎规则。
图 \ref{fig:naive_noesis_lang} 与图 \ref{fig:naive_noesis_rule} 共同表示了
朴素 Noesis 形式系统。
其中参数律用于构建参数，一阶同构引入律与一阶同构削除律为技术性操作无实际意义，应用律
用于函数调用，抽象律用于函数构建，对应记号律、同构记号律用于临时变量的引入，
对应记号削除律、同构记号削除律用于函数构建前临时变量的封装。

\noesishol 是 Noesis 形式系统在交互式高阶逻辑证明器（HOL interactive theorem prover）
的逻辑（HOL 逻辑，HOL Logic）上的实现，由图 \ref{fig:noesis-hol-rule} 表示。
它允许使用 HOL 定理证明器应用 Noesis 形式系统，进而演绎 Noesis 对应关系的定理以构建程序。

本发明提出的新技术是取代传统类型系统而以 Noesis 形式系统通过演绎 Noesis 对应关系的
定理以构建程序，这种技术由一个名为 \Eamlh 的软件具体实现。
图 \ref{fig:total-frame} 为软件 \Eamlh 的整体架构。

\Eamlh 的核心原理是在 \noesishol 上设定常量与基元函数，构建出一台抽象机器 \amlh，
并通过 HOL 定理证明器操作抽象机器 \amlh ，最终提供给用户编写抽象机器 \amlh 上程序的
能力，以及将 \amlh 上的程序编译到指定的目标执行环境。

朴素 Noesis 系统、\noesishol、\amlh、\amlh 上的程序，4者之间的关系如图 \ref{fig:noesis-rela}
所示。

抽象机器 \amlh 上的程序是常量与基元函数的组合，基元函数是程序的指令集。
抽象机器 \amlh 上程序的构建方法是， \amlh 中常量与基元函数作为公理置入 \noesishol 系统中，
HOL 定理证明器上实现的 Noesis 系统 \noesishol 对这些公理进行演绎，得出 Noesis 定理，
Noesis 定理即包含所构造的程序与此程序的 Noesis 对应。程序的 Noesis 对应揭示了程序的
抽象意义，对程序的形式化验证就只需要对其抽象意义进行。而抽象意义是数学友好的数理对象，
对其的分析与证明都十分容易与自然，可自然地由 HOL 定理证明器完成。于是 1. 对程序的验证
变为对其意义的验证，形式化验证就被极大地简化。2. 得到了这样的正确性被彻底证明的程序。

软件 \Eamlh 按照上述方法为用户提供构建正确性被彻底证明的程序的能力。具体而言，
图 \ref{fig:total-frame} 中编辑壳层直接与定理证明器交互，用户不需要直接接触复杂的数学理论变换
与定理演绎，编辑壳层提供统一的抽象接口，编辑前端连接到这样的接口，为用户提供各种形式的
用户接口（User Interface）。

\Eamlh 上程序的编译过程如图 \ref{fig:compilation} 所示。\amlh 上的程序首先在编辑壳层对定理证明
器的操作下在定理证明器中被等价变化，定义被逐层展开最终得到常量与基元函数的表达。
这种常量与基元函数的表达作为一种中间表达（Intermediate Representation, IR）由定理证明器输出传入
编辑壳层，编辑壳层再根据用户指令传入用户期望的目标执行环境对应的编译器后端，由编译器后端
最终生成目标执行环境上的可执行程序。

\section{本发明的关键点}
\subsection{以 Noesis 对应替代类型描述并验证程序的性质}

传统编程语言使用类型特别是依赖类型描述程序的性质，以此进行形式化验证。
本发明的技术使用 Noesis 对应替代类型以描述程序的性质。

首先传统编程语言的类型对程序性质的描述能力，除了依赖类型之外，都是有限的，就意味着
类型不能描述程序的所有性质，自然也就无法证明程序的所有特性。
Noesis 对应 $x \widesim{i} \epsilon$ 找到程序 $x$ 在理解 $i$ 下对应的作为抽象意义的
本体 $\epsilon$，这一对应是全面的，程序 $x$ 的任意性质在理解 $i$ 下都体现在本体 $\epsilon$ 上。
而 $\epsilon$ 描述于 HOL 逻辑中，HOL 逻辑具有类似经典逻辑（Classical Logic）
的完整的全面的数学表达能力，
可以表达几乎所有的性质，并证明这些性质。故而 Noesis 对应可以表达程序的几乎所有性质，
至少是所有经典逻辑上能表达的性质。

其次，尽管依赖类型也能表达所有经典逻辑或直觉逻辑的性质，但这种表达是不利于程序开发的。
依赖类型的能力来自于 Curry-Howard 同构，Curry-Howard 同构揭示了程序与证明的对应。
依赖类型系统的程序必须即作为承载工程实现的程序又是对作为类型的定理的证明，同样依赖类型系统的
类型必须兼任命题就意味着必须具有巧妙的数学灵性，以允许作为证明过程的程序对其证明。
这本来就很困难了，让依赖类型系统的类型再承载对程序所期望功能的描述就让依赖类型更加复杂，
于是程序的编写就更加更加困难。
依赖类型系统的程序必须一人分饰两角，同时考虑工程实现的性能，又必须保持巧妙的数学灵性。
一人分饰两角，在现实的舞台上都称得上精彩的戏剧了。

相比而言，Noesis 对应 $x \widesim{i} \epsilon$ 将程序与证明分立。程序部分 $x$ 只负责工程实现，
专注工程实现的性能；本体部分 $\epsilon$ 存在于纯粹抽象的数学世界，是自然且数学友好的数学对象，
允许各种数学分析与证明。一切分析与证明只考察抽象的本体 $\epsilon$，而非
直接操作复杂的数学不友好的程序 $x$，于是形式化分析与验证的效率被根本地改善。

\subsection{分析与证明程序的抽象意义以分析与证明程序}

传统的形式化验证直接分析程序的性质。
但程序是现实而复杂的造物，难以想象如何从一堆状态转移指令中抽象还原以验证其是一段质因数分解程序，
这非常困难，消耗巨大的人力。
大量的例子已经显然地揭示了这一点，看看 SeL4 内核 9300 行的源代码消耗了 $200{,}000$ 行证明代码与
20人年的时间就知道了。

不要直接分析繁杂的现实程序。本发明的方法是，由 Noesis 对应关系 $x \widesim{i} \epsilon$
得到程序 $x$ 在理解 $i$ 下作为抽象意义的本体 $\epsilon$，去分析与验证抽象且数学友好的本体
$\epsilon$ 而不是直接分析繁杂的程序。本体 $\epsilon$ 的性质在 Noesis 对应关系的定理的保障下
即是程序 $x$ 的性质。以此对程序的分析与验证转移为对抽象本体的分析与验证，分析与验证的效率就被
根本改善与得到提升。

\subsection{通过演绎 Noesis  对应定理以构建程序}

传统编程语言中类型系统仅作为程序编写的辅助工具，一种形式化的分析与验证工具。
类型定理被自动地或由用户的标记中推导，而类型检查是对类型关系作为一个命题的证明。

但问题在于，并非所有的命题都可以被自动地证明，事实上数学上已经证明不存在一个万能的算法
证明所有的命题。这意味着总有一些类型关系亦即程序所具有的性质是无法被自动推导得出的；
总有些作为命题的类型关系无法被自动验证或自动证明的。这也是为何不存在一个全自动的定理证明工具，
而一定是交互式的。更复杂的，表达能力更强的类型关系命题，是无法被自动证明的，必须要人的才智。

本发明的方法是，通过演绎 Noesis  对应定理以构建程序。即用户并非编写程序，而是操作编辑壳层演绎
Noesis  对应定理本身，而 Noesis  对应定理中包含程序与程序的抽象意义对应。通过演绎 Noesis  对应定理，
来构建 Noesis  对应定理中那包含着的程序。并在适当的时候，运用适当的证明策略完成特定 Noesis  对应定理
的证明，以完成一些更复杂的程序诸如递归函数的构建。

\subsection{\amlh 基元指令与常量设定的通用性允许生产任意执行环境上的程序}

本发明是一个通用的技术。朴素 Noesis 系统、\noesishol、抽象机 \amlh、以及软件 \Eamlh 
均未限定目标的执行环境。通过具体地设定 \amlh 上的常量与基元指令，本发明提出的技术
可以生产任意场景下任意目标执行环境的正确性被彻底证明的程序实现。

这些执行环境可以是智能合约场景、嵌入式场景；也可以是其他的传统编程语言，即被设定的
 \amlh 允许将其上的程序编译到别的编程语言上；甚至允许超出传统计算机范畴的执行环境，
例如给定量子计算机上的基元指令与常量，如此设定的 \amlh 可以生产正确性被证明的量子计算机
上的程序实现。

\section{本发明的技术效果}

本发明实现了这样的形式化方法，它代价不高，不消耗大量的开发成本，
只需要不可规避的专业数学知识与机器证明技能，而本身施行起来不复杂不困难，
进而能被普遍地应用在现实的普通工业生产中；但却能有效而{\bfseries 彻底地严谨地}
证明程序实现的正确性。

而当一个程序实现的正确性被彻底证明，就不会出现任何程序实现上的缺陷或者漏洞，因为
这是彻底而严谨的数学证明，正确性是被彻底证明的。于是一个软件只可能因为不良的设计
而引入缺陷；而所有的程序实现上的缺陷与漏洞都不可能，因此这程序实现是绝对安全的，
理论上的证明，它不会因程序实现的缺陷被任何黑客攻陷，永远都不会
\footnote{尽管黑客仍然可以发现它在设计上的漏洞——例如通过一一尝试穷举一个3位十进制密码锁
所有可能的密码来破解这把锁子——来攻陷一个系统；或者是绑架系统的管理员，逼问出管理密码，来攻陷一个
系统}。

\chapter{附图}
\input{./patent_noesis/naive_noesis_rule.tex}
\input{./patent_noesis/figure.tex}

